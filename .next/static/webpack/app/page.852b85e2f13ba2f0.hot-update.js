"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BATTERY_OPTIONS: function() { return /* binding */ BATTERY_OPTIONS; },\n/* harmony export */   buildDataQualityReport: function() { return /* binding */ buildDataQualityReport; },\n/* harmony export */   buildDayKwSeries: function() { return /* binding */ buildDayKwSeries; },\n/* harmony export */   buildDayProfile: function() { return /* binding */ buildDayProfile; },\n/* harmony export */   computeSizing: function() { return /* binding */ computeSizing; },\n/* harmony export */   findMaxObserved: function() { return /* binding */ findMaxObserved; },\n/* harmony export */   groupPeakEvents: function() { return /* binding */ groupPeakEvents; },\n/* harmony export */   processIntervals: function() { return /* binding */ processIntervals; },\n/* harmony export */   selectMinimumCostBatteryOptions: function() { return /* binding */ selectMinimumCostBatteryOptions; },\n/* harmony export */   selectTopExceededIntervals: function() { return /* binding */ selectTopExceededIntervals; }\n/* harmony export */ });\n/* harmony import */ var _datetime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime */ \"(app-pages-browser)/./lib/datetime.ts\");\n\nconst BATTERY_OPTIONS = [\n    {\n        label: \"WattsNext ESS Cabinet 64 kWh\",\n        capacityKwh: 64,\n        modular: true,\n        unitPriceEur: 15689.33\n    },\n    {\n        label: \"WattsNext ESS Cabinet 96 kWh\",\n        capacityKwh: 96,\n        modular: true,\n        unitPriceEur: 22225.98\n    },\n    {\n        label: \"ESS All-in-one Cabinet 261 kWh\",\n        capacityKwh: 261,\n        modular: true,\n        unitPriceEur: 43995.96\n    },\n    {\n        label: \"WattsNext All-in-one Container 2.09 MWh\",\n        capacityKwh: 2090,\n        modular: false,\n        unitPriceEur: 318658.06\n    },\n    {\n        label: \"WattsNext All in-one Container 5.015 MWh\",\n        capacityKwh: 5015,\n        modular: false,\n        unitPriceEur: 675052.49\n    }\n];\nfunction roundCurrency(value) {\n    return Math.round(value * 100) / 100;\n}\nfunction toBatteryProduct(candidate) {\n    const totalPriceEur = roundCurrency(candidate.totalPriceEur);\n    return {\n        label: candidate.label,\n        capacityKwh: candidate.totalCapacityKwh,\n        unitCapacityKwh: candidate.unitCapacityKwh,\n        count: candidate.count,\n        unitPriceEur: roundCurrency(candidate.unitPriceEur),\n        totalPriceEur,\n        breakdown: [\n            {\n                type: \"\".concat(candidate.unitCapacityKwh, \" kWh\"),\n                count: candidate.count,\n                unitCapacityKwh: candidate.unitCapacityKwh,\n                unitPriceEur: roundCurrency(candidate.unitPriceEur),\n                totalPriceEur\n            }\n        ]\n    };\n}\nfunction selectMinimumCostBatteryOptions(requiredKwh) {\n    const normalizedRequired = Math.max(0, requiredKwh);\n    const candidates = [];\n    BATTERY_OPTIONS.forEach((option)=>{\n        var _option_unitPriceEur;\n        const unitPriceEur = (_option_unitPriceEur = option.unitPriceEur) !== null && _option_unitPriceEur !== void 0 ? _option_unitPriceEur : 0;\n        if (option.modular) {\n            const maxCount = Math.max(1, Math.ceil(normalizedRequired / option.capacityKwh));\n            for(let count = 1; count <= maxCount; count += 1){\n                const totalCapacityKwh = count * option.capacityKwh;\n                if (totalCapacityKwh < normalizedRequired) continue;\n                const totalPriceEur = count * unitPriceEur;\n                candidates.push({\n                    label: \"\".concat(count, \"x \").concat(option.capacityKwh, \" kWh (modulair)\"),\n                    totalCapacityKwh,\n                    totalPriceEur,\n                    overCapacityKwh: totalCapacityKwh - normalizedRequired,\n                    count,\n                    unitCapacityKwh: option.capacityKwh,\n                    unitPriceEur\n                });\n            }\n            return;\n        }\n        if (option.capacityKwh >= normalizedRequired) {\n            candidates.push({\n                label: option.label,\n                totalCapacityKwh: option.capacityKwh,\n                totalPriceEur: unitPriceEur,\n                overCapacityKwh: option.capacityKwh - normalizedRequired,\n                count: 1,\n                unitCapacityKwh: option.capacityKwh,\n                unitPriceEur\n            });\n        }\n    });\n    const sorted = candidates.sort((a, b)=>a.totalPriceEur - b.totalPriceEur || a.overCapacityKwh - b.overCapacityKwh || a.totalCapacityKwh - b.totalCapacityKwh);\n    const recommendedProduct = toBatteryProduct(sorted[0]);\n    const alternativeProduct = sorted[1] ? toBatteryProduct(sorted[1]) : null;\n    return {\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction processIntervals(rows, contractedPowerKw) {\n    return rows.map((row)=>{\n        const timestamp = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(row.timestamp);\n        const normalizedTimestamp = Number.isNaN(timestamp.getTime()) ? row.timestamp : timestamp.toISOString();\n        const consumptionKw = row.consumptionKwh / 0.25;\n        const excessKw = Math.max(0, consumptionKw - contractedPowerKw);\n        return {\n            ...row,\n            timestamp: normalizedTimestamp,\n            consumptionKw,\n            excessKw,\n            excessKwh: excessKw * 0.25\n        };\n    });\n}\nfunction groupPeakEvents(intervals) {\n    const events = [];\n    let current = null;\n    intervals.forEach((interval, index)=>{\n        if (interval.excessKw > 0) {\n            if (!current) {\n                current = {\n                    peakTimestamp: interval.timestamp,\n                    durationIntervals: 0,\n                    maxExcessKw: 0,\n                    totalExcessKwh: 0,\n                    intervalIndexes: []\n                };\n            }\n            current.durationIntervals += 1;\n            if (interval.excessKw > current.maxExcessKw || interval.excessKw === current.maxExcessKw && interval.timestamp < current.peakTimestamp) {\n                current.maxExcessKw = interval.excessKw;\n                current.peakTimestamp = interval.timestamp;\n            }\n            current.totalExcessKwh += interval.excessKwh;\n            current.intervalIndexes.push(index);\n        } else if (current) {\n            events.push(current);\n            current = null;\n        }\n    });\n    if (current) {\n        events.push(current);\n    }\n    return events;\n}\nfunction percentile(values, p) {\n    if (values.length === 0) return 0;\n    const sorted = [\n        ...values\n    ].sort((a, b)=>a - b);\n    const idx = Math.ceil(p / 100 * sorted.length) - 1;\n    return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\n}\nfunction computeSizing(params) {\n    const { intervals, events, method, compliance, safetyFactor, efficiency } = params;\n    let kWhNeededRaw = 0;\n    let kWNeededRaw = 0;\n    if (method === \"MAX_PEAK\") {\n        const highestEnergyEvent = [\n            ...events\n        ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n        if (highestEnergyEvent) {\n            kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n            kWNeededRaw = highestEnergyEvent.maxExcessKw;\n        }\n    }\n    if (method === \"P95\") {\n        if (events.length < 20) {\n            const highestEnergyEvent = [\n                ...events\n            ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n            if (highestEnergyEvent) {\n                kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n                kWNeededRaw = highestEnergyEvent.maxExcessKw;\n            }\n        } else {\n            kWhNeededRaw = percentile(events.map((event)=>event.totalExcessKwh), 95);\n            kWNeededRaw = percentile(events.map((event)=>event.maxExcessKw), 95);\n        }\n    }\n    if (method === \"FULL_COVERAGE\") {\n        const byDay = new Map();\n        intervals.forEach((interval)=>{\n            const day = interval.timestamp.slice(0, 10);\n            var _byDay_get;\n            const list = (_byDay_get = byDay.get(day)) !== null && _byDay_get !== void 0 ? _byDay_get : [];\n            list.push(interval);\n            byDay.set(day, list);\n        });\n        let maxDayEnergy = 0;\n        let maxDayPeak = 0;\n        byDay.forEach((dayIntervals)=>{\n            const dayEnergy = dayIntervals.reduce((sum, interval)=>sum + interval.excessKwh, 0);\n            if (dayEnergy > maxDayEnergy) {\n                maxDayEnergy = dayEnergy;\n                maxDayPeak = Math.max(...dayIntervals.map((interval)=>interval.excessKw));\n            }\n        });\n        kWhNeededRaw = maxDayEnergy;\n        kWNeededRaw = maxDayPeak;\n    }\n    kWhNeededRaw *= compliance;\n    kWNeededRaw *= compliance;\n    const kWhNeeded = kWhNeededRaw / efficiency * safetyFactor;\n    const kWNeeded = kWNeededRaw * safetyFactor;\n    const { recommendedProduct, alternativeProduct } = selectMinimumCostBatteryOptions(kWhNeeded);\n    return {\n        kWhNeededRaw,\n        kWNeededRaw,\n        kWhNeeded,\n        kWNeeded,\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction buildDataQualityReport(intervals) {\n    var _timestamps_, _timestamps_1;\n    if (intervals.length === 0) {\n        return {\n            rows: 0,\n            startDate: null,\n            endDate: null,\n            missingIntervalsCount: 0,\n            duplicateCount: 0,\n            non15MinIntervals: 0,\n            warnings: [\n                \"No rows found in dataset.\"\n            ]\n        };\n    }\n    const timestamps = intervals.map((row)=>new Date(row.timestamp)).filter((date)=>!Number.isNaN(date.getTime())).sort((a, b)=>a.getTime() - b.getTime());\n    const duplicateCount = timestamps.length - new Set(timestamps.map((d)=>d.toISOString())).size;\n    let non15MinIntervals = 0;\n    let missingIntervalsCount = 0;\n    const EPS = 0.01;\n    for(let i = 1; i < timestamps.length; i += 1){\n        const diffMinutes = (timestamps[i].getTime() - timestamps[i - 1].getTime()) / 60000;\n        if (Math.abs(diffMinutes - 15) > EPS) {\n            non15MinIntervals += 1;\n            if (diffMinutes > 15 + EPS) {\n                missingIntervalsCount += Math.max(0, Math.round(diffMinutes / 15) - 1);\n            }\n        }\n    }\n    const warnings = [];\n    if (duplicateCount > 0) warnings.push(\"Detected \".concat(duplicateCount, \" duplicate timestamps.\"));\n    if (non15MinIntervals > 0) {\n        warnings.push(\"Detected \".concat(non15MinIntervals, \" non-15-minute interval transitions.\"));\n    }\n    var _timestamps__toISOString, _timestamps__toISOString1;\n    return {\n        rows: intervals.length,\n        startDate: (_timestamps__toISOString = (_timestamps_ = timestamps[0]) === null || _timestamps_ === void 0 ? void 0 : _timestamps_.toISOString()) !== null && _timestamps__toISOString !== void 0 ? _timestamps__toISOString : null,\n        endDate: (_timestamps__toISOString1 = (_timestamps_1 = timestamps[timestamps.length - 1]) === null || _timestamps_1 === void 0 ? void 0 : _timestamps_1.toISOString()) !== null && _timestamps__toISOString1 !== void 0 ? _timestamps__toISOString1 : null,\n        missingIntervalsCount,\n        duplicateCount,\n        non15MinIntervals,\n        warnings\n    };\n}\nfunction findMaxObserved(intervals) {\n    if (intervals.length === 0) {\n        return {\n            maxObservedKw: 0,\n            maxObservedTimestamp: null\n        };\n    }\n    let maxObservedKw = -1;\n    let maxObservedTimestamp = null;\n    intervals.forEach((interval)=>{\n        if (interval.consumptionKw > maxObservedKw || interval.consumptionKw === maxObservedKw && maxObservedTimestamp !== null && interval.timestamp < maxObservedTimestamp) {\n            maxObservedKw = interval.consumptionKw;\n            maxObservedTimestamp = interval.timestamp;\n        }\n    });\n    return {\n        maxObservedKw,\n        maxObservedTimestamp\n    };\n}\nfunction selectTopExceededIntervals(intervals, day) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;\n    return intervals.filter((interval)=>(0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp) === day && interval.excessKw > 0).sort((a, b)=>b.excessKw - a.excessKw || a.timestamp.localeCompare(b.timestamp)).slice(0, limit).map((interval)=>({\n            timestamp: interval.timestamp,\n            consumption_kW: interval.consumptionKw,\n            excess_kW: interval.excessKw\n        }));\n}\nfunction buildDayProfile(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    const fullDaySeries = buildDayKwSeries(intervals.map((interval)=>({\n            timestamp: interval.timestamp,\n            consumptionKw: interval.consumptionKw\n        })), dayIso, intervalMinutes, timeZone);\n    return fullDaySeries.map((slot)=>({\n            timestampLabel: slot.timeLabel,\n            timestampIso: slot.timestampIso,\n            observedKw: slot.consumptionKw\n        }));\n}\nfunction buildDayKwSeries(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    if (!dayIso || intervalMinutes <= 0) return [];\n    const [year, month, day] = dayIso.split(\"-\").map(Number);\n    const dayStartLocal = new Date(year, month - 1, day, 0, 0, 0, 0);\n    if (Number.isNaN(dayStartLocal.getTime())) return [];\n    const slotsPerDay = Math.floor(24 * 60 / intervalMinutes);\n    const profile = Array.from({\n        length: slotsPerDay\n    }, (_, index)=>{\n        const minutes = index * intervalMinutes;\n        const hour = Math.floor(minutes / 60);\n        const minute = minutes % 60;\n        return {\n            timeLabel: \"\".concat(String(hour).padStart(2, \"0\"), \":\").concat(String(minute).padStart(2, \"0\")),\n            timestampIso: new Date(dayStartLocal.getTime() + minutes * 60000).toISOString(),\n            consumptionKw: 0\n        };\n    });\n    intervals.forEach((interval)=>{\n        if ((0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp, timeZone) !== dayIso) return;\n        const dt = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(interval.timestamp);\n        if (Number.isNaN(dt.getTime())) return;\n        const { hour, minute } = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalHourMinute)(dt, timeZone);\n        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return;\n        const minuteOfDay = hour * 60 + minute;\n        const slotIndex = Math.floor(minuteOfDay / intervalMinutes);\n        if (slotIndex < 0 || slotIndex >= slotsPerDay) return;\n        profile[slotIndex].consumptionKw = Math.max(profile[slotIndex].consumptionKw, interval.consumptionKw);\n    });\n    return profile;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jYWxjdWxhdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Y7QUFpRnpFLE1BQU1HLGtCQUFvQztJQUMvQztRQUNFQyxPQUFPO1FBQ1BDLGFBQWE7UUFDYkMsU0FBUztRQUNUQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsY0FBYztJQUNoQjtJQUNBO1FBQ0VILE9BQU87UUFDUEMsYUFBYTtRQUNiQyxTQUFTO1FBQ1RDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxPQUFPO1FBQ1BDLGFBQWE7UUFDYkMsU0FBUztRQUNUQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsY0FBYztJQUNoQjtDQUNELENBQUM7QUFZRixTQUFTQyxjQUFjQyxLQUFhO0lBQ2xDLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0YsUUFBUSxPQUFPO0FBQ25DO0FBRUEsU0FBU0csaUJBQWlCQyxTQUF3QztJQUNoRSxNQUFNQyxnQkFBZ0JOLGNBQWNLLFVBQVVDLGFBQWE7SUFDM0QsT0FBTztRQUNMVixPQUFPUyxVQUFVVCxLQUFLO1FBQ3RCQyxhQUFhUSxVQUFVRSxnQkFBZ0I7UUFDdkNDLGlCQUFpQkgsVUFBVUcsZUFBZTtRQUMxQ0MsT0FBT0osVUFBVUksS0FBSztRQUN0QlYsY0FBY0MsY0FBY0ssVUFBVU4sWUFBWTtRQUNsRE87UUFDQUksV0FBVztZQUNUO2dCQUNFQyxNQUFNLEdBQTZCLE9BQTFCTixVQUFVRyxlQUFlLEVBQUM7Z0JBQ25DQyxPQUFPSixVQUFVSSxLQUFLO2dCQUN0QkQsaUJBQWlCSCxVQUFVRyxlQUFlO2dCQUMxQ1QsY0FBY0MsY0FBY0ssVUFBVU4sWUFBWTtnQkFDbERPO1lBQ0Y7U0FDRDtJQUNIO0FBQ0Y7QUFFTyxTQUFTTSxnQ0FBZ0NDLFdBQW1CO0lBSWpFLE1BQU1DLHFCQUFxQlosS0FBS2EsR0FBRyxDQUFDLEdBQUdGO0lBQ3ZDLE1BQU1HLGFBQThDLEVBQUU7SUFFdERyQixnQkFBZ0JzQixPQUFPLENBQUMsQ0FBQ0M7WUFDRkE7UUFBckIsTUFBTW5CLGVBQWVtQixDQUFBQSx1QkFBQUEsT0FBT25CLFlBQVksY0FBbkJtQixrQ0FBQUEsdUJBQXVCO1FBQzVDLElBQUlBLE9BQU9wQixPQUFPLEVBQUU7WUFDbEIsTUFBTXFCLFdBQVdqQixLQUFLYSxHQUFHLENBQUMsR0FBR2IsS0FBS2tCLElBQUksQ0FBQ04scUJBQXFCSSxPQUFPckIsV0FBVztZQUM5RSxJQUFLLElBQUlZLFFBQVEsR0FBR0EsU0FBU1UsVUFBVVYsU0FBUyxFQUFHO2dCQUNqRCxNQUFNRixtQkFBbUJFLFFBQVFTLE9BQU9yQixXQUFXO2dCQUNuRCxJQUFJVSxtQkFBbUJPLG9CQUFvQjtnQkFDM0MsTUFBTVIsZ0JBQWdCRyxRQUFRVjtnQkFDOUJpQixXQUFXSyxJQUFJLENBQUM7b0JBQ2R6QixPQUFPLEdBQWFzQixPQUFWVCxPQUFNLE1BQXVCLE9BQW5CUyxPQUFPckIsV0FBVyxFQUFDO29CQUN2Q1U7b0JBQ0FEO29CQUNBZ0IsaUJBQWlCZixtQkFBbUJPO29CQUNwQ0w7b0JBQ0FELGlCQUFpQlUsT0FBT3JCLFdBQVc7b0JBQ25DRTtnQkFDRjtZQUNGO1lBQ0E7UUFDRjtRQUVBLElBQUltQixPQUFPckIsV0FBVyxJQUFJaUIsb0JBQW9CO1lBQzVDRSxXQUFXSyxJQUFJLENBQUM7Z0JBQ2R6QixPQUFPc0IsT0FBT3RCLEtBQUs7Z0JBQ25CVyxrQkFBa0JXLE9BQU9yQixXQUFXO2dCQUNwQ1MsZUFBZVA7Z0JBQ2Z1QixpQkFBaUJKLE9BQU9yQixXQUFXLEdBQUdpQjtnQkFDdENMLE9BQU87Z0JBQ1BELGlCQUFpQlUsT0FBT3JCLFdBQVc7Z0JBQ25DRTtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE1BQU13QixTQUFTUCxXQUFXUSxJQUFJLENBQzVCLENBQUNDLEdBQUdDLElBQ0ZELEVBQUVuQixhQUFhLEdBQUdvQixFQUFFcEIsYUFBYSxJQUNqQ21CLEVBQUVILGVBQWUsR0FBR0ksRUFBRUosZUFBZSxJQUNyQ0csRUFBRWxCLGdCQUFnQixHQUFHbUIsRUFBRW5CLGdCQUFnQjtJQUczQyxNQUFNb0IscUJBQXFCdkIsaUJBQWlCbUIsTUFBTSxDQUFDLEVBQUU7SUFDckQsTUFBTUsscUJBQXFCTCxNQUFNLENBQUMsRUFBRSxHQUFHbkIsaUJBQWlCbUIsTUFBTSxDQUFDLEVBQUUsSUFBSTtJQUVyRSxPQUFPO1FBQUVJO1FBQW9CQztJQUFtQjtBQUNsRDtBQUVPLFNBQVNDLGlCQUNkQyxJQUFzQixFQUN0QkMsaUJBQXlCO0lBRXpCLE9BQU9ELEtBQUtFLEdBQUcsQ0FBQyxDQUFDQztRQUNmLE1BQU1DLFlBQVl4Qyx5REFBY0EsQ0FBQ3VDLElBQUlDLFNBQVM7UUFDOUMsTUFBTUMsc0JBQXNCQyxPQUFPQyxLQUFLLENBQUNILFVBQVVJLE9BQU8sTUFBTUwsSUFBSUMsU0FBUyxHQUFHQSxVQUFVSyxXQUFXO1FBQ3JHLE1BQU1DLGdCQUFnQlAsSUFBSVEsY0FBYyxHQUFHO1FBQzNDLE1BQU1DLFdBQVd4QyxLQUFLYSxHQUFHLENBQUMsR0FBR3lCLGdCQUFnQlQ7UUFDN0MsT0FBTztZQUNMLEdBQUdFLEdBQUc7WUFDTkMsV0FBV0M7WUFDWEs7WUFDQUU7WUFDQUMsV0FBV0QsV0FBVztRQUN4QjtJQUNGO0FBQ0Y7QUFFTyxTQUFTRSxnQkFBZ0JDLFNBQThCO0lBQzVELE1BQU1DLFNBQXNCLEVBQUU7SUFDOUIsSUFBSUMsVUFBNEI7SUFFaENGLFVBQVU1QixPQUFPLENBQUMsQ0FBQytCLFVBQVVDO1FBQzNCLElBQUlELFNBQVNOLFFBQVEsR0FBRyxHQUFHO1lBQ3pCLElBQUksQ0FBQ0ssU0FBUztnQkFDWkEsVUFBVTtvQkFDUkcsZUFBZUYsU0FBU2QsU0FBUztvQkFDakNpQixtQkFBbUI7b0JBQ25CQyxhQUFhO29CQUNiQyxnQkFBZ0I7b0JBQ2hCQyxpQkFBaUIsRUFBRTtnQkFDckI7WUFDRjtZQUNBUCxRQUFRSSxpQkFBaUIsSUFBSTtZQUM3QixJQUNFSCxTQUFTTixRQUFRLEdBQUdLLFFBQVFLLFdBQVcsSUFDdENKLFNBQVNOLFFBQVEsS0FBS0ssUUFBUUssV0FBVyxJQUFJSixTQUFTZCxTQUFTLEdBQUdhLFFBQVFHLGFBQWEsRUFDeEY7Z0JBQ0FILFFBQVFLLFdBQVcsR0FBR0osU0FBU04sUUFBUTtnQkFDdkNLLFFBQVFHLGFBQWEsR0FBR0YsU0FBU2QsU0FBUztZQUM1QztZQUNBYSxRQUFRTSxjQUFjLElBQUlMLFNBQVNMLFNBQVM7WUFDNUNJLFFBQVFPLGVBQWUsQ0FBQ2pDLElBQUksQ0FBQzRCO1FBQy9CLE9BQU8sSUFBSUYsU0FBUztZQUNsQkQsT0FBT3pCLElBQUksQ0FBQzBCO1lBQ1pBLFVBQVU7UUFDWjtJQUNGO0lBRUEsSUFBSUEsU0FBUztRQUNYRCxPQUFPekIsSUFBSSxDQUFDMEI7SUFDZDtJQUVBLE9BQU9EO0FBQ1Q7QUFFQSxTQUFTUyxXQUFXQyxNQUFnQixFQUFFQyxDQUFTO0lBQzdDLElBQUlELE9BQU9FLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFDaEMsTUFBTW5DLFNBQVM7V0FBSWlDO0tBQU8sQ0FBQ2hDLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQztJQUM5QyxNQUFNaUMsTUFBTXpELEtBQUtrQixJQUFJLENBQUMsSUFBSyxNQUFPRyxPQUFPbUMsTUFBTSxJQUFJO0lBQ25ELE9BQU9uQyxNQUFNLENBQUNyQixLQUFLYSxHQUFHLENBQUMsR0FBR2IsS0FBSzBELEdBQUcsQ0FBQ0QsS0FBS3BDLE9BQU9tQyxNQUFNLEdBQUcsSUFBSTtBQUM5RDtBQUVPLFNBQVNHLGNBQWNDLE1BTzdCO0lBQ0MsTUFBTSxFQUFFakIsU0FBUyxFQUFFQyxNQUFNLEVBQUVpQixNQUFNLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxFQUFFQyxVQUFVLEVBQUUsR0FBR0o7SUFFNUUsSUFBSUssZUFBZTtJQUNuQixJQUFJQyxjQUFjO0lBRWxCLElBQUlMLFdBQVcsWUFBWTtRQUN6QixNQUFNTSxxQkFBcUI7ZUFBSXZCO1NBQU8sQ0FBQ3RCLElBQUksQ0FDekMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRTJCLGNBQWMsR0FBRzVCLEVBQUU0QixjQUFjLENBQzlDLENBQUMsRUFBRTtRQUNKLElBQUlnQixvQkFBb0I7WUFDdEJGLGVBQWVFLG1CQUFtQmhCLGNBQWM7WUFDaERlLGNBQWNDLG1CQUFtQmpCLFdBQVc7UUFDOUM7SUFDRjtJQUVBLElBQUlXLFdBQVcsT0FBTztRQUNwQixJQUFJakIsT0FBT1ksTUFBTSxHQUFHLElBQUk7WUFDdEIsTUFBTVcscUJBQXFCO21CQUFJdkI7YUFBTyxDQUFDdEIsSUFBSSxDQUN6QyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFMkIsY0FBYyxHQUFHNUIsRUFBRTRCLGNBQWMsQ0FDOUMsQ0FBQyxFQUFFO1lBQ0osSUFBSWdCLG9CQUFvQjtnQkFDdEJGLGVBQWVFLG1CQUFtQmhCLGNBQWM7Z0JBQ2hEZSxjQUFjQyxtQkFBbUJqQixXQUFXO1lBQzlDO1FBQ0YsT0FBTztZQUNMZSxlQUFlWixXQUNiVCxPQUFPZCxHQUFHLENBQUMsQ0FBQ3NDLFFBQVVBLE1BQU1qQixjQUFjLEdBQzFDO1lBRUZlLGNBQWNiLFdBQ1pULE9BQU9kLEdBQUcsQ0FBQyxDQUFDc0MsUUFBVUEsTUFBTWxCLFdBQVcsR0FDdkM7UUFFSjtJQUNGO0lBRUEsSUFBSVcsV0FBVyxpQkFBaUI7UUFDOUIsTUFBTVEsUUFBUSxJQUFJQztRQUNsQjNCLFVBQVU1QixPQUFPLENBQUMsQ0FBQytCO1lBQ2pCLE1BQU15QixNQUFNekIsU0FBU2QsU0FBUyxDQUFDd0MsS0FBSyxDQUFDLEdBQUc7Z0JBQzNCSDtZQUFiLE1BQU1JLE9BQU9KLENBQUFBLGFBQUFBLE1BQU1LLEdBQUcsQ0FBQ0gsa0JBQVZGLHdCQUFBQSxhQUFrQixFQUFFO1lBQ2pDSSxLQUFLdEQsSUFBSSxDQUFDMkI7WUFDVnVCLE1BQU1NLEdBQUcsQ0FBQ0osS0FBS0U7UUFDakI7UUFFQSxJQUFJRyxlQUFlO1FBQ25CLElBQUlDLGFBQWE7UUFFakJSLE1BQU10RCxPQUFPLENBQUMsQ0FBQytEO1lBQ2IsTUFBTUMsWUFBWUQsYUFBYUUsTUFBTSxDQUFDLENBQUNDLEtBQUtuQyxXQUFhbUMsTUFBTW5DLFNBQVNMLFNBQVMsRUFBRTtZQUNuRixJQUFJc0MsWUFBWUgsY0FBYztnQkFDNUJBLGVBQWVHO2dCQUNmRixhQUFhN0UsS0FBS2EsR0FBRyxJQUFJaUUsYUFBYWhELEdBQUcsQ0FBQyxDQUFDZ0IsV0FBYUEsU0FBU04sUUFBUTtZQUMzRTtRQUNGO1FBRUF5QixlQUFlVztRQUNmVixjQUFjVztJQUNoQjtJQUVBWixnQkFBZ0JIO0lBQ2hCSSxlQUFlSjtJQUVmLE1BQU1vQixZQUFZLGVBQWdCbEIsYUFBY0Q7SUFDaEQsTUFBTW9CLFdBQVdqQixjQUFjSDtJQUUvQixNQUFNLEVBQUV0QyxrQkFBa0IsRUFBRUMsa0JBQWtCLEVBQUUsR0FBR2hCLGdDQUFnQ3dFO0lBRW5GLE9BQU87UUFDTGpCO1FBQ0FDO1FBQ0FnQjtRQUNBQztRQUNBMUQ7UUFDQUM7SUFDRjtBQUNGO0FBRU8sU0FBUzBELHVCQUF1QnpDLFNBQTJCO1FBeUNuRDBDLGNBQ0ZBO0lBekNYLElBQUkxQyxVQUFVYSxNQUFNLEtBQUssR0FBRztRQUMxQixPQUFPO1lBQ0w1QixNQUFNO1lBQ04wRCxXQUFXO1lBQ1hDLFNBQVM7WUFDVEMsdUJBQXVCO1lBQ3ZCQyxnQkFBZ0I7WUFDaEJDLG1CQUFtQjtZQUNuQkMsVUFBVTtnQkFBQzthQUE0QjtRQUN6QztJQUNGO0lBRUEsTUFBTU4sYUFBYTFDLFVBQ2hCYixHQUFHLENBQUMsQ0FBQ0MsTUFBUSxJQUFJNkQsS0FBSzdELElBQUlDLFNBQVMsR0FDbkM2RCxNQUFNLENBQUMsQ0FBQ0MsT0FBUyxDQUFDNUQsT0FBT0MsS0FBSyxDQUFDMkQsS0FBSzFELE9BQU8sS0FDM0NkLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFYSxPQUFPLEtBQUtaLEVBQUVZLE9BQU87SUFFekMsTUFBTXFELGlCQUFpQkosV0FBVzdCLE1BQU0sR0FBRyxJQUFJdUMsSUFBSVYsV0FBV3ZELEdBQUcsQ0FBQyxDQUFDa0UsSUFBTUEsRUFBRTNELFdBQVcsS0FBSzRELElBQUk7SUFDL0YsSUFBSVAsb0JBQW9CO0lBQ3hCLElBQUlGLHdCQUF3QjtJQUM1QixNQUFNVSxNQUFNO0lBRVosSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlkLFdBQVc3QixNQUFNLEVBQUUyQyxLQUFLLEVBQUc7UUFDN0MsTUFBTUMsY0FBYyxDQUFDZixVQUFVLENBQUNjLEVBQUUsQ0FBQy9ELE9BQU8sS0FBS2lELFVBQVUsQ0FBQ2MsSUFBSSxFQUFFLENBQUMvRCxPQUFPLEVBQUMsSUFBSztRQUM5RSxJQUFJcEMsS0FBS3FHLEdBQUcsQ0FBQ0QsY0FBYyxNQUFNRixLQUFLO1lBQ3BDUixxQkFBcUI7WUFDckIsSUFBSVUsY0FBYyxLQUFLRixLQUFLO2dCQUMxQlYseUJBQXlCeEYsS0FBS2EsR0FBRyxDQUFDLEdBQUdiLEtBQUtDLEtBQUssQ0FBQ21HLGNBQWMsTUFBTTtZQUN0RTtRQUNGO0lBQ0Y7SUFFQSxNQUFNVCxXQUFxQixFQUFFO0lBQzdCLElBQUlGLGlCQUFpQixHQUFHRSxTQUFTeEUsSUFBSSxDQUFDLFlBQTJCLE9BQWZzRSxnQkFBZTtJQUNqRSxJQUFJQyxvQkFBb0IsR0FBRztRQUN6QkMsU0FBU3hFLElBQUksQ0FBQyxZQUE4QixPQUFsQnVFLG1CQUFrQjtJQUM5QztRQUlhTCwwQkFDRkE7SUFIWCxPQUFPO1FBQ0x6RCxNQUFNZSxVQUFVYSxNQUFNO1FBQ3RCOEIsV0FBV0QsQ0FBQUEsNEJBQUFBLGVBQUFBLFVBQVUsQ0FBQyxFQUFFLGNBQWJBLG1DQUFBQSxhQUFlaEQsV0FBVyxnQkFBMUJnRCxzQ0FBQUEsMkJBQWdDO1FBQzNDRSxTQUFTRixDQUFBQSw2QkFBQUEsZ0JBQUFBLFVBQVUsQ0FBQ0EsV0FBVzdCLE1BQU0sR0FBRyxFQUFFLGNBQWpDNkIsb0NBQUFBLGNBQW1DaEQsV0FBVyxnQkFBOUNnRCx1Q0FBQUEsNEJBQW9EO1FBQzdERztRQUNBQztRQUNBQztRQUNBQztJQUNGO0FBQ0Y7QUFFTyxTQUFTVyxnQkFBZ0IzRCxTQUE4QjtJQUk1RCxJQUFJQSxVQUFVYSxNQUFNLEtBQUssR0FBRztRQUMxQixPQUFPO1lBQ0wrQyxlQUFlO1lBQ2ZDLHNCQUFzQjtRQUN4QjtJQUNGO0lBRUEsSUFBSUQsZ0JBQWdCLENBQUM7SUFDckIsSUFBSUMsdUJBQXNDO0lBRTFDN0QsVUFBVTVCLE9BQU8sQ0FBQyxDQUFDK0I7UUFDakIsSUFDRUEsU0FBU1IsYUFBYSxHQUFHaUUsaUJBQ3hCekQsU0FBU1IsYUFBYSxLQUFLaUUsaUJBQzFCQyx5QkFBeUIsUUFDekIxRCxTQUFTZCxTQUFTLEdBQUd3RSxzQkFDdkI7WUFDQUQsZ0JBQWdCekQsU0FBU1IsYUFBYTtZQUN0Q2tFLHVCQUF1QjFELFNBQVNkLFNBQVM7UUFDM0M7SUFDRjtJQUVBLE9BQU87UUFDTHVFO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVPLFNBQVNDLDJCQUNkOUQsU0FBOEIsRUFDOUI0QixHQUFXO1FBQ1htQyxRQUFBQSxpRUFBUTtJQUVSLE9BQU8vRCxVQUNKa0QsTUFBTSxDQUFDLENBQUMvQyxXQUFheEQseURBQWNBLENBQUN3RCxTQUFTZCxTQUFTLE1BQU11QyxPQUFPekIsU0FBU04sUUFBUSxHQUFHLEdBQ3ZGbEIsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVnQixRQUFRLEdBQUdqQixFQUFFaUIsUUFBUSxJQUFJakIsRUFBRVMsU0FBUyxDQUFDMkUsYUFBYSxDQUFDbkYsRUFBRVEsU0FBUyxHQUMvRXdDLEtBQUssQ0FBQyxHQUFHa0MsT0FDVDVFLEdBQUcsQ0FBQyxDQUFDZ0IsV0FBYztZQUNsQmQsV0FBV2MsU0FBU2QsU0FBUztZQUM3QjRFLGdCQUFnQjlELFNBQVNSLGFBQWE7WUFDdEN1RSxXQUFXL0QsU0FBU04sUUFBUTtRQUM5QjtBQUNKO0FBRU8sU0FBU3NFLGdCQUNkbkUsU0FBOEIsRUFDOUJvRSxNQUFjO1FBQ2RDLGtCQUFBQSxpRUFBa0IsSUFDbEJDLFdBQUFBLGlFQUFXO0lBRVgsTUFBTUMsZ0JBQWdCQyxpQkFDcEJ4RSxVQUFVYixHQUFHLENBQUMsQ0FBQ2dCLFdBQWM7WUFDM0JkLFdBQVdjLFNBQVNkLFNBQVM7WUFDN0JNLGVBQWVRLFNBQVNSLGFBQWE7UUFDdkMsS0FDQXlFLFFBQ0FDLGlCQUNBQztJQUdGLE9BQU9DLGNBQWNwRixHQUFHLENBQUMsQ0FBQ3NGLE9BQVU7WUFDbENDLGdCQUFnQkQsS0FBS0UsU0FBUztZQUM5QkMsY0FBY0gsS0FBS0csWUFBWTtZQUMvQkMsWUFBWUosS0FBSzlFLGFBQWE7UUFDaEM7QUFDRjtBQUVPLFNBQVM2RSxpQkFDZHhFLFNBQXlELEVBQ3pEb0UsTUFBYztRQUNkQyxrQkFBQUEsaUVBQWtCLElBQ2xCQyxXQUFBQSxpRUFBVztJQUVYLElBQUksQ0FBQ0YsVUFBVUMsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0lBRTlDLE1BQU0sQ0FBQ1MsTUFBTUMsT0FBT25ELElBQUksR0FBR3dDLE9BQU9ZLEtBQUssQ0FBQyxLQUFLN0YsR0FBRyxDQUFDSTtJQUNqRCxNQUFNMEYsZ0JBQWdCLElBQUloQyxLQUFLNkIsTUFBTUMsUUFBUSxHQUFHbkQsS0FBSyxHQUFHLEdBQUcsR0FBRztJQUM5RCxJQUFJckMsT0FBT0MsS0FBSyxDQUFDeUYsY0FBY3hGLE9BQU8sS0FBSyxPQUFPLEVBQUU7SUFFcEQsTUFBTXlGLGNBQWM3SCxLQUFLOEgsS0FBSyxDQUFDLEtBQU0sS0FBTWQ7SUFDM0MsTUFBTWUsVUFBVUMsTUFBTUMsSUFBSSxDQUFDO1FBQUV6RSxRQUFRcUU7SUFBWSxHQUFHLENBQUNLLEdBQUduRjtRQUN0RCxNQUFNb0YsVUFBVXBGLFFBQVFpRTtRQUN4QixNQUFNb0IsT0FBT3BJLEtBQUs4SCxLQUFLLENBQUNLLFVBQVU7UUFDbEMsTUFBTUUsU0FBU0YsVUFBVTtRQUN6QixPQUFPO1lBQ0xiLFdBQVcsR0FBb0NnQixPQUFqQ0EsT0FBT0YsTUFBTUcsUUFBUSxDQUFDLEdBQUcsTUFBSyxLQUFtQyxPQUFoQ0QsT0FBT0QsUUFBUUUsUUFBUSxDQUFDLEdBQUc7WUFDMUVoQixjQUFjLElBQUkzQixLQUFLZ0MsY0FBY3hGLE9BQU8sS0FBSytGLFVBQVUsT0FBUTlGLFdBQVc7WUFDOUVDLGVBQWU7UUFDakI7SUFDRjtJQUVBSyxVQUFVNUIsT0FBTyxDQUFDLENBQUMrQjtRQUNqQixJQUFJeEQseURBQWNBLENBQUN3RCxTQUFTZCxTQUFTLEVBQUVpRixjQUFjRixRQUFRO1FBRTdELE1BQU15QixLQUFLaEoseURBQWNBLENBQUNzRCxTQUFTZCxTQUFTO1FBQzVDLElBQUlFLE9BQU9DLEtBQUssQ0FBQ3FHLEdBQUdwRyxPQUFPLEtBQUs7UUFDaEMsTUFBTSxFQUFFZ0csSUFBSSxFQUFFQyxNQUFNLEVBQUUsR0FBRzlJLDZEQUFrQkEsQ0FBQ2lKLElBQUl2QjtRQUNoRCxJQUFJLENBQUMvRSxPQUFPdUcsUUFBUSxDQUFDTCxTQUFTLENBQUNsRyxPQUFPdUcsUUFBUSxDQUFDSixTQUFTO1FBRXhELE1BQU1LLGNBQWNOLE9BQU8sS0FBS0M7UUFDaEMsTUFBTU0sWUFBWTNJLEtBQUs4SCxLQUFLLENBQUNZLGNBQWMxQjtRQUMzQyxJQUFJMkIsWUFBWSxLQUFLQSxhQUFhZCxhQUFhO1FBRS9DRSxPQUFPLENBQUNZLFVBQVUsQ0FBQ3JHLGFBQWEsR0FBR3RDLEtBQUthLEdBQUcsQ0FBQ2tILE9BQU8sQ0FBQ1ksVUFBVSxDQUFDckcsYUFBYSxFQUFFUSxTQUFTUixhQUFhO0lBQ3RHO0lBRUEsT0FBT3lGO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2NhbGN1bGF0aW9ucy50cz8zZjc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExvY2FsRGF5SXNvLCBnZXRMb2NhbEhvdXJNaW51dGUsIHBhcnNlVGltZXN0YW1wIH0gZnJvbSAnLi9kYXRldGltZSc7XG5cbmV4cG9ydCB0eXBlIE1ldGhvZCA9ICdNQVhfUEVBSycgfCAnUDk1JyB8ICdGVUxMX0NPVkVSQUdFJztcblxyXG5leHBvcnQgaW50ZXJmYWNlIEludGVydmFsUmVjb3JkIHtcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxuICBjb25zdW1wdGlvbkt3aDogbnVtYmVyO1xyXG4gIGV4cG9ydEt3aD86IG51bWJlcjtcclxuICBwdkt3aD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzZWRJbnRlcnZhbCBleHRlbmRzIEludGVydmFsUmVjb3JkIHtcclxuICBjb25zdW1wdGlvbkt3OiBudW1iZXI7XHJcbiAgZXhjZXNzS3c6IG51bWJlcjtcclxuICBleGNlc3NLd2g6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQZWFrRXZlbnQge1xuICBwZWFrVGltZXN0YW1wOiBzdHJpbmc7XG4gIGR1cmF0aW9uSW50ZXJ2YWxzOiBudW1iZXI7XG4gIG1heEV4Y2Vzc0t3OiBudW1iZXI7XG4gIHRvdGFsRXhjZXNzS3doOiBudW1iZXI7XG4gIGludGVydmFsSW5kZXhlczogbnVtYmVyW107XG59XG5cclxuZXhwb3J0IGludGVyZmFjZSBEYXRhUXVhbGl0eVJlcG9ydCB7XHJcbiAgcm93czogbnVtYmVyO1xyXG4gIHN0YXJ0RGF0ZTogc3RyaW5nIHwgbnVsbDtcclxuICBlbmREYXRlOiBzdHJpbmcgfCBudWxsO1xyXG4gIG1pc3NpbmdJbnRlcnZhbHNDb3VudDogbnVtYmVyO1xyXG4gIGR1cGxpY2F0ZUNvdW50OiBudW1iZXI7XHJcbiAgbm9uMTVNaW5JbnRlcnZhbHM6IG51bWJlcjtcclxuICB3YXJuaW5nczogc3RyaW5nW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2l6aW5nUmVzdWx0IHtcclxuICBrV2hOZWVkZWRSYXc6IG51bWJlcjtcclxuICBrV05lZWRlZFJhdzogbnVtYmVyO1xyXG4gIGtXaE5lZWRlZDogbnVtYmVyO1xyXG4gIGtXTmVlZGVkOiBudW1iZXI7XHJcbiAgcmVjb21tZW5kZWRQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdDtcclxuICBhbHRlcm5hdGl2ZVByb2R1Y3Q6IEJhdHRlcnlQcm9kdWN0IHwgbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXR0ZXJ5UHJvZHVjdCB7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGNhcGFjaXR5S3doOiBudW1iZXI7XG4gIG1vZHVsYXI/OiBib29sZWFuO1xuICB1bml0UHJpY2VFdXI/OiBudW1iZXI7XG4gIHVuaXRDYXBhY2l0eUt3aD86IG51bWJlcjtcbiAgY291bnQ/OiBudW1iZXI7XG4gIHRvdGFsUHJpY2VFdXI/OiBudW1iZXI7XG4gIGJyZWFrZG93bj86IEJhdHRlcnlCcmVha2Rvd25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXR0ZXJ5QnJlYWtkb3duIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb3VudDogbnVtYmVyO1xuICB1bml0Q2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgdW5pdFByaWNlRXVyOiBudW1iZXI7XG4gIHRvdGFsUHJpY2VFdXI6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeGNlZWRlZEludGVydmFsIHtcbiAgdGltZXN0YW1wOiBzdHJpbmc7XG4gIGNvbnN1bXB0aW9uX2tXOiBudW1iZXI7XG4gIGV4Y2Vzc19rVzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERheVByb2ZpbGVQb2ludCB7XG4gIHRpbWVzdGFtcExhYmVsOiBzdHJpbmc7XG4gIHRpbWVzdGFtcElzbzogc3RyaW5nO1xuICBvYnNlcnZlZEt3OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5S3dTZXJpZXNQb2ludCB7XG4gIHRpbWVMYWJlbDogc3RyaW5nO1xuICB0aW1lc3RhbXBJc286IHN0cmluZztcbiAgY29uc3VtcHRpb25LdzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgQkFUVEVSWV9PUFRJT05TOiBCYXR0ZXJ5UHJvZHVjdFtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgRVNTIENhYmluZXQgNjQga1doJyxcbiAgICBjYXBhY2l0eUt3aDogNjQsXG4gICAgbW9kdWxhcjogdHJ1ZSxcbiAgICB1bml0UHJpY2VFdXI6IDE1Njg5LjMzXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1dhdHRzTmV4dCBFU1MgQ2FiaW5ldCA5NiBrV2gnLFxuICAgIGNhcGFjaXR5S3doOiA5NixcbiAgICBtb2R1bGFyOiB0cnVlLFxuICAgIHVuaXRQcmljZUV1cjogMjIyMjUuOThcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnRVNTIEFsbC1pbi1vbmUgQ2FiaW5ldCAyNjEga1doJyxcbiAgICBjYXBhY2l0eUt3aDogMjYxLFxuICAgIG1vZHVsYXI6IHRydWUsXG4gICAgdW5pdFByaWNlRXVyOiA0Mzk5NS45NlxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgQWxsLWluLW9uZSBDb250YWluZXIgMi4wOSBNV2gnLFxuICAgIGNhcGFjaXR5S3doOiAyMDkwLFxuICAgIG1vZHVsYXI6IGZhbHNlLFxuICAgIHVuaXRQcmljZUV1cjogMzE4NjU4LjA2XG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1dhdHRzTmV4dCBBbGwgaW4tb25lIENvbnRhaW5lciA1LjAxNSBNV2gnLFxuICAgIGNhcGFjaXR5S3doOiA1MDE1LFxuICAgIG1vZHVsYXI6IGZhbHNlLFxuICAgIHVuaXRQcmljZUV1cjogNjc1MDUyLjQ5XG4gIH1cbl07XG5cbmludGVyZmFjZSBCYXR0ZXJ5Q29uZmlndXJhdGlvbkNhbmRpZGF0ZSB7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIHRvdGFsQ2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgdG90YWxQcmljZUV1cjogbnVtYmVyO1xuICBvdmVyQ2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgY291bnQ6IG51bWJlcjtcbiAgdW5pdENhcGFjaXR5S3doOiBudW1iZXI7XG4gIHVuaXRQcmljZUV1cjogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiByb3VuZEN1cnJlbmN5KHZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIHRvQmF0dGVyeVByb2R1Y3QoY2FuZGlkYXRlOiBCYXR0ZXJ5Q29uZmlndXJhdGlvbkNhbmRpZGF0ZSk6IEJhdHRlcnlQcm9kdWN0IHtcbiAgY29uc3QgdG90YWxQcmljZUV1ciA9IHJvdW5kQ3VycmVuY3koY2FuZGlkYXRlLnRvdGFsUHJpY2VFdXIpO1xuICByZXR1cm4ge1xuICAgIGxhYmVsOiBjYW5kaWRhdGUubGFiZWwsXG4gICAgY2FwYWNpdHlLd2g6IGNhbmRpZGF0ZS50b3RhbENhcGFjaXR5S3doLFxuICAgIHVuaXRDYXBhY2l0eUt3aDogY2FuZGlkYXRlLnVuaXRDYXBhY2l0eUt3aCxcbiAgICBjb3VudDogY2FuZGlkYXRlLmNvdW50LFxuICAgIHVuaXRQcmljZUV1cjogcm91bmRDdXJyZW5jeShjYW5kaWRhdGUudW5pdFByaWNlRXVyKSxcbiAgICB0b3RhbFByaWNlRXVyLFxuICAgIGJyZWFrZG93bjogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBgJHtjYW5kaWRhdGUudW5pdENhcGFjaXR5S3dofSBrV2hgLFxuICAgICAgICBjb3VudDogY2FuZGlkYXRlLmNvdW50LFxuICAgICAgICB1bml0Q2FwYWNpdHlLd2g6IGNhbmRpZGF0ZS51bml0Q2FwYWNpdHlLd2gsXG4gICAgICAgIHVuaXRQcmljZUV1cjogcm91bmRDdXJyZW5jeShjYW5kaWRhdGUudW5pdFByaWNlRXVyKSxcbiAgICAgICAgdG90YWxQcmljZUV1clxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdE1pbmltdW1Db3N0QmF0dGVyeU9wdGlvbnMocmVxdWlyZWRLd2g6IG51bWJlcik6IHtcbiAgcmVjb21tZW5kZWRQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdDtcbiAgYWx0ZXJuYXRpdmVQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdCB8IG51bGw7XG59IHtcbiAgY29uc3Qgbm9ybWFsaXplZFJlcXVpcmVkID0gTWF0aC5tYXgoMCwgcmVxdWlyZWRLd2gpO1xuICBjb25zdCBjYW5kaWRhdGVzOiBCYXR0ZXJ5Q29uZmlndXJhdGlvbkNhbmRpZGF0ZVtdID0gW107XG5cbiAgQkFUVEVSWV9PUFRJT05TLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgIGNvbnN0IHVuaXRQcmljZUV1ciA9IG9wdGlvbi51bml0UHJpY2VFdXIgPz8gMDtcbiAgICBpZiAob3B0aW9uLm1vZHVsYXIpIHtcbiAgICAgIGNvbnN0IG1heENvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKG5vcm1hbGl6ZWRSZXF1aXJlZCAvIG9wdGlvbi5jYXBhY2l0eUt3aCkpO1xuICAgICAgZm9yIChsZXQgY291bnQgPSAxOyBjb3VudCA8PSBtYXhDb3VudDsgY291bnQgKz0gMSkge1xuICAgICAgICBjb25zdCB0b3RhbENhcGFjaXR5S3doID0gY291bnQgKiBvcHRpb24uY2FwYWNpdHlLd2g7XG4gICAgICAgIGlmICh0b3RhbENhcGFjaXR5S3doIDwgbm9ybWFsaXplZFJlcXVpcmVkKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdG90YWxQcmljZUV1ciA9IGNvdW50ICogdW5pdFByaWNlRXVyO1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgIGxhYmVsOiBgJHtjb3VudH14ICR7b3B0aW9uLmNhcGFjaXR5S3dofSBrV2ggKG1vZHVsYWlyKWAsXG4gICAgICAgICAgdG90YWxDYXBhY2l0eUt3aCxcbiAgICAgICAgICB0b3RhbFByaWNlRXVyLFxuICAgICAgICAgIG92ZXJDYXBhY2l0eUt3aDogdG90YWxDYXBhY2l0eUt3aCAtIG5vcm1hbGl6ZWRSZXF1aXJlZCxcbiAgICAgICAgICBjb3VudCxcbiAgICAgICAgICB1bml0Q2FwYWNpdHlLd2g6IG9wdGlvbi5jYXBhY2l0eUt3aCxcbiAgICAgICAgICB1bml0UHJpY2VFdXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbi5jYXBhY2l0eUt3aCA+PSBub3JtYWxpemVkUmVxdWlyZWQpIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgIGxhYmVsOiBvcHRpb24ubGFiZWwsXG4gICAgICAgIHRvdGFsQ2FwYWNpdHlLd2g6IG9wdGlvbi5jYXBhY2l0eUt3aCxcbiAgICAgICAgdG90YWxQcmljZUV1cjogdW5pdFByaWNlRXVyLFxuICAgICAgICBvdmVyQ2FwYWNpdHlLd2g6IG9wdGlvbi5jYXBhY2l0eUt3aCAtIG5vcm1hbGl6ZWRSZXF1aXJlZCxcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICAgIHVuaXRDYXBhY2l0eUt3aDogb3B0aW9uLmNhcGFjaXR5S3doLFxuICAgICAgICB1bml0UHJpY2VFdXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3Qgc29ydGVkID0gY2FuZGlkYXRlcy5zb3J0KFxuICAgIChhLCBiKSA9PlxuICAgICAgYS50b3RhbFByaWNlRXVyIC0gYi50b3RhbFByaWNlRXVyIHx8XG4gICAgICBhLm92ZXJDYXBhY2l0eUt3aCAtIGIub3ZlckNhcGFjaXR5S3doIHx8XG4gICAgICBhLnRvdGFsQ2FwYWNpdHlLd2ggLSBiLnRvdGFsQ2FwYWNpdHlLd2hcbiAgKTtcblxuICBjb25zdCByZWNvbW1lbmRlZFByb2R1Y3QgPSB0b0JhdHRlcnlQcm9kdWN0KHNvcnRlZFswXSk7XG4gIGNvbnN0IGFsdGVybmF0aXZlUHJvZHVjdCA9IHNvcnRlZFsxXSA/IHRvQmF0dGVyeVByb2R1Y3Qoc29ydGVkWzFdKSA6IG51bGw7XG5cbiAgcmV0dXJuIHsgcmVjb21tZW5kZWRQcm9kdWN0LCBhbHRlcm5hdGl2ZVByb2R1Y3QgfTtcbn1cblxyXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0ludGVydmFscyhcbiAgcm93czogSW50ZXJ2YWxSZWNvcmRbXSxcbiAgY29udHJhY3RlZFBvd2VyS3c6IG51bWJlclxuKTogUHJvY2Vzc2VkSW50ZXJ2YWxbXSB7XG4gIHJldHVybiByb3dzLm1hcCgocm93KSA9PiB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VUaW1lc3RhbXAocm93LnRpbWVzdGFtcCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFRpbWVzdGFtcCA9IE51bWJlci5pc05hTih0aW1lc3RhbXAuZ2V0VGltZSgpKSA/IHJvdy50aW1lc3RhbXAgOiB0aW1lc3RhbXAudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBjb25zdW1wdGlvbkt3ID0gcm93LmNvbnN1bXB0aW9uS3doIC8gMC4yNTtcbiAgICBjb25zdCBleGNlc3NLdyA9IE1hdGgubWF4KDAsIGNvbnN1bXB0aW9uS3cgLSBjb250cmFjdGVkUG93ZXJLdyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJvdyxcbiAgICAgIHRpbWVzdGFtcDogbm9ybWFsaXplZFRpbWVzdGFtcCxcbiAgICAgIGNvbnN1bXB0aW9uS3csXG4gICAgICBleGNlc3NLdyxcbiAgICAgIGV4Y2Vzc0t3aDogZXhjZXNzS3cgKiAwLjI1XG4gICAgfTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwUGVha0V2ZW50cyhpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10pOiBQZWFrRXZlbnRbXSB7XG4gIGNvbnN0IGV2ZW50czogUGVha0V2ZW50W10gPSBbXTtcbiAgbGV0IGN1cnJlbnQ6IFBlYWtFdmVudCB8IG51bGwgPSBudWxsO1xuXG4gIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW50ZXJ2YWwuZXhjZXNzS3cgPiAwKSB7XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudCA9IHtcbiAgICAgICAgICBwZWFrVGltZXN0YW1wOiBpbnRlcnZhbC50aW1lc3RhbXAsXG4gICAgICAgICAgZHVyYXRpb25JbnRlcnZhbHM6IDAsXG4gICAgICAgICAgbWF4RXhjZXNzS3c6IDAsXG4gICAgICAgICAgdG90YWxFeGNlc3NLd2g6IDAsXG4gICAgICAgICAgaW50ZXJ2YWxJbmRleGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudC5kdXJhdGlvbkludGVydmFscyArPSAxO1xuICAgICAgaWYgKFxuICAgICAgICBpbnRlcnZhbC5leGNlc3NLdyA+IGN1cnJlbnQubWF4RXhjZXNzS3cgfHxcbiAgICAgICAgKGludGVydmFsLmV4Y2Vzc0t3ID09PSBjdXJyZW50Lm1heEV4Y2Vzc0t3ICYmIGludGVydmFsLnRpbWVzdGFtcCA8IGN1cnJlbnQucGVha1RpbWVzdGFtcClcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50Lm1heEV4Y2Vzc0t3ID0gaW50ZXJ2YWwuZXhjZXNzS3c7XG4gICAgICAgIGN1cnJlbnQucGVha1RpbWVzdGFtcCA9IGludGVydmFsLnRpbWVzdGFtcDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQudG90YWxFeGNlc3NLd2ggKz0gaW50ZXJ2YWwuZXhjZXNzS3doO1xuICAgICAgY3VycmVudC5pbnRlcnZhbEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICBldmVudHMucHVzaChjdXJyZW50KTtcclxuICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGlmIChjdXJyZW50KSB7XHJcbiAgICBldmVudHMucHVzaChjdXJyZW50KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBldmVudHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBlcmNlbnRpbGUodmFsdWVzOiBudW1iZXJbXSwgcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XHJcbiAgY29uc3Qgc29ydGVkID0gWy4uLnZhbHVlc10uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gIGNvbnN0IGlkeCA9IE1hdGguY2VpbCgocCAvIDEwMCkgKiBzb3J0ZWQubGVuZ3RoKSAtIDE7XHJcbiAgcmV0dXJuIHNvcnRlZFtNYXRoLm1heCgwLCBNYXRoLm1pbihpZHgsIHNvcnRlZC5sZW5ndGggLSAxKSldO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNpemluZyhwYXJhbXM6IHtcclxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW107XHJcbiAgZXZlbnRzOiBQZWFrRXZlbnRbXTtcclxuICBtZXRob2Q6IE1ldGhvZDtcclxuICBjb21wbGlhbmNlOiBudW1iZXI7XHJcbiAgc2FmZXR5RmFjdG9yOiBudW1iZXI7XHJcbiAgZWZmaWNpZW5jeTogbnVtYmVyO1xyXG59KTogU2l6aW5nUmVzdWx0IHtcclxuICBjb25zdCB7IGludGVydmFscywgZXZlbnRzLCBtZXRob2QsIGNvbXBsaWFuY2UsIHNhZmV0eUZhY3RvciwgZWZmaWNpZW5jeSB9ID0gcGFyYW1zO1xyXG5cclxuICBsZXQga1doTmVlZGVkUmF3ID0gMDtcclxuICBsZXQga1dOZWVkZWRSYXcgPSAwO1xyXG5cclxuICBpZiAobWV0aG9kID09PSAnTUFYX1BFQUsnKSB7XHJcbiAgICBjb25zdCBoaWdoZXN0RW5lcmd5RXZlbnQgPSBbLi4uZXZlbnRzXS5zb3J0KFxyXG4gICAgICAoYSwgYikgPT4gYi50b3RhbEV4Y2Vzc0t3aCAtIGEudG90YWxFeGNlc3NLd2hcclxuICAgIClbMF07XHJcbiAgICBpZiAoaGlnaGVzdEVuZXJneUV2ZW50KSB7XHJcbiAgICAgIGtXaE5lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC50b3RhbEV4Y2Vzc0t3aDtcclxuICAgICAga1dOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQubWF4RXhjZXNzS3c7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAobWV0aG9kID09PSAnUDk1Jykge1xyXG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPCAyMCkge1xyXG4gICAgICBjb25zdCBoaWdoZXN0RW5lcmd5RXZlbnQgPSBbLi4uZXZlbnRzXS5zb3J0KFxyXG4gICAgICAgIChhLCBiKSA9PiBiLnRvdGFsRXhjZXNzS3doIC0gYS50b3RhbEV4Y2Vzc0t3aFxyXG4gICAgICApWzBdO1xyXG4gICAgICBpZiAoaGlnaGVzdEVuZXJneUV2ZW50KSB7XHJcbiAgICAgICAga1doTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50LnRvdGFsRXhjZXNzS3doO1xyXG4gICAgICAgIGtXTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50Lm1heEV4Y2Vzc0t3O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBrV2hOZWVkZWRSYXcgPSBwZXJjZW50aWxlKFxyXG4gICAgICAgIGV2ZW50cy5tYXAoKGV2ZW50KSA9PiBldmVudC50b3RhbEV4Y2Vzc0t3aCksXHJcbiAgICAgICAgOTVcclxuICAgICAgKTtcclxuICAgICAga1dOZWVkZWRSYXcgPSBwZXJjZW50aWxlKFxyXG4gICAgICAgIGV2ZW50cy5tYXAoKGV2ZW50KSA9PiBldmVudC5tYXhFeGNlc3NLdyksXHJcbiAgICAgICAgOTVcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChtZXRob2QgPT09ICdGVUxMX0NPVkVSQUdFJykge1xyXG4gICAgY29uc3QgYnlEYXkgPSBuZXcgTWFwPHN0cmluZywgUHJvY2Vzc2VkSW50ZXJ2YWxbXT4oKTtcclxuICAgIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXkgPSBpbnRlcnZhbC50aW1lc3RhbXAuc2xpY2UoMCwgMTApO1xyXG4gICAgICBjb25zdCBsaXN0ID0gYnlEYXkuZ2V0KGRheSkgPz8gW107XHJcbiAgICAgIGxpc3QucHVzaChpbnRlcnZhbCk7XHJcbiAgICAgIGJ5RGF5LnNldChkYXksIGxpc3QpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IG1heERheUVuZXJneSA9IDA7XHJcbiAgICBsZXQgbWF4RGF5UGVhayA9IDA7XHJcblxyXG4gICAgYnlEYXkuZm9yRWFjaCgoZGF5SW50ZXJ2YWxzKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRheUVuZXJneSA9IGRheUludGVydmFscy5yZWR1Y2UoKHN1bSwgaW50ZXJ2YWwpID0+IHN1bSArIGludGVydmFsLmV4Y2Vzc0t3aCwgMCk7XHJcbiAgICAgIGlmIChkYXlFbmVyZ3kgPiBtYXhEYXlFbmVyZ3kpIHtcclxuICAgICAgICBtYXhEYXlFbmVyZ3kgPSBkYXlFbmVyZ3k7XHJcbiAgICAgICAgbWF4RGF5UGVhayA9IE1hdGgubWF4KC4uLmRheUludGVydmFscy5tYXAoKGludGVydmFsKSA9PiBpbnRlcnZhbC5leGNlc3NLdykpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBrV2hOZWVkZWRSYXcgPSBtYXhEYXlFbmVyZ3k7XHJcbiAgICBrV05lZWRlZFJhdyA9IG1heERheVBlYWs7XHJcbiAgfVxyXG5cclxuICBrV2hOZWVkZWRSYXcgKj0gY29tcGxpYW5jZTtcclxuICBrV05lZWRlZFJhdyAqPSBjb21wbGlhbmNlO1xyXG5cclxuICBjb25zdCBrV2hOZWVkZWQgPSAoa1doTmVlZGVkUmF3IC8gZWZmaWNpZW5jeSkgKiBzYWZldHlGYWN0b3I7XHJcbiAgY29uc3Qga1dOZWVkZWQgPSBrV05lZWRlZFJhdyAqIHNhZmV0eUZhY3RvcjtcclxuXHJcbiAgY29uc3QgeyByZWNvbW1lbmRlZFByb2R1Y3QsIGFsdGVybmF0aXZlUHJvZHVjdCB9ID0gc2VsZWN0TWluaW11bUNvc3RCYXR0ZXJ5T3B0aW9ucyhrV2hOZWVkZWQpO1xuXHJcbiAgcmV0dXJuIHtcclxuICAgIGtXaE5lZWRlZFJhdyxcclxuICAgIGtXTmVlZGVkUmF3LFxyXG4gICAga1doTmVlZGVkLFxyXG4gICAga1dOZWVkZWQsXHJcbiAgICByZWNvbW1lbmRlZFByb2R1Y3QsXHJcbiAgICBhbHRlcm5hdGl2ZVByb2R1Y3RcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXRhUXVhbGl0eVJlcG9ydChpbnRlcnZhbHM6IEludGVydmFsUmVjb3JkW10pOiBEYXRhUXVhbGl0eVJlcG9ydCB7XG4gIGlmIChpbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb3dzOiAwLFxyXG4gICAgICBzdGFydERhdGU6IG51bGwsXHJcbiAgICAgIGVuZERhdGU6IG51bGwsXHJcbiAgICAgIG1pc3NpbmdJbnRlcnZhbHNDb3VudDogMCxcclxuICAgICAgZHVwbGljYXRlQ291bnQ6IDAsXHJcbiAgICAgIG5vbjE1TWluSW50ZXJ2YWxzOiAwLFxyXG4gICAgICB3YXJuaW5nczogWydObyByb3dzIGZvdW5kIGluIGRhdGFzZXQuJ11cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdCB0aW1lc3RhbXBzID0gaW50ZXJ2YWxzXHJcbiAgICAubWFwKChyb3cpID0+IG5ldyBEYXRlKHJvdy50aW1lc3RhbXApKVxyXG4gICAgLmZpbHRlcigoZGF0ZSkgPT4gIU51bWJlci5pc05hTihkYXRlLmdldFRpbWUoKSkpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKSk7XHJcblxyXG4gIGNvbnN0IGR1cGxpY2F0ZUNvdW50ID0gdGltZXN0YW1wcy5sZW5ndGggLSBuZXcgU2V0KHRpbWVzdGFtcHMubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpKS5zaXplO1xuICBsZXQgbm9uMTVNaW5JbnRlcnZhbHMgPSAwO1xuICBsZXQgbWlzc2luZ0ludGVydmFsc0NvdW50ID0gMDtcbiAgY29uc3QgRVBTID0gMC4wMTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IHRpbWVzdGFtcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBkaWZmTWludXRlcyA9ICh0aW1lc3RhbXBzW2ldLmdldFRpbWUoKSAtIHRpbWVzdGFtcHNbaSAtIDFdLmdldFRpbWUoKSkgLyA2MDAwMDtcbiAgICBpZiAoTWF0aC5hYnMoZGlmZk1pbnV0ZXMgLSAxNSkgPiBFUFMpIHtcbiAgICAgIG5vbjE1TWluSW50ZXJ2YWxzICs9IDE7XG4gICAgICBpZiAoZGlmZk1pbnV0ZXMgPiAxNSArIEVQUykge1xuICAgICAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQgKz0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChkaWZmTWludXRlcyAvIDE1KSAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXHJcbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XHJcbiAgaWYgKGR1cGxpY2F0ZUNvdW50ID4gMCkgd2FybmluZ3MucHVzaChgRGV0ZWN0ZWQgJHtkdXBsaWNhdGVDb3VudH0gZHVwbGljYXRlIHRpbWVzdGFtcHMuYCk7XHJcbiAgaWYgKG5vbjE1TWluSW50ZXJ2YWxzID4gMCkge1xyXG4gICAgd2FybmluZ3MucHVzaChgRGV0ZWN0ZWQgJHtub24xNU1pbkludGVydmFsc30gbm9uLTE1LW1pbnV0ZSBpbnRlcnZhbCB0cmFuc2l0aW9ucy5gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByb3dzOiBpbnRlcnZhbHMubGVuZ3RoLFxyXG4gICAgc3RhcnREYXRlOiB0aW1lc3RhbXBzWzBdPy50b0lTT1N0cmluZygpID8/IG51bGwsXHJcbiAgICBlbmREYXRlOiB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0/LnRvSVNPU3RyaW5nKCkgPz8gbnVsbCxcclxuICAgIG1pc3NpbmdJbnRlcnZhbHNDb3VudCxcclxuICAgIGR1cGxpY2F0ZUNvdW50LFxyXG4gICAgbm9uMTVNaW5JbnRlcnZhbHMsXHJcbiAgICB3YXJuaW5nc1xyXG4gIH07XHJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRNYXhPYnNlcnZlZChpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10pOiB7XG4gIG1heE9ic2VydmVkS3c6IG51bWJlcjtcbiAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IHN0cmluZyB8IG51bGw7XG59IHtcbiAgaWYgKGludGVydmFscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF4T2JzZXJ2ZWRLdzogMCxcbiAgICAgIG1heE9ic2VydmVkVGltZXN0YW1wOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGxldCBtYXhPYnNlcnZlZEt3ID0gLTE7XG4gIGxldCBtYXhPYnNlcnZlZFRpbWVzdGFtcDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgaWYgKFxuICAgICAgaW50ZXJ2YWwuY29uc3VtcHRpb25LdyA+IG1heE9ic2VydmVkS3cgfHxcbiAgICAgIChpbnRlcnZhbC5jb25zdW1wdGlvbkt3ID09PSBtYXhPYnNlcnZlZEt3ICYmXG4gICAgICAgIG1heE9ic2VydmVkVGltZXN0YW1wICE9PSBudWxsICYmXG4gICAgICAgIGludGVydmFsLnRpbWVzdGFtcCA8IG1heE9ic2VydmVkVGltZXN0YW1wKVxuICAgICkge1xuICAgICAgbWF4T2JzZXJ2ZWRLdyA9IGludGVydmFsLmNvbnN1bXB0aW9uS3c7XG4gICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcCA9IGludGVydmFsLnRpbWVzdGFtcDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbWF4T2JzZXJ2ZWRLdyxcbiAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0VG9wRXhjZWVkZWRJbnRlcnZhbHMoXG4gIGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSxcbiAgZGF5OiBzdHJpbmcsXG4gIGxpbWl0ID0gMjBcbik6IEV4Y2VlZGVkSW50ZXJ2YWxbXSB7XG4gIHJldHVybiBpbnRlcnZhbHNcbiAgICAuZmlsdGVyKChpbnRlcnZhbCkgPT4gZ2V0TG9jYWxEYXlJc28oaW50ZXJ2YWwudGltZXN0YW1wKSA9PT0gZGF5ICYmIGludGVydmFsLmV4Y2Vzc0t3ID4gMClcbiAgICAuc29ydCgoYSwgYikgPT4gYi5leGNlc3NLdyAtIGEuZXhjZXNzS3cgfHwgYS50aW1lc3RhbXAubG9jYWxlQ29tcGFyZShiLnRpbWVzdGFtcCkpXG4gICAgLnNsaWNlKDAsIGxpbWl0KVxuICAgIC5tYXAoKGludGVydmFsKSA9PiAoe1xuICAgICAgdGltZXN0YW1wOiBpbnRlcnZhbC50aW1lc3RhbXAsXG4gICAgICBjb25zdW1wdGlvbl9rVzogaW50ZXJ2YWwuY29uc3VtcHRpb25LdyxcbiAgICAgIGV4Y2Vzc19rVzogaW50ZXJ2YWwuZXhjZXNzS3dcbiAgICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERheVByb2ZpbGUoXG4gIGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSxcbiAgZGF5SXNvOiBzdHJpbmcsXG4gIGludGVydmFsTWludXRlcyA9IDE1LFxuICB0aW1lWm9uZSA9ICdFdXJvcGUvQW1zdGVyZGFtJ1xuKTogRGF5UHJvZmlsZVBvaW50W10ge1xuICBjb25zdCBmdWxsRGF5U2VyaWVzID0gYnVpbGREYXlLd1NlcmllcyhcbiAgICBpbnRlcnZhbHMubWFwKChpbnRlcnZhbCkgPT4gKHtcbiAgICAgIHRpbWVzdGFtcDogaW50ZXJ2YWwudGltZXN0YW1wLFxuICAgICAgY29uc3VtcHRpb25LdzogaW50ZXJ2YWwuY29uc3VtcHRpb25Ld1xuICAgIH0pKSxcbiAgICBkYXlJc28sXG4gICAgaW50ZXJ2YWxNaW51dGVzLFxuICAgIHRpbWVab25lXG4gICk7XG5cbiAgcmV0dXJuIGZ1bGxEYXlTZXJpZXMubWFwKChzbG90KSA9PiAoe1xuICAgIHRpbWVzdGFtcExhYmVsOiBzbG90LnRpbWVMYWJlbCxcbiAgICB0aW1lc3RhbXBJc286IHNsb3QudGltZXN0YW1wSXNvLFxuICAgIG9ic2VydmVkS3c6IHNsb3QuY29uc3VtcHRpb25Ld1xuICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERheUt3U2VyaWVzKFxuICBpbnRlcnZhbHM6IHsgdGltZXN0YW1wOiBzdHJpbmc7IGNvbnN1bXB0aW9uS3c6IG51bWJlciB9W10sXG4gIGRheUlzbzogc3RyaW5nLFxuICBpbnRlcnZhbE1pbnV0ZXMgPSAxNSxcbiAgdGltZVpvbmUgPSAnRXVyb3BlL0Ftc3RlcmRhbSdcbik6IERheUt3U2VyaWVzUG9pbnRbXSB7XG4gIGlmICghZGF5SXNvIHx8IGludGVydmFsTWludXRlcyA8PSAwKSByZXR1cm4gW107XG5cbiAgY29uc3QgW3llYXIsIG1vbnRoLCBkYXldID0gZGF5SXNvLnNwbGl0KCctJykubWFwKE51bWJlcik7XG4gIGNvbnN0IGRheVN0YXJ0TG9jYWwgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMCwgMCwgMCwgMCk7XG4gIGlmIChOdW1iZXIuaXNOYU4oZGF5U3RhcnRMb2NhbC5nZXRUaW1lKCkpKSByZXR1cm4gW107XG5cbiAgY29uc3Qgc2xvdHNQZXJEYXkgPSBNYXRoLmZsb29yKCgyNCAqIDYwKSAvIGludGVydmFsTWludXRlcyk7XG4gIGNvbnN0IHByb2ZpbGUgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzbG90c1BlckRheSB9LCAoXywgaW5kZXgpOiBEYXlLd1Nlcmllc1BvaW50ID0+IHtcbiAgICBjb25zdCBtaW51dGVzID0gaW5kZXggKiBpbnRlcnZhbE1pbnV0ZXM7XG4gICAgY29uc3QgaG91ciA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBjb25zdCBtaW51dGUgPSBtaW51dGVzICUgNjA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVMYWJlbDogYCR7U3RyaW5nKGhvdXIpLnBhZFN0YXJ0KDIsICcwJyl9OiR7U3RyaW5nKG1pbnV0ZSkucGFkU3RhcnQoMiwgJzAnKX1gLFxuICAgICAgdGltZXN0YW1wSXNvOiBuZXcgRGF0ZShkYXlTdGFydExvY2FsLmdldFRpbWUoKSArIG1pbnV0ZXMgKiA2MF8wMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBjb25zdW1wdGlvbkt3OiAwXG4gICAgfTtcbiAgfSk7XG5cbiAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgaWYgKGdldExvY2FsRGF5SXNvKGludGVydmFsLnRpbWVzdGFtcCwgdGltZVpvbmUpICE9PSBkYXlJc28pIHJldHVybjtcblxuICAgIGNvbnN0IGR0ID0gcGFyc2VUaW1lc3RhbXAoaW50ZXJ2YWwudGltZXN0YW1wKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGR0LmdldFRpbWUoKSkpIHJldHVybjtcbiAgICBjb25zdCB7IGhvdXIsIG1pbnV0ZSB9ID0gZ2V0TG9jYWxIb3VyTWludXRlKGR0LCB0aW1lWm9uZSk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaG91cikgfHwgIU51bWJlci5pc0Zpbml0ZShtaW51dGUpKSByZXR1cm47XG5cbiAgICBjb25zdCBtaW51dGVPZkRheSA9IGhvdXIgKiA2MCArIG1pbnV0ZTtcbiAgICBjb25zdCBzbG90SW5kZXggPSBNYXRoLmZsb29yKG1pbnV0ZU9mRGF5IC8gaW50ZXJ2YWxNaW51dGVzKTtcbiAgICBpZiAoc2xvdEluZGV4IDwgMCB8fCBzbG90SW5kZXggPj0gc2xvdHNQZXJEYXkpIHJldHVybjtcblxuICAgIHByb2ZpbGVbc2xvdEluZGV4XS5jb25zdW1wdGlvbkt3ID0gTWF0aC5tYXgocHJvZmlsZVtzbG90SW5kZXhdLmNvbnN1bXB0aW9uS3csIGludGVydmFsLmNvbnN1bXB0aW9uS3cpO1xuICB9KTtcblxuICByZXR1cm4gcHJvZmlsZTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRMb2NhbERheUlzbyIsImdldExvY2FsSG91ck1pbnV0ZSIsInBhcnNlVGltZXN0YW1wIiwiQkFUVEVSWV9PUFRJT05TIiwibGFiZWwiLCJjYXBhY2l0eUt3aCIsIm1vZHVsYXIiLCJ1bml0UHJpY2VFdXIiLCJyb3VuZEN1cnJlbmN5IiwidmFsdWUiLCJNYXRoIiwicm91bmQiLCJ0b0JhdHRlcnlQcm9kdWN0IiwiY2FuZGlkYXRlIiwidG90YWxQcmljZUV1ciIsInRvdGFsQ2FwYWNpdHlLd2giLCJ1bml0Q2FwYWNpdHlLd2giLCJjb3VudCIsImJyZWFrZG93biIsInR5cGUiLCJzZWxlY3RNaW5pbXVtQ29zdEJhdHRlcnlPcHRpb25zIiwicmVxdWlyZWRLd2giLCJub3JtYWxpemVkUmVxdWlyZWQiLCJtYXgiLCJjYW5kaWRhdGVzIiwiZm9yRWFjaCIsIm9wdGlvbiIsIm1heENvdW50IiwiY2VpbCIsInB1c2giLCJvdmVyQ2FwYWNpdHlLd2giLCJzb3J0ZWQiLCJzb3J0IiwiYSIsImIiLCJyZWNvbW1lbmRlZFByb2R1Y3QiLCJhbHRlcm5hdGl2ZVByb2R1Y3QiLCJwcm9jZXNzSW50ZXJ2YWxzIiwicm93cyIsImNvbnRyYWN0ZWRQb3dlckt3IiwibWFwIiwicm93IiwidGltZXN0YW1wIiwibm9ybWFsaXplZFRpbWVzdGFtcCIsIk51bWJlciIsImlzTmFOIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwiY29uc3VtcHRpb25LdyIsImNvbnN1bXB0aW9uS3doIiwiZXhjZXNzS3ciLCJleGNlc3NLd2giLCJncm91cFBlYWtFdmVudHMiLCJpbnRlcnZhbHMiLCJldmVudHMiLCJjdXJyZW50IiwiaW50ZXJ2YWwiLCJpbmRleCIsInBlYWtUaW1lc3RhbXAiLCJkdXJhdGlvbkludGVydmFscyIsIm1heEV4Y2Vzc0t3IiwidG90YWxFeGNlc3NLd2giLCJpbnRlcnZhbEluZGV4ZXMiLCJwZXJjZW50aWxlIiwidmFsdWVzIiwicCIsImxlbmd0aCIsImlkeCIsIm1pbiIsImNvbXB1dGVTaXppbmciLCJwYXJhbXMiLCJtZXRob2QiLCJjb21wbGlhbmNlIiwic2FmZXR5RmFjdG9yIiwiZWZmaWNpZW5jeSIsImtXaE5lZWRlZFJhdyIsImtXTmVlZGVkUmF3IiwiaGlnaGVzdEVuZXJneUV2ZW50IiwiZXZlbnQiLCJieURheSIsIk1hcCIsImRheSIsInNsaWNlIiwibGlzdCIsImdldCIsInNldCIsIm1heERheUVuZXJneSIsIm1heERheVBlYWsiLCJkYXlJbnRlcnZhbHMiLCJkYXlFbmVyZ3kiLCJyZWR1Y2UiLCJzdW0iLCJrV2hOZWVkZWQiLCJrV05lZWRlZCIsImJ1aWxkRGF0YVF1YWxpdHlSZXBvcnQiLCJ0aW1lc3RhbXBzIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsIm1pc3NpbmdJbnRlcnZhbHNDb3VudCIsImR1cGxpY2F0ZUNvdW50Iiwibm9uMTVNaW5JbnRlcnZhbHMiLCJ3YXJuaW5ncyIsIkRhdGUiLCJmaWx0ZXIiLCJkYXRlIiwiU2V0IiwiZCIsInNpemUiLCJFUFMiLCJpIiwiZGlmZk1pbnV0ZXMiLCJhYnMiLCJmaW5kTWF4T2JzZXJ2ZWQiLCJtYXhPYnNlcnZlZEt3IiwibWF4T2JzZXJ2ZWRUaW1lc3RhbXAiLCJzZWxlY3RUb3BFeGNlZWRlZEludGVydmFscyIsImxpbWl0IiwibG9jYWxlQ29tcGFyZSIsImNvbnN1bXB0aW9uX2tXIiwiZXhjZXNzX2tXIiwiYnVpbGREYXlQcm9maWxlIiwiZGF5SXNvIiwiaW50ZXJ2YWxNaW51dGVzIiwidGltZVpvbmUiLCJmdWxsRGF5U2VyaWVzIiwiYnVpbGREYXlLd1NlcmllcyIsInNsb3QiLCJ0aW1lc3RhbXBMYWJlbCIsInRpbWVMYWJlbCIsInRpbWVzdGFtcElzbyIsIm9ic2VydmVkS3ciLCJ5ZWFyIiwibW9udGgiLCJzcGxpdCIsImRheVN0YXJ0TG9jYWwiLCJzbG90c1BlckRheSIsImZsb29yIiwicHJvZmlsZSIsIkFycmF5IiwiZnJvbSIsIl8iLCJtaW51dGVzIiwiaG91ciIsIm1pbnV0ZSIsIlN0cmluZyIsInBhZFN0YXJ0IiwiZHQiLCJpc0Zpbml0ZSIsIm1pbnV0ZU9mRGF5Iiwic2xvdEluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});