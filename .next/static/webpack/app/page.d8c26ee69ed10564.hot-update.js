"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/simulation.ts":
/*!***************************!*\
  !*** ./lib/simulation.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findHighestPeakDay: function() { return /* binding */ findHighestPeakDay; },\n/* harmony export */   generateNearbyModularOptions: function() { return /* binding */ generateNearbyModularOptions; },\n/* harmony export */   generateScenarioOptions: function() { return /* binding */ generateScenarioOptions; },\n/* harmony export */   simulateAllScenarios: function() { return /* binding */ simulateAllScenarios; },\n/* harmony export */   simulateSingleScenario: function() { return /* binding */ simulateSingleScenario; }\n/* harmony export */ });\n/* harmony import */ var _calculations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calculations */ \"(app-pages-browser)/./lib/calculations.ts\");\n/* harmony import */ var _datetime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datetime */ \"(app-pages-browser)/./lib/datetime.ts\");\n\n\nconst MODULAR_BASE_SIZES = [\n    64,\n    96,\n    261\n];\nconst FIXED_SCENARIO_OPTIONS = [\n    {\n        capacityKwh: 64,\n        label: \"64 kWh\"\n    },\n    {\n        capacityKwh: 96,\n        label: \"96 kWh\"\n    },\n    {\n        capacityKwh: 261,\n        label: \"261 kWh\"\n    },\n    {\n        capacityKwh: 2090,\n        label: \"2.09 MWh (2090 kWh)\"\n    },\n    {\n        capacityKwh: 5015,\n        label: \"5.015 MWh (5015 kWh)\"\n    }\n];\nfunction generateNearbyModularOptions(params) {\n    const { baseSize, targetKwh, maxOptionsPerBase = 4 } = params;\n    const nCenter = targetKwh / baseSize;\n    const n0 = Math.floor(nCenter);\n    const n1 = Math.ceil(nCenter);\n    const nCandidates = [\n        n0 - 2,\n        n0 - 1,\n        n0,\n        n1,\n        n1 + 1,\n        n1 + 2\n    ].filter((n)=>n >= 1);\n    const uniqueCounts = Array.from(new Set(nCandidates));\n    return uniqueCounts.map((count)=>{\n        const capacityKwh = count * baseSize;\n        return {\n            capacityKwh,\n            label: \"\".concat(count, \"x\").concat(baseSize, \" (\").concat(capacityKwh, \" kWh)\"),\n            modular: {\n                baseSize,\n                count\n            }\n        };\n    }).sort((a, b)=>Math.abs(a.capacityKwh - targetKwh) - Math.abs(b.capacityKwh - targetKwh) || a.capacityKwh - targetKwh - (b.capacityKwh - targetKwh) || a.capacityKwh - b.capacityKwh).slice(0, maxOptionsPerBase);\n}\nfunction generateScenarioOptions(params) {\n    const { targetKwh, maxOptionsPerBase = 3, maxTotalOptions = 10 } = params;\n    const modularOptions = MODULAR_BASE_SIZES.flatMap((baseSize)=>generateNearbyModularOptions({\n            baseSize,\n            targetKwh,\n            maxOptionsPerBase\n        }));\n    const combined = [\n        ...modularOptions,\n        ...FIXED_SCENARIO_OPTIONS\n    ];\n    const deduped = new Map();\n    combined.forEach((option)=>{\n        if (!deduped.has(option.capacityKwh)) {\n            deduped.set(option.capacityKwh, option);\n        }\n    });\n    const allOptions = Array.from(deduped.values());\n    if (allOptions.length <= maxTotalOptions) {\n        return allOptions.sort((a, b)=>a.capacityKwh - b.capacityKwh);\n    }\n    const relevanceSort = (a, b)=>Math.abs(a.capacityKwh - targetKwh) - Math.abs(b.capacityKwh - targetKwh) || a.capacityKwh - targetKwh - (b.capacityKwh - targetKwh) || a.capacityKwh - b.capacityKwh;\n    const selected = new Map();\n    const alwaysIncludeCapacities = [\n        2090,\n        5015\n    ];\n    alwaysIncludeCapacities.forEach((capacity)=>{\n        const option = allOptions.find((candidate)=>candidate.capacityKwh === capacity);\n        if (option) selected.set(option.capacityKwh, option);\n    });\n    MODULAR_BASE_SIZES.forEach((baseSize)=>{\n        const closestPerBase = allOptions.filter((option)=>option.capacityKwh % baseSize === 0).sort(relevanceSort)[0];\n        if (closestPerBase) selected.set(closestPerBase.capacityKwh, closestPerBase);\n    });\n    allOptions.sort(relevanceSort).forEach((option)=>{\n        if (selected.size >= maxTotalOptions) return;\n        selected.set(option.capacityKwh, option);\n    });\n    return Array.from(selected.values()).slice(0, maxTotalOptions).sort((a, b)=>a.capacityKwh - b.capacityKwh);\n}\nfunction simulateSingleScenario(intervals, batteryCapacityKwh, sizingKwNeeded, maxExcessKw, config, optionLabel) {\n    var _BATTERY_OPTIONS_find;\n    var _config_powerCapKw;\n    const powerCapKw = (_config_powerCapKw = config === null || config === void 0 ? void 0 : config.powerCapKw) !== null && _config_powerCapKw !== void 0 ? _config_powerCapKw : sizingKwNeeded > 0 ? sizingKwNeeded : Math.min(maxExcessKw, batteryCapacityKwh / 0.5);\n    var _config_initialSocRatio;\n    const initialSocRatio = (_config_initialSocRatio = config === null || config === void 0 ? void 0 : config.initialSocRatio) !== null && _config_initialSocRatio !== void 0 ? _config_initialSocRatio : 0.5;\n    const chargeEfficiency = 0.95;\n    const contractKw = Math.max(0, ...intervals.map((interval)=>interval.consumptionKw - interval.excessKw));\n    let soc = batteryCapacityKwh * initialSocRatio;\n    let exceedanceIntervalsBefore = 0;\n    let exceedanceIntervalsAfter = 0;\n    let exceedanceEnergyKwhBefore = 0;\n    let exceedanceEnergyKwhAfter = 0;\n    let maxRemainingExcessKw = 0;\n    const dailyTotals = new Map();\n    const shavedSeries = intervals.map((interval)=>{\n        const day = interval.timestamp.slice(0, 10);\n        var _dailyTotals_get;\n        const dayTotal = (_dailyTotals_get = dailyTotals.get(day)) !== null && _dailyTotals_get !== void 0 ? _dailyTotals_get : {\n            before: 0,\n            after: 0\n        };\n        dailyTotals.set(day, dayTotal);\n        const headroomKw = Math.max(0, contractKw - interval.consumptionKw);\n        const chargeKwh = Math.min(headroomKw, powerCapKw) * 0.25 * chargeEfficiency;\n        soc = Math.min(batteryCapacityKwh, soc + chargeKwh);\n        if (interval.excessKw > 0) {\n            exceedanceIntervalsBefore += 1;\n            exceedanceEnergyKwhBefore += interval.excessKwh;\n            dayTotal.before += interval.excessKwh;\n            const dischargeNeedKwh = Math.min(interval.excessKw, powerCapKw) * 0.25;\n            const deliveredKwh = Math.min(dischargeNeedKwh, soc);\n            soc -= deliveredKwh;\n            const shavedKw = deliveredKwh / 0.25;\n            const remainingExcessKw = interval.excessKw - deliveredKwh / 0.25;\n            if (remainingExcessKw > 0) {\n                exceedanceIntervalsAfter += 1;\n                exceedanceEnergyKwhAfter += remainingExcessKw * 0.25;\n                dayTotal.after += remainingExcessKw * 0.25;\n            }\n            maxRemainingExcessKw = Math.max(maxRemainingExcessKw, remainingExcessKw);\n            return {\n                timestamp: interval.timestamp,\n                originalKw: interval.consumptionKw,\n                shavedKw: interval.consumptionKw - shavedKw\n            };\n        }\n        return {\n            timestamp: interval.timestamp,\n            originalKw: interval.consumptionKw,\n            shavedKw: interval.consumptionKw\n        };\n    });\n    const achievedComplianceDataset = exceedanceEnergyKwhBefore === 0 ? 1 : 1 - exceedanceEnergyKwhAfter / exceedanceEnergyKwhBefore;\n    const dailyComplianceValues = Array.from(dailyTotals.values()).map((param)=>{\n        let { before, after } = param;\n        return before === 0 ? 1 : 1 - after / before;\n    });\n    const achievedComplianceDailyAverage = dailyComplianceValues.length === 0 ? 1 : dailyComplianceValues.reduce((sum, value)=>sum + value, 0) / dailyComplianceValues.length;\n    var _ref;\n    return {\n        optionLabel: (_ref = optionLabel !== null && optionLabel !== void 0 ? optionLabel : (_BATTERY_OPTIONS_find = _calculations__WEBPACK_IMPORTED_MODULE_0__.BATTERY_OPTIONS.find((b)=>b.capacityKwh === batteryCapacityKwh)) === null || _BATTERY_OPTIONS_find === void 0 ? void 0 : _BATTERY_OPTIONS_find.label) !== null && _ref !== void 0 ? _ref : \"\".concat(batteryCapacityKwh, \" kWh\"),\n        capacityKwh: batteryCapacityKwh,\n        exceedanceIntervalsBefore,\n        exceedanceIntervalsAfter,\n        exceedanceEnergyKwhBefore,\n        exceedanceEnergyKwhAfter,\n        achievedComplianceDataset,\n        achievedComplianceDailyAverage,\n        achievedCompliance: achievedComplianceDataset,\n        maxRemainingExcessKw,\n        shavedSeries\n    };\n}\nfunction simulateAllScenarios(intervals, sizingKwNeeded, targetKwhOrConfig, config) {\n    const targetKwh = typeof targetKwhOrConfig === \"number\" ? targetKwhOrConfig : sizingKwNeeded;\n    const effectiveConfig = typeof targetKwhOrConfig === \"number\" ? config : targetKwhOrConfig;\n    const options = generateScenarioOptions({\n        targetKwh\n    });\n    const maxExcessKw = Math.max(0, ...intervals.map((interval)=>interval.excessKw));\n    return options.map((option)=>simulateSingleScenario(intervals, option.capacityKwh, sizingKwNeeded, maxExcessKw, effectiveConfig, option.label));\n}\nfunction findHighestPeakDay(intervals) {\n    const totalsByDay = new Map();\n    intervals.forEach((interval)=>{\n        const day = (0,_datetime__WEBPACK_IMPORTED_MODULE_1__.getLocalDayIso)(interval.timestamp);\n        if (!day) return;\n        var _totalsByDay_get;\n        totalsByDay.set(day, ((_totalsByDay_get = totalsByDay.get(day)) !== null && _totalsByDay_get !== void 0 ? _totalsByDay_get : 0) + interval.excessKw);\n    });\n    let highestDay = null;\n    let maxTotal = -1;\n    totalsByDay.forEach((total, day)=>{\n        if (total > maxTotal) {\n            maxTotal = total;\n            highestDay = day;\n        }\n    });\n    return highestDay;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFBLG1CQUF3QixLQUFLckMsU0FBU0UsUUFBUTtJQUN0RTtJQUVBLElBQUlvQyxhQUE0QjtJQUNoQyxJQUFJQyxXQUFXLENBQUM7SUFDaEJGLFlBQVlqRSxPQUFPLENBQUMsQ0FBQ29FLE9BQU83QjtRQUMxQixJQUFJNkIsUUFBUUQsVUFBVTtZQUNwQkEsV0FBV0M7WUFDWEYsYUFBYTNCO1FBQ2Y7SUFDRjtJQUVBLE9BQU8yQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9zaW11bGF0aW9uLnRzPzM2MWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQkFUVEVSWV9PUFRJT05TLCB0eXBlIFByb2Nlc3NlZEludGVydmFsIH0gZnJvbSAnLi9jYWxjdWxhdGlvbnMnO1xuaW1wb3J0IHsgZ2V0TG9jYWxEYXlJc28gfSBmcm9tICcuL2RhdGV0aW1lJztcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNpbXVsYXRpb25Db25maWcge1xyXG4gIHBvd2VyQ2FwS3c/OiBudW1iZXI7XHJcbiAgaW5pdGlhbFNvY1JhdGlvPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNjZW5hcmlvUmVzdWx0IHtcbiAgb3B0aW9uTGFiZWw6IHN0cmluZztcclxuICBjYXBhY2l0eUt3aDogbnVtYmVyO1xyXG4gIGV4Y2VlZGFuY2VJbnRlcnZhbHNCZWZvcmU6IG51bWJlcjtcclxuICBleGNlZWRhbmNlSW50ZXJ2YWxzQWZ0ZXI6IG51bWJlcjtcclxuICBleGNlZWRhbmNlRW5lcmd5S3doQmVmb3JlOiBudW1iZXI7XG4gIGV4Y2VlZGFuY2VFbmVyZ3lLd2hBZnRlcjogbnVtYmVyO1xuICBhY2hpZXZlZENvbXBsaWFuY2VEYXRhc2V0OiBudW1iZXI7XG4gIGFjaGlldmVkQ29tcGxpYW5jZURhaWx5QXZlcmFnZTogbnVtYmVyO1xuICBhY2hpZXZlZENvbXBsaWFuY2U6IG51bWJlcjtcbiAgbWF4UmVtYWluaW5nRXhjZXNzS3c6IG51bWJlcjtcbiAgc2hhdmVkU2VyaWVzOiB7IHRpbWVzdGFtcDogc3RyaW5nOyBvcmlnaW5hbEt3OiBudW1iZXI7IHNoYXZlZEt3OiBudW1iZXIgfVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjZW5hcmlvT3B0aW9uIHtcbiAgY2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgbGFiZWw6IHN0cmluZztcbiAgbW9kdWxhcj86IHtcbiAgICBiYXNlU2l6ZTogbnVtYmVyO1xuICAgIGNvdW50OiBudW1iZXI7XG4gIH07XG59XG5cbmNvbnN0IE1PRFVMQVJfQkFTRV9TSVpFUyA9IFs2NCwgOTYsIDI2MV07XG5jb25zdCBGSVhFRF9TQ0VOQVJJT19PUFRJT05TOiBTY2VuYXJpb09wdGlvbltdID0gW1xuICB7IGNhcGFjaXR5S3doOiA2NCwgbGFiZWw6ICc2NCBrV2gnIH0sXG4gIHsgY2FwYWNpdHlLd2g6IDk2LCBsYWJlbDogJzk2IGtXaCcgfSxcbiAgeyBjYXBhY2l0eUt3aDogMjYxLCBsYWJlbDogJzI2MSBrV2gnIH0sXG4gIHsgY2FwYWNpdHlLd2g6IDIwOTAsIGxhYmVsOiAnMi4wOSBNV2ggKDIwOTAga1doKScgfSxcbiAgeyBjYXBhY2l0eUt3aDogNTAxNSwgbGFiZWw6ICc1LjAxNSBNV2ggKDUwMTUga1doKScgfVxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTmVhcmJ5TW9kdWxhck9wdGlvbnMocGFyYW1zOiB7XG4gIGJhc2VTaXplOiBudW1iZXI7XG4gIHRhcmdldEt3aDogbnVtYmVyO1xuICBtYXhPcHRpb25zUGVyQmFzZT86IG51bWJlcjtcbn0pOiBTY2VuYXJpb09wdGlvbltdIHtcbiAgY29uc3QgeyBiYXNlU2l6ZSwgdGFyZ2V0S3doLCBtYXhPcHRpb25zUGVyQmFzZSA9IDQgfSA9IHBhcmFtcztcbiAgY29uc3QgbkNlbnRlciA9IHRhcmdldEt3aCAvIGJhc2VTaXplO1xuICBjb25zdCBuMCA9IE1hdGguZmxvb3IobkNlbnRlcik7XG4gIGNvbnN0IG4xID0gTWF0aC5jZWlsKG5DZW50ZXIpO1xuICBjb25zdCBuQ2FuZGlkYXRlcyA9IFtuMCAtIDIsIG4wIC0gMSwgbjAsIG4xLCBuMSArIDEsIG4xICsgMl0uZmlsdGVyKChuKSA9PiBuID49IDEpO1xuICBjb25zdCB1bmlxdWVDb3VudHMgPSBBcnJheS5mcm9tKG5ldyBTZXQobkNhbmRpZGF0ZXMpKTtcblxuICByZXR1cm4gdW5pcXVlQ291bnRzXG4gICAgLm1hcCgoY291bnQpID0+IHtcbiAgICAgIGNvbnN0IGNhcGFjaXR5S3doID0gY291bnQgKiBiYXNlU2l6ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhcGFjaXR5S3doLFxuICAgICAgICBsYWJlbDogYCR7Y291bnR9eCR7YmFzZVNpemV9ICgke2NhcGFjaXR5S3dofSBrV2gpYCxcbiAgICAgICAgbW9kdWxhcjogeyBiYXNlU2l6ZSwgY291bnQgfVxuICAgICAgfTtcbiAgICB9KVxuICAgIC5zb3J0KFxuICAgICAgKGEsIGIpID0+XG4gICAgICAgIE1hdGguYWJzKGEuY2FwYWNpdHlLd2ggLSB0YXJnZXRLd2gpIC0gTWF0aC5hYnMoYi5jYXBhY2l0eUt3aCAtIHRhcmdldEt3aCkgfHxcbiAgICAgICAgKGEuY2FwYWNpdHlLd2ggLSB0YXJnZXRLd2gpIC0gKGIuY2FwYWNpdHlLd2ggLSB0YXJnZXRLd2gpIHx8XG4gICAgICAgIGEuY2FwYWNpdHlLd2ggLSBiLmNhcGFjaXR5S3doXG4gICAgKVxuICAgIC5zbGljZSgwLCBtYXhPcHRpb25zUGVyQmFzZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVNjZW5hcmlvT3B0aW9ucyhwYXJhbXM6IHtcbiAgdGFyZ2V0S3doOiBudW1iZXI7XG4gIG1heE9wdGlvbnNQZXJCYXNlPzogbnVtYmVyO1xuICBtYXhUb3RhbE9wdGlvbnM/OiBudW1iZXI7XG59KTogU2NlbmFyaW9PcHRpb25bXSB7XG4gIGNvbnN0IHsgdGFyZ2V0S3doLCBtYXhPcHRpb25zUGVyQmFzZSA9IDMsIG1heFRvdGFsT3B0aW9ucyA9IDEwIH0gPSBwYXJhbXM7XG5cbiAgY29uc3QgbW9kdWxhck9wdGlvbnMgPSBNT0RVTEFSX0JBU0VfU0laRVMuZmxhdE1hcCgoYmFzZVNpemUpID0+XG4gICAgZ2VuZXJhdGVOZWFyYnlNb2R1bGFyT3B0aW9ucyh7IGJhc2VTaXplLCB0YXJnZXRLd2gsIG1heE9wdGlvbnNQZXJCYXNlIH0pXG4gICk7XG4gIGNvbnN0IGNvbWJpbmVkID0gWy4uLm1vZHVsYXJPcHRpb25zLCAuLi5GSVhFRF9TQ0VOQVJJT19PUFRJT05TXTtcbiAgY29uc3QgZGVkdXBlZCA9IG5ldyBNYXA8bnVtYmVyLCBTY2VuYXJpb09wdGlvbj4oKTtcbiAgY29tYmluZWQuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgaWYgKCFkZWR1cGVkLmhhcyhvcHRpb24uY2FwYWNpdHlLd2gpKSB7XG4gICAgICBkZWR1cGVkLnNldChvcHRpb24uY2FwYWNpdHlLd2gsIG9wdGlvbik7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBhbGxPcHRpb25zID0gQXJyYXkuZnJvbShkZWR1cGVkLnZhbHVlcygpKTtcbiAgaWYgKGFsbE9wdGlvbnMubGVuZ3RoIDw9IG1heFRvdGFsT3B0aW9ucykge1xuICAgIHJldHVybiBhbGxPcHRpb25zLnNvcnQoKGEsIGIpID0+IGEuY2FwYWNpdHlLd2ggLSBiLmNhcGFjaXR5S3doKTtcbiAgfVxuXG4gIGNvbnN0IHJlbGV2YW5jZVNvcnQgPSAoYTogU2NlbmFyaW9PcHRpb24sIGI6IFNjZW5hcmlvT3B0aW9uKSA9PlxuICAgIE1hdGguYWJzKGEuY2FwYWNpdHlLd2ggLSB0YXJnZXRLd2gpIC0gTWF0aC5hYnMoYi5jYXBhY2l0eUt3aCAtIHRhcmdldEt3aCkgfHxcbiAgICAoYS5jYXBhY2l0eUt3aCAtIHRhcmdldEt3aCkgLSAoYi5jYXBhY2l0eUt3aCAtIHRhcmdldEt3aCkgfHxcbiAgICBhLmNhcGFjaXR5S3doIC0gYi5jYXBhY2l0eUt3aDtcblxuICBjb25zdCBzZWxlY3RlZCA9IG5ldyBNYXA8bnVtYmVyLCBTY2VuYXJpb09wdGlvbj4oKTtcbiAgY29uc3QgYWx3YXlzSW5jbHVkZUNhcGFjaXRpZXMgPSBbMjA5MCwgNTAxNV07XG4gIGFsd2F5c0luY2x1ZGVDYXBhY2l0aWVzLmZvckVhY2goKGNhcGFjaXR5KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uID0gYWxsT3B0aW9ucy5maW5kKChjYW5kaWRhdGUpID0+IGNhbmRpZGF0ZS5jYXBhY2l0eUt3aCA9PT0gY2FwYWNpdHkpO1xuICAgIGlmIChvcHRpb24pIHNlbGVjdGVkLnNldChvcHRpb24uY2FwYWNpdHlLd2gsIG9wdGlvbik7XG4gIH0pO1xuXG4gIE1PRFVMQVJfQkFTRV9TSVpFUy5mb3JFYWNoKChiYXNlU2l6ZSkgPT4ge1xuICAgIGNvbnN0IGNsb3Nlc3RQZXJCYXNlID0gYWxsT3B0aW9uc1xuICAgICAgLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24uY2FwYWNpdHlLd2ggJSBiYXNlU2l6ZSA9PT0gMClcbiAgICAgIC5zb3J0KHJlbGV2YW5jZVNvcnQpWzBdO1xuICAgIGlmIChjbG9zZXN0UGVyQmFzZSkgc2VsZWN0ZWQuc2V0KGNsb3Nlc3RQZXJCYXNlLmNhcGFjaXR5S3doLCBjbG9zZXN0UGVyQmFzZSk7XG4gIH0pO1xuXG4gIGFsbE9wdGlvbnNcbiAgICAuc29ydChyZWxldmFuY2VTb3J0KVxuICAgIC5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgIGlmIChzZWxlY3RlZC5zaXplID49IG1heFRvdGFsT3B0aW9ucykgcmV0dXJuO1xuICAgICAgc2VsZWN0ZWQuc2V0KG9wdGlvbi5jYXBhY2l0eUt3aCwgb3B0aW9uKTtcbiAgICB9KTtcblxuICByZXR1cm4gQXJyYXkuZnJvbShzZWxlY3RlZC52YWx1ZXMoKSlcbiAgICAuc2xpY2UoMCwgbWF4VG90YWxPcHRpb25zKVxuICAgIC5zb3J0KChhLCBiKSA9PiBhLmNhcGFjaXR5S3doIC0gYi5jYXBhY2l0eUt3aCk7XG59XG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNpbXVsYXRlU2luZ2xlU2NlbmFyaW8oXG4gIGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSxcbiAgYmF0dGVyeUNhcGFjaXR5S3doOiBudW1iZXIsXG4gIHNpemluZ0t3TmVlZGVkOiBudW1iZXIsXG4gIG1heEV4Y2Vzc0t3OiBudW1iZXIsXG4gIGNvbmZpZz86IFNpbXVsYXRpb25Db25maWcsXG4gIG9wdGlvbkxhYmVsPzogc3RyaW5nXG4pOiBTY2VuYXJpb1Jlc3VsdCB7XG4gIGNvbnN0IHBvd2VyQ2FwS3cgPVxuICAgIGNvbmZpZz8ucG93ZXJDYXBLdyA/P1xyXG4gICAgKHNpemluZ0t3TmVlZGVkID4gMFxyXG4gICAgICA/IHNpemluZ0t3TmVlZGVkXHJcbiAgICAgIDogTWF0aC5taW4obWF4RXhjZXNzS3csIGJhdHRlcnlDYXBhY2l0eUt3aCAvIDAuNSkpO1xyXG4gIGNvbnN0IGluaXRpYWxTb2NSYXRpbyA9IGNvbmZpZz8uaW5pdGlhbFNvY1JhdGlvID8/IDAuNTtcbiAgY29uc3QgY2hhcmdlRWZmaWNpZW5jeSA9IDAuOTU7XG4gIGNvbnN0IGNvbnRyYWN0S3cgPSBNYXRoLm1heCgwLCAuLi5pbnRlcnZhbHMubWFwKChpbnRlcnZhbCkgPT4gaW50ZXJ2YWwuY29uc3VtcHRpb25LdyAtIGludGVydmFsLmV4Y2Vzc0t3KSk7XG5cbiAgbGV0IHNvYyA9IGJhdHRlcnlDYXBhY2l0eUt3aCAqIGluaXRpYWxTb2NSYXRpbztcbiAgbGV0IGV4Y2VlZGFuY2VJbnRlcnZhbHNCZWZvcmUgPSAwO1xyXG4gIGxldCBleGNlZWRhbmNlSW50ZXJ2YWxzQWZ0ZXIgPSAwO1xyXG4gIGxldCBleGNlZWRhbmNlRW5lcmd5S3doQmVmb3JlID0gMDtcclxuICBsZXQgZXhjZWVkYW5jZUVuZXJneUt3aEFmdGVyID0gMDtcbiAgbGV0IG1heFJlbWFpbmluZ0V4Y2Vzc0t3ID0gMDtcbiAgY29uc3QgZGFpbHlUb3RhbHMgPSBuZXcgTWFwPHN0cmluZywgeyBiZWZvcmU6IG51bWJlcjsgYWZ0ZXI6IG51bWJlciB9PigpO1xuXG4gIGNvbnN0IHNoYXZlZFNlcmllcyA9IGludGVydmFscy5tYXAoKGludGVydmFsKSA9PiB7XG4gICAgY29uc3QgZGF5ID0gaW50ZXJ2YWwudGltZXN0YW1wLnNsaWNlKDAsIDEwKTtcbiAgICBjb25zdCBkYXlUb3RhbCA9IGRhaWx5VG90YWxzLmdldChkYXkpID8/IHsgYmVmb3JlOiAwLCBhZnRlcjogMCB9O1xuICAgIGRhaWx5VG90YWxzLnNldChkYXksIGRheVRvdGFsKTtcblxuICAgIGNvbnN0IGhlYWRyb29tS3cgPSBNYXRoLm1heCgwLCBjb250cmFjdEt3IC0gaW50ZXJ2YWwuY29uc3VtcHRpb25Ldyk7XG4gICAgY29uc3QgY2hhcmdlS3doID0gTWF0aC5taW4oaGVhZHJvb21LdywgcG93ZXJDYXBLdykgKiAwLjI1ICogY2hhcmdlRWZmaWNpZW5jeTtcbiAgICBzb2MgPSBNYXRoLm1pbihiYXR0ZXJ5Q2FwYWNpdHlLd2gsIHNvYyArIGNoYXJnZUt3aCk7XG5cbiAgICBpZiAoaW50ZXJ2YWwuZXhjZXNzS3cgPiAwKSB7XG4gICAgICBleGNlZWRhbmNlSW50ZXJ2YWxzQmVmb3JlICs9IDE7XG4gICAgICBleGNlZWRhbmNlRW5lcmd5S3doQmVmb3JlICs9IGludGVydmFsLmV4Y2Vzc0t3aDtcbiAgICAgIGRheVRvdGFsLmJlZm9yZSArPSBpbnRlcnZhbC5leGNlc3NLd2g7XG5cbiAgICAgIGNvbnN0IGRpc2NoYXJnZU5lZWRLd2ggPSBNYXRoLm1pbihpbnRlcnZhbC5leGNlc3NLdywgcG93ZXJDYXBLdykgKiAwLjI1O1xuICAgICAgY29uc3QgZGVsaXZlcmVkS3doID0gTWF0aC5taW4oZGlzY2hhcmdlTmVlZEt3aCwgc29jKTtcbiAgICAgIHNvYyAtPSBkZWxpdmVyZWRLd2g7XG4gICAgICBjb25zdCBzaGF2ZWRLdyA9IGRlbGl2ZXJlZEt3aCAvIDAuMjU7XG5cbiAgICAgIGNvbnN0IHJlbWFpbmluZ0V4Y2Vzc0t3ID0gaW50ZXJ2YWwuZXhjZXNzS3cgLSBkZWxpdmVyZWRLd2ggLyAwLjI1O1xuICAgICAgaWYgKHJlbWFpbmluZ0V4Y2Vzc0t3ID4gMCkge1xuICAgICAgICBleGNlZWRhbmNlSW50ZXJ2YWxzQWZ0ZXIgKz0gMTtcbiAgICAgICAgZXhjZWVkYW5jZUVuZXJneUt3aEFmdGVyICs9IHJlbWFpbmluZ0V4Y2Vzc0t3ICogMC4yNTtcbiAgICAgICAgZGF5VG90YWwuYWZ0ZXIgKz0gcmVtYWluaW5nRXhjZXNzS3cgKiAwLjI1O1xuICAgICAgfVxuICAgICAgbWF4UmVtYWluaW5nRXhjZXNzS3cgPSBNYXRoLm1heChtYXhSZW1haW5pbmdFeGNlc3NLdywgcmVtYWluaW5nRXhjZXNzS3cpO1xuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGltZXN0YW1wOiBpbnRlcnZhbC50aW1lc3RhbXAsXHJcbiAgICAgICAgb3JpZ2luYWxLdzogaW50ZXJ2YWwuY29uc3VtcHRpb25LdyxcclxuICAgICAgICBzaGF2ZWRLdzogaW50ZXJ2YWwuY29uc3VtcHRpb25LdyAtIHNoYXZlZEt3XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGltZXN0YW1wOiBpbnRlcnZhbC50aW1lc3RhbXAsXHJcbiAgICAgIG9yaWdpbmFsS3c6IGludGVydmFsLmNvbnN1bXB0aW9uS3csXHJcbiAgICAgIHNoYXZlZEt3OiBpbnRlcnZhbC5jb25zdW1wdGlvbkt3XHJcbiAgICB9O1xyXG4gIH0pO1xuXG4gIGNvbnN0IGFjaGlldmVkQ29tcGxpYW5jZURhdGFzZXQgPVxuICAgIGV4Y2VlZGFuY2VFbmVyZ3lLd2hCZWZvcmUgPT09IDBcbiAgICAgID8gMVxuICAgICAgOiAxIC0gZXhjZWVkYW5jZUVuZXJneUt3aEFmdGVyIC8gZXhjZWVkYW5jZUVuZXJneUt3aEJlZm9yZTtcbiAgY29uc3QgZGFpbHlDb21wbGlhbmNlVmFsdWVzID0gQXJyYXkuZnJvbShkYWlseVRvdGFscy52YWx1ZXMoKSkubWFwKCh7IGJlZm9yZSwgYWZ0ZXIgfSkgPT5cbiAgICBiZWZvcmUgPT09IDAgPyAxIDogMSAtIGFmdGVyIC8gYmVmb3JlXG4gICk7XG4gIGNvbnN0IGFjaGlldmVkQ29tcGxpYW5jZURhaWx5QXZlcmFnZSA9XG4gICAgZGFpbHlDb21wbGlhbmNlVmFsdWVzLmxlbmd0aCA9PT0gMFxuICAgICAgPyAxXG4gICAgICA6IGRhaWx5Q29tcGxpYW5jZVZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlLCAwKSAvIGRhaWx5Q29tcGxpYW5jZVZhbHVlcy5sZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBvcHRpb25MYWJlbDpcbiAgICAgIG9wdGlvbkxhYmVsID8/IEJBVFRFUllfT1BUSU9OUy5maW5kKChiKSA9PiBiLmNhcGFjaXR5S3doID09PSBiYXR0ZXJ5Q2FwYWNpdHlLd2gpPy5sYWJlbCA/PyBgJHtiYXR0ZXJ5Q2FwYWNpdHlLd2h9IGtXaGAsXG4gICAgY2FwYWNpdHlLd2g6IGJhdHRlcnlDYXBhY2l0eUt3aCxcbiAgICBleGNlZWRhbmNlSW50ZXJ2YWxzQmVmb3JlLFxyXG4gICAgZXhjZWVkYW5jZUludGVydmFsc0FmdGVyLFxuICAgIGV4Y2VlZGFuY2VFbmVyZ3lLd2hCZWZvcmUsXG4gICAgZXhjZWVkYW5jZUVuZXJneUt3aEFmdGVyLFxuICAgIGFjaGlldmVkQ29tcGxpYW5jZURhdGFzZXQsXG4gICAgYWNoaWV2ZWRDb21wbGlhbmNlRGFpbHlBdmVyYWdlLFxuICAgIGFjaGlldmVkQ29tcGxpYW5jZTogYWNoaWV2ZWRDb21wbGlhbmNlRGF0YXNldCxcbiAgICBtYXhSZW1haW5pbmdFeGNlc3NLdyxcbiAgICBzaGF2ZWRTZXJpZXNcbiAgfTtcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW11bGF0ZUFsbFNjZW5hcmlvcyhcbiAgaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdLFxuICBzaXppbmdLd05lZWRlZDogbnVtYmVyLFxuICB0YXJnZXRLd2hPckNvbmZpZz86IG51bWJlciB8IFNpbXVsYXRpb25Db25maWcsXG4gIGNvbmZpZz86IFNpbXVsYXRpb25Db25maWdcbik6IFNjZW5hcmlvUmVzdWx0W10ge1xuICBjb25zdCB0YXJnZXRLd2ggPSB0eXBlb2YgdGFyZ2V0S3doT3JDb25maWcgPT09ICdudW1iZXInID8gdGFyZ2V0S3doT3JDb25maWcgOiBzaXppbmdLd05lZWRlZDtcbiAgY29uc3QgZWZmZWN0aXZlQ29uZmlnID0gdHlwZW9mIHRhcmdldEt3aE9yQ29uZmlnID09PSAnbnVtYmVyJyA/IGNvbmZpZyA6IHRhcmdldEt3aE9yQ29uZmlnO1xuICBjb25zdCBvcHRpb25zID0gZ2VuZXJhdGVTY2VuYXJpb09wdGlvbnMoeyB0YXJnZXRLd2ggfSk7XG4gIGNvbnN0IG1heEV4Y2Vzc0t3ID0gTWF0aC5tYXgoMCwgLi4uaW50ZXJ2YWxzLm1hcCgoaW50ZXJ2YWwpID0+IGludGVydmFsLmV4Y2Vzc0t3KSk7XG4gIHJldHVybiBvcHRpb25zLm1hcCgob3B0aW9uKSA9PlxuICAgIHNpbXVsYXRlU2luZ2xlU2NlbmFyaW8oaW50ZXJ2YWxzLCBvcHRpb24uY2FwYWNpdHlLd2gsIHNpemluZ0t3TmVlZGVkLCBtYXhFeGNlc3NLdywgZWZmZWN0aXZlQ29uZmlnLCBvcHRpb24ubGFiZWwpXG4gICk7XG59XG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRIaWdoZXN0UGVha0RheShpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgdG90YWxzQnlEYXkgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcbiAgICBjb25zdCBkYXkgPSBnZXRMb2NhbERheUlzbyhpbnRlcnZhbC50aW1lc3RhbXApO1xuICAgIGlmICghZGF5KSByZXR1cm47XG4gICAgdG90YWxzQnlEYXkuc2V0KGRheSwgKHRvdGFsc0J5RGF5LmdldChkYXkpID8/IDApICsgaW50ZXJ2YWwuZXhjZXNzS3cpO1xuICB9KTtcblxyXG4gIGxldCBoaWdoZXN0RGF5OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICBsZXQgbWF4VG90YWwgPSAtMTtcclxuICB0b3RhbHNCeURheS5mb3JFYWNoKCh0b3RhbCwgZGF5KSA9PiB7XHJcbiAgICBpZiAodG90YWwgPiBtYXhUb3RhbCkge1xyXG4gICAgICBtYXhUb3RhbCA9IHRvdGFsO1xyXG4gICAgICBoaWdoZXN0RGF5ID0gZGF5O1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gaGlnaGVzdERheTtcclxufVxyXG4iXSwibmFtZXMiOlsiQkFUVEVSWV9PUFRJT05TIiwiZ2V0TG9jYWxEYXlJc28iLCJNT0RVTEFSX0JBU0VfU0laRVMiLCJGSVhFRF9TQ0VOQVJJT19PUFRJT05TIiwiY2FwYWNpdHlLd2giLCJsYWJlbCIsImdlbmVyYXRlTmVhcmJ5TW9kdWxhck9wdGlvbnMiLCJwYXJhbXMiLCJiYXNlU2l6ZSIsInRhcmdldEt3aCIsIm1heE9wdGlvbnNQZXJCYXNlIiwibkNlbnRlciIsIm4wIiwiTWF0aCIsImZsb29yIiwibjEiLCJjZWlsIiwibkNhbmRpZGF0ZXMiLCJmaWx0ZXIiLCJuIiwidW5pcXVlQ291bnRzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwibWFwIiwiY291bnQiLCJtb2R1bGFyIiwic29ydCIsImEiLCJiIiwiYWJzIiwic2xpY2UiLCJnZW5lcmF0ZVNjZW5hcmlvT3B0aW9ucyIsIm1heFRvdGFsT3B0aW9ucyIsIm1vZHVsYXJPcHRpb25zIiwiZmxhdE1hcCIsImNvbWJpbmVkIiwiZGVkdXBlZCIsIk1hcCIsImZvckVhY2giLCJvcHRpb24iLCJoYXMiLCJzZXQiLCJhbGxPcHRpb25zIiwidmFsdWVzIiwibGVuZ3RoIiwicmVsZXZhbmNlU29ydCIsInNlbGVjdGVkIiwiYWx3YXlzSW5jbHVkZUNhcGFjaXRpZXMiLCJjYXBhY2l0eSIsImZpbmQiLCJjYW5kaWRhdGUiLCJjbG9zZXN0UGVyQmFzZSIsInNpemUiLCJzaW11bGF0ZVNpbmdsZVNjZW5hcmlvIiwiaW50ZXJ2YWxzIiwiYmF0dGVyeUNhcGFjaXR5S3doIiwic2l6aW5nS3dOZWVkZWQiLCJtYXhFeGNlc3NLdyIsImNvbmZpZyIsIm9wdGlvbkxhYmVsIiwicG93ZXJDYXBLdyIsIm1pbiIsImluaXRpYWxTb2NSYXRpbyIsImNoYXJnZUVmZmljaWVuY3kiLCJjb250cmFjdEt3IiwibWF4IiwiaW50ZXJ2YWwiLCJjb25zdW1wdGlvbkt3IiwiZXhjZXNzS3ciLCJzb2MiLCJleGNlZWRhbmNlSW50ZXJ2YWxzQmVmb3JlIiwiZXhjZWVkYW5jZUludGVydmFsc0FmdGVyIiwiZXhjZWVkYW5jZUVuZXJneUt3aEJlZm9yZSIsImV4Y2VlZGFuY2VFbmVyZ3lLd2hBZnRlciIsIm1heFJlbWFpbmluZ0V4Y2Vzc0t3IiwiZGFpbHlUb3RhbHMiLCJzaGF2ZWRTZXJpZXMiLCJkYXkiLCJ0aW1lc3RhbXAiLCJkYXlUb3RhbCIsImdldCIsImJlZm9yZSIsImFmdGVyIiwiaGVhZHJvb21LdyIsImNoYXJnZUt3aCIsImV4Y2Vzc0t3aCIsImRpc2NoYXJnZU5lZWRLd2giLCJkZWxpdmVyZWRLd2giLCJzaGF2ZWRLdyIsInJlbWFpbmluZ0V4Y2Vzc0t3Iiwib3JpZ2luYWxLdyIsImFjaGlldmVkQ29tcGxpYW5jZURhdGFzZXQiLCJkYWlseUNvbXBsaWFuY2VWYWx1ZXMiLCJhY2hpZXZlZENvbXBsaWFuY2VEYWlseUF2ZXJhZ2UiLCJyZWR1Y2UiLCJzdW0iLCJ2YWx1ZSIsImFjaGlldmVkQ29tcGxpYW5jZSIsInNpbXVsYXRlQWxsU2NlbmFyaW9zIiwidGFyZ2V0S3doT3JDb25maWciLCJlZmZlY3RpdmVDb25maWciLCJvcHRpb25zIiwiZmluZEhpZ2hlc3RQZWFrRGF5IiwidG90YWxzQnlEYXkiLCJoaWdoZXN0RGF5IiwibWF4VG90YWwiLCJ0b3RhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/simulation.ts\n"));

/***/ })

});