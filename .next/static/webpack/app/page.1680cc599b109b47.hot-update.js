"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BATTERY_OPTIONS: function() { return /* binding */ BATTERY_OPTIONS; },\n/* harmony export */   buildDataQualityReport: function() { return /* binding */ buildDataQualityReport; },\n/* harmony export */   buildDayKwSeries: function() { return /* binding */ buildDayKwSeries; },\n/* harmony export */   buildDayProfile: function() { return /* binding */ buildDayProfile; },\n/* harmony export */   computeSizing: function() { return /* binding */ computeSizing; },\n/* harmony export */   findMaxObserved: function() { return /* binding */ findMaxObserved; },\n/* harmony export */   groupPeakEvents: function() { return /* binding */ groupPeakEvents; },\n/* harmony export */   listPeakMoments: function() { return /* binding */ listPeakMoments; },\n/* harmony export */   processIntervals: function() { return /* binding */ processIntervals; },\n/* harmony export */   selectMinimumCostBatteryOptions: function() { return /* binding */ selectMinimumCostBatteryOptions; },\n/* harmony export */   selectTopExceededIntervals: function() { return /* binding */ selectTopExceededIntervals; }\n/* harmony export */ });\n/* harmony import */ var _datetime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime */ \"(app-pages-browser)/./lib/datetime.ts\");\n\nconst BATTERY_OPTIONS = [\n    {\n        label: \"WattsNext ESS Cabinet 64 kWh\",\n        capacityKwh: 64,\n        modular: true,\n        unitPriceEur: 15689.33\n    },\n    {\n        label: \"WattsNext ESS Cabinet 96 kWh\",\n        capacityKwh: 96,\n        modular: true,\n        unitPriceEur: 22225.98\n    },\n    {\n        label: \"ESS All-in-one Cabinet 261 kWh\",\n        capacityKwh: 261,\n        modular: true,\n        unitPriceEur: 43995.96\n    },\n    {\n        label: \"WattsNext All-in-one Container 2.09 MWh\",\n        capacityKwh: 2090,\n        modular: false,\n        unitPriceEur: 318658.06\n    },\n    {\n        label: \"WattsNext All in-one Container 5.015 MWh\",\n        capacityKwh: 5015,\n        modular: false,\n        unitPriceEur: 675052.49\n    }\n];\nfunction roundCurrency(value) {\n    return Math.round(value * 100) / 100;\n}\nfunction toBatteryProduct(candidate) {\n    const totalPriceEur = roundCurrency(candidate.totalPriceEur);\n    return {\n        label: candidate.label,\n        capacityKwh: candidate.totalCapacityKwh,\n        unitCapacityKwh: candidate.unitCapacityKwh,\n        count: candidate.count,\n        unitPriceEur: roundCurrency(candidate.unitPriceEur),\n        totalPriceEur,\n        breakdown: [\n            {\n                type: \"\".concat(candidate.unitCapacityKwh, \" kWh\"),\n                count: candidate.count,\n                unitCapacityKwh: candidate.unitCapacityKwh,\n                unitPriceEur: roundCurrency(candidate.unitPriceEur),\n                totalPriceEur\n            }\n        ]\n    };\n}\nfunction selectMinimumCostBatteryOptions(requiredKwh) {\n    const normalizedRequired = Math.max(0, requiredKwh);\n    const candidates = [];\n    BATTERY_OPTIONS.forEach((option)=>{\n        var _option_unitPriceEur;\n        const unitPriceEur = (_option_unitPriceEur = option.unitPriceEur) !== null && _option_unitPriceEur !== void 0 ? _option_unitPriceEur : 0;\n        if (option.modular) {\n            const maxCount = Math.max(1, Math.ceil(normalizedRequired / option.capacityKwh));\n            for(let count = 1; count <= maxCount; count += 1){\n                const totalCapacityKwh = count * option.capacityKwh;\n                if (totalCapacityKwh < normalizedRequired) continue;\n                const totalPriceEur = count * unitPriceEur;\n                candidates.push({\n                    label: \"\".concat(count, \"x \").concat(option.capacityKwh, \" kWh (modulair)\"),\n                    totalCapacityKwh,\n                    totalPriceEur,\n                    overCapacityKwh: totalCapacityKwh - normalizedRequired,\n                    count,\n                    unitCapacityKwh: option.capacityKwh,\n                    unitPriceEur\n                });\n            }\n            return;\n        }\n        if (option.capacityKwh >= normalizedRequired) {\n            candidates.push({\n                label: option.label,\n                totalCapacityKwh: option.capacityKwh,\n                totalPriceEur: unitPriceEur,\n                overCapacityKwh: option.capacityKwh - normalizedRequired,\n                count: 1,\n                unitCapacityKwh: option.capacityKwh,\n                unitPriceEur\n            });\n        }\n    });\n    const sorted = candidates.sort((a, b)=>a.totalPriceEur - b.totalPriceEur || a.overCapacityKwh - b.overCapacityKwh || a.totalCapacityKwh - b.totalCapacityKwh);\n    const recommendedProduct = toBatteryProduct(sorted[0]);\n    const alternativeProduct = sorted[1] ? toBatteryProduct(sorted[1]) : null;\n    return {\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction processIntervals(rows, contractedPowerKw) {\n    return rows.map((row)=>{\n        const timestamp = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(row.timestamp);\n        const normalizedTimestamp = Number.isNaN(timestamp.getTime()) ? row.timestamp : timestamp.toISOString();\n        const consumptionKw = row.consumptionKwh / 0.25;\n        const excessKw = Math.max(0, consumptionKw - contractedPowerKw);\n        return {\n            ...row,\n            timestamp: normalizedTimestamp,\n            consumptionKw,\n            excessKw,\n            excessKwh: excessKw * 0.25\n        };\n    });\n}\nfunction groupPeakEvents(intervals) {\n    const events = [];\n    let current = null;\n    intervals.forEach((interval, index)=>{\n        if (interval.excessKw > 0) {\n            if (!current) {\n                current = {\n                    peakTimestamp: interval.timestamp,\n                    durationIntervals: 0,\n                    maxExcessKw: 0,\n                    totalExcessKwh: 0,\n                    intervalIndexes: []\n                };\n            }\n            current.durationIntervals += 1;\n            if (interval.excessKw > current.maxExcessKw || interval.excessKw === current.maxExcessKw && interval.timestamp < current.peakTimestamp) {\n                current.maxExcessKw = interval.excessKw;\n                current.peakTimestamp = interval.timestamp;\n            }\n            current.totalExcessKwh += interval.excessKwh;\n            current.intervalIndexes.push(index);\n        } else if (current) {\n            events.push(current);\n            current = null;\n        }\n    });\n    if (current) {\n        events.push(current);\n    }\n    return events;\n}\nfunction listPeakMoments(intervals) {\n    return intervals.filter((interval)=>interval.excessKw > 0).sort((a, b)=>a.timestamp.localeCompare(b.timestamp)).map((interval)=>({\n            timestamp: interval.timestamp,\n            consumptionKw: interval.consumptionKw,\n            excessKw: interval.excessKw,\n            excessKwh: interval.excessKwh\n        }));\n}\nfunction percentile(values, p) {\n    if (values.length === 0) return 0;\n    const sorted = [\n        ...values\n    ].sort((a, b)=>a - b);\n    const idx = Math.ceil(p / 100 * sorted.length) - 1;\n    return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\n}\nfunction computeSizing(params) {\n    const { intervals, events, method, compliance, safetyFactor, efficiency } = params;\n    let kWhNeededRaw = 0;\n    let kWNeededRaw = 0;\n    if (method === \"MAX_PEAK\") {\n        const highestEnergyEvent = [\n            ...events\n        ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n        if (highestEnergyEvent) {\n            kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n            kWNeededRaw = highestEnergyEvent.maxExcessKw;\n        }\n    }\n    if (method === \"P95\") {\n        if (events.length < 20) {\n            const highestEnergyEvent = [\n                ...events\n            ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n            if (highestEnergyEvent) {\n                kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n                kWNeededRaw = highestEnergyEvent.maxExcessKw;\n            }\n        } else {\n            kWhNeededRaw = percentile(events.map((event)=>event.totalExcessKwh), 95);\n            kWNeededRaw = percentile(events.map((event)=>event.maxExcessKw), 95);\n        }\n    }\n    if (method === \"FULL_COVERAGE\") {\n        const byDay = new Map();\n        intervals.forEach((interval)=>{\n            const day = interval.timestamp.slice(0, 10);\n            var _byDay_get;\n            const list = (_byDay_get = byDay.get(day)) !== null && _byDay_get !== void 0 ? _byDay_get : [];\n            list.push(interval);\n            byDay.set(day, list);\n        });\n        let maxDayEnergy = 0;\n        let maxDayPeak = 0;\n        byDay.forEach((dayIntervals)=>{\n            const dayEnergy = dayIntervals.reduce((sum, interval)=>sum + interval.excessKwh, 0);\n            if (dayEnergy > maxDayEnergy) {\n                maxDayEnergy = dayEnergy;\n                maxDayPeak = Math.max(...dayIntervals.map((interval)=>interval.excessKw));\n            }\n        });\n        kWhNeededRaw = maxDayEnergy;\n        kWNeededRaw = maxDayPeak;\n    }\n    kWhNeededRaw *= compliance;\n    kWNeededRaw *= compliance;\n    const kWhNeeded = kWhNeededRaw / efficiency * safetyFactor;\n    const kWNeeded = kWNeededRaw * safetyFactor;\n    const { recommendedProduct, alternativeProduct } = selectMinimumCostBatteryOptions(kWhNeeded);\n    return {\n        kWhNeededRaw,\n        kWNeededRaw,\n        kWhNeeded,\n        kWNeeded,\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction buildDataQualityReport(intervals) {\n    var _timestamps_, _timestamps_1;\n    if (intervals.length === 0) {\n        return {\n            rows: 0,\n            startDate: null,\n            endDate: null,\n            missingIntervalsCount: 0,\n            duplicateCount: 0,\n            non15MinIntervals: 0,\n            warnings: [\n                \"No rows found in dataset.\"\n            ]\n        };\n    }\n    const timestamps = intervals.map((row)=>new Date(row.timestamp)).filter((date)=>!Number.isNaN(date.getTime())).sort((a, b)=>a.getTime() - b.getTime());\n    const duplicateCount = timestamps.length - new Set(timestamps.map((d)=>d.toISOString())).size;\n    let non15MinIntervals = 0;\n    let missingIntervalsCount = 0;\n    const EPS = 0.01;\n    for(let i = 1; i < timestamps.length; i += 1){\n        const diffMinutes = (timestamps[i].getTime() - timestamps[i - 1].getTime()) / 60000;\n        if (Math.abs(diffMinutes - 15) > EPS) {\n            non15MinIntervals += 1;\n            if (diffMinutes > 15 + EPS) {\n                missingIntervalsCount += Math.max(0, Math.round(diffMinutes / 15) - 1);\n            }\n        }\n    }\n    const warnings = [];\n    if (duplicateCount > 0) warnings.push(\"Detected \".concat(duplicateCount, \" duplicate timestamps.\"));\n    if (non15MinIntervals > 0) {\n        warnings.push(\"Detected \".concat(non15MinIntervals, \" non-15-minute interval transitions.\"));\n    }\n    var _timestamps__toISOString, _timestamps__toISOString1;\n    return {\n        rows: intervals.length,\n        startDate: (_timestamps__toISOString = (_timestamps_ = timestamps[0]) === null || _timestamps_ === void 0 ? void 0 : _timestamps_.toISOString()) !== null && _timestamps__toISOString !== void 0 ? _timestamps__toISOString : null,\n        endDate: (_timestamps__toISOString1 = (_timestamps_1 = timestamps[timestamps.length - 1]) === null || _timestamps_1 === void 0 ? void 0 : _timestamps_1.toISOString()) !== null && _timestamps__toISOString1 !== void 0 ? _timestamps__toISOString1 : null,\n        missingIntervalsCount,\n        duplicateCount,\n        non15MinIntervals,\n        warnings\n    };\n}\nfunction findMaxObserved(intervals) {\n    if (intervals.length === 0) {\n        return {\n            maxObservedKw: 0,\n            maxObservedTimestamp: null\n        };\n    }\n    let maxObservedKw = -1;\n    let maxObservedTimestamp = null;\n    intervals.forEach((interval)=>{\n        if (interval.consumptionKw > maxObservedKw || interval.consumptionKw === maxObservedKw && maxObservedTimestamp !== null && interval.timestamp < maxObservedTimestamp) {\n            maxObservedKw = interval.consumptionKw;\n            maxObservedTimestamp = interval.timestamp;\n        }\n    });\n    return {\n        maxObservedKw,\n        maxObservedTimestamp\n    };\n}\nfunction selectTopExceededIntervals(intervals, day) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;\n    return intervals.filter((interval)=>(0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp) === day && interval.excessKw > 0).sort((a, b)=>b.excessKw - a.excessKw || a.timestamp.localeCompare(b.timestamp)).slice(0, limit).map((interval)=>({\n            timestamp: interval.timestamp,\n            consumption_kW: interval.consumptionKw,\n            excess_kW: interval.excessKw\n        }));\n}\nfunction buildDayProfile(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    const fullDaySeries = buildDayKwSeries(intervals.map((interval)=>({\n            timestamp: interval.timestamp,\n            consumptionKw: interval.consumptionKw\n        })), dayIso, intervalMinutes, timeZone);\n    return fullDaySeries.map((slot)=>({\n            timestampLabel: slot.timeLabel,\n            timestampIso: slot.timestampIso,\n            observedKw: slot.consumptionKw\n        }));\n}\nfunction buildDayKwSeries(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    if (!dayIso || intervalMinutes <= 0) return [];\n    const [year, month, day] = dayIso.split(\"-\").map(Number);\n    const dayStartLocal = new Date(year, month - 1, day, 0, 0, 0, 0);\n    if (Number.isNaN(dayStartLocal.getTime())) return [];\n    const slotsPerDay = Math.floor(24 * 60 / intervalMinutes);\n    const profile = Array.from({\n        length: slotsPerDay\n    }, (_, index)=>{\n        const minutes = index * intervalMinutes;\n        const hour = Math.floor(minutes / 60);\n        const minute = minutes % 60;\n        return {\n            timeLabel: \"\".concat(String(hour).padStart(2, \"0\"), \":\").concat(String(minute).padStart(2, \"0\")),\n            timestampIso: new Date(dayStartLocal.getTime() + minutes * 60000).toISOString(),\n            consumptionKw: 0\n        };\n    });\n    intervals.forEach((interval)=>{\n        if ((0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp, timeZone) !== dayIso) return;\n        const dt = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(interval.timestamp);\n        if (Number.isNaN(dt.getTime())) return;\n        const { hour, minute } = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalHourMinute)(dt, timeZone);\n        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return;\n        const minuteOfDay = hour * 60 + minute;\n        const slotIndex = Math.floor(minuteOfDay / intervalMinutes);\n        if (slotIndex < 0 || slotIndex >= slotsPerDay) return;\n        profile[slotIndex].consumptionKw = Math.max(profile[slotIndex].consumptionKw, interval.consumptionKw);\n    });\n    return profile;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jYWxjdWxhdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWdGO0FBd0Z6RSxNQUFNRyxrQkFBb0M7SUFDL0M7UUFDRUMsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsY0FBYztJQUNoQjtJQUNBO1FBQ0VILE9BQU87UUFDUEMsYUFBYTtRQUNiQyxTQUFTO1FBQ1RDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxPQUFPO1FBQ1BDLGFBQWE7UUFDYkMsU0FBUztRQUNUQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsY0FBYztJQUNoQjtJQUNBO1FBQ0VILE9BQU87UUFDUEMsYUFBYTtRQUNiQyxTQUFTO1FBQ1RDLGNBQWM7SUFDaEI7Q0FDRCxDQUFDO0FBWUYsU0FBU0MsY0FBY0MsS0FBYTtJQUNsQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNGLFFBQVEsT0FBTztBQUNuQztBQUVBLFNBQVNHLGlCQUFpQkMsU0FBd0M7SUFDaEUsTUFBTUMsZ0JBQWdCTixjQUFjSyxVQUFVQyxhQUFhO0lBQzNELE9BQU87UUFDTFYsT0FBT1MsVUFBVVQsS0FBSztRQUN0QkMsYUFBYVEsVUFBVUUsZ0JBQWdCO1FBQ3ZDQyxpQkFBaUJILFVBQVVHLGVBQWU7UUFDMUNDLE9BQU9KLFVBQVVJLEtBQUs7UUFDdEJWLGNBQWNDLGNBQWNLLFVBQVVOLFlBQVk7UUFDbERPO1FBQ0FJLFdBQVc7WUFDVDtnQkFDRUMsTUFBTSxHQUE2QixPQUExQk4sVUFBVUcsZUFBZSxFQUFDO2dCQUNuQ0MsT0FBT0osVUFBVUksS0FBSztnQkFDdEJELGlCQUFpQkgsVUFBVUcsZUFBZTtnQkFDMUNULGNBQWNDLGNBQWNLLFVBQVVOLFlBQVk7Z0JBQ2xETztZQUNGO1NBQ0Q7SUFDSDtBQUNGO0FBRU8sU0FBU00sZ0NBQWdDQyxXQUFtQjtJQUlqRSxNQUFNQyxxQkFBcUJaLEtBQUthLEdB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WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jYWxjdWxhdGlvbnMudHM/M2Y3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMb2NhbERheUlzbywgZ2V0TG9jYWxIb3VyTWludXRlLCBwYXJzZVRpbWVzdGFtcCB9IGZyb20gJy4vZGF0ZXRpbWUnO1xuXG5leHBvcnQgdHlwZSBNZXRob2QgPSAnTUFYX1BFQUsnIHwgJ1A5NScgfCAnRlVMTF9DT1ZFUkFHRSc7XG5cclxuZXhwb3J0IGludGVyZmFjZSBJbnRlcnZhbFJlY29yZCB7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgY29uc3VtcHRpb25Ld2g6IG51bWJlcjtcclxuICBleHBvcnRLd2g/OiBudW1iZXI7XHJcbiAgcHZLd2g/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2VkSW50ZXJ2YWwgZXh0ZW5kcyBJbnRlcnZhbFJlY29yZCB7XHJcbiAgY29uc3VtcHRpb25LdzogbnVtYmVyO1xyXG4gIGV4Y2Vzc0t3OiBudW1iZXI7XHJcbiAgZXhjZXNzS3doOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGVha0V2ZW50IHtcbiAgcGVha1RpbWVzdGFtcDogc3RyaW5nO1xuICBkdXJhdGlvbkludGVydmFsczogbnVtYmVyO1xuICBtYXhFeGNlc3NLdzogbnVtYmVyO1xuICB0b3RhbEV4Y2Vzc0t3aDogbnVtYmVyO1xuICBpbnRlcnZhbEluZGV4ZXM6IG51bWJlcltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBlYWtNb21lbnQge1xuICB0aW1lc3RhbXA6IHN0cmluZztcbiAgY29uc3VtcHRpb25LdzogbnVtYmVyO1xuICBleGNlc3NLdzogbnVtYmVyO1xuICBleGNlc3NLd2g6IG51bWJlcjtcbn1cblxyXG5leHBvcnQgaW50ZXJmYWNlIERhdGFRdWFsaXR5UmVwb3J0IHtcclxuICByb3dzOiBudW1iZXI7XHJcbiAgc3RhcnREYXRlOiBzdHJpbmcgfCBudWxsO1xyXG4gIGVuZERhdGU6IHN0cmluZyB8IG51bGw7XHJcbiAgbWlzc2luZ0ludGVydmFsc0NvdW50OiBudW1iZXI7XHJcbiAgZHVwbGljYXRlQ291bnQ6IG51bWJlcjtcclxuICBub24xNU1pbkludGVydmFsczogbnVtYmVyO1xyXG4gIHdhcm5pbmdzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTaXppbmdSZXN1bHQge1xyXG4gIGtXaE5lZWRlZFJhdzogbnVtYmVyO1xyXG4gIGtXTmVlZGVkUmF3OiBudW1iZXI7XHJcbiAga1doTmVlZGVkOiBudW1iZXI7XHJcbiAga1dOZWVkZWQ6IG51bWJlcjtcclxuICByZWNvbW1lbmRlZFByb2R1Y3Q6IEJhdHRlcnlQcm9kdWN0O1xyXG4gIGFsdGVybmF0aXZlUHJvZHVjdDogQmF0dGVyeVByb2R1Y3QgfCBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhdHRlcnlQcm9kdWN0IHtcbiAgbGFiZWw6IHN0cmluZztcbiAgY2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgbW9kdWxhcj86IGJvb2xlYW47XG4gIHVuaXRQcmljZUV1cj86IG51bWJlcjtcbiAgdW5pdENhcGFjaXR5S3doPzogbnVtYmVyO1xuICBjb3VudD86IG51bWJlcjtcbiAgdG90YWxQcmljZUV1cj86IG51bWJlcjtcbiAgYnJlYWtkb3duPzogQmF0dGVyeUJyZWFrZG93bltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdHRlcnlCcmVha2Rvd24ge1xuICB0eXBlOiBzdHJpbmc7XG4gIGNvdW50OiBudW1iZXI7XG4gIHVuaXRDYXBhY2l0eUt3aDogbnVtYmVyO1xuICB1bml0UHJpY2VFdXI6IG51bWJlcjtcbiAgdG90YWxQcmljZUV1cjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4Y2VlZGVkSW50ZXJ2YWwge1xuICB0aW1lc3RhbXA6IHN0cmluZztcbiAgY29uc3VtcHRpb25fa1c6IG51bWJlcjtcbiAgZXhjZXNzX2tXOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5UHJvZmlsZVBvaW50IHtcbiAgdGltZXN0YW1wTGFiZWw6IHN0cmluZztcbiAgdGltZXN0YW1wSXNvOiBzdHJpbmc7XG4gIG9ic2VydmVkS3c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXlLd1Nlcmllc1BvaW50IHtcbiAgdGltZUxhYmVsOiBzdHJpbmc7XG4gIHRpbWVzdGFtcElzbzogc3RyaW5nO1xuICBjb25zdW1wdGlvbkt3OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBCQVRURVJZX09QVElPTlM6IEJhdHRlcnlQcm9kdWN0W10gPSBbXG4gIHtcbiAgICBsYWJlbDogJ1dhdHRzTmV4dCBFU1MgQ2FiaW5ldCA2NCBrV2gnLFxuICAgIGNhcGFjaXR5S3doOiA2NCxcbiAgICBtb2R1bGFyOiB0cnVlLFxuICAgIHVuaXRQcmljZUV1cjogMTU2ODkuMzNcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnV2F0dHNOZXh0IEVTUyBDYWJpbmV0IDk2IGtXaCcsXG4gICAgY2FwYWNpdHlLd2g6IDk2LFxuICAgIG1vZHVsYXI6IHRydWUsXG4gICAgdW5pdFByaWNlRXVyOiAyMjIyNS45OFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdFU1MgQWxsLWluLW9uZSBDYWJpbmV0IDI2MSBrV2gnLFxuICAgIGNhcGFjaXR5S3doOiAyNjEsXG4gICAgbW9kdWxhcjogdHJ1ZSxcbiAgICB1bml0UHJpY2VFdXI6IDQzOTk1Ljk2XG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1dhdHRzTmV4dCBBbGwtaW4tb25lIENvbnRhaW5lciAyLjA5IE1XaCcsXG4gICAgY2FwYWNpdHlLd2g6IDIwOTAsXG4gICAgbW9kdWxhcjogZmFsc2UsXG4gICAgdW5pdFByaWNlRXVyOiAzMTg2NTguMDZcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnV2F0dHNOZXh0IEFsbCBpbi1vbmUgQ29udGFpbmVyIDUuMDE1IE1XaCcsXG4gICAgY2FwYWNpdHlLd2g6IDUwMTUsXG4gICAgbW9kdWxhcjogZmFsc2UsXG4gICAgdW5pdFByaWNlRXVyOiA2NzUwNTIuNDlcbiAgfVxuXTtcblxuaW50ZXJmYWNlIEJhdHRlcnlDb25maWd1cmF0aW9uQ2FuZGlkYXRlIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgdG90YWxDYXBhY2l0eUt3aDogbnVtYmVyO1xuICB0b3RhbFByaWNlRXVyOiBudW1iZXI7XG4gIG92ZXJDYXBhY2l0eUt3aDogbnVtYmVyO1xuICBjb3VudDogbnVtYmVyO1xuICB1bml0Q2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgdW5pdFByaWNlRXVyOiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIHJvdW5kQ3VycmVuY3kodmFsdWU6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwKSAvIDEwMDtcbn1cblxuZnVuY3Rpb24gdG9CYXR0ZXJ5UHJvZHVjdChjYW5kaWRhdGU6IEJhdHRlcnlDb25maWd1cmF0aW9uQ2FuZGlkYXRlKTogQmF0dGVyeVByb2R1Y3Qge1xuICBjb25zdCB0b3RhbFByaWNlRXVyID0gcm91bmRDdXJyZW5jeShjYW5kaWRhdGUudG90YWxQcmljZUV1cik7XG4gIHJldHVybiB7XG4gICAgbGFiZWw6IGNhbmRpZGF0ZS5sYWJlbCxcbiAgICBjYXBhY2l0eUt3aDogY2FuZGlkYXRlLnRvdGFsQ2FwYWNpdHlLd2gsXG4gICAgdW5pdENhcGFjaXR5S3doOiBjYW5kaWRhdGUudW5pdENhcGFjaXR5S3doLFxuICAgIGNvdW50OiBjYW5kaWRhdGUuY291bnQsXG4gICAgdW5pdFByaWNlRXVyOiByb3VuZEN1cnJlbmN5KGNhbmRpZGF0ZS51bml0UHJpY2VFdXIpLFxuICAgIHRvdGFsUHJpY2VFdXIsXG4gICAgYnJlYWtkb3duOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IGAke2NhbmRpZGF0ZS51bml0Q2FwYWNpdHlLd2h9IGtXaGAsXG4gICAgICAgIGNvdW50OiBjYW5kaWRhdGUuY291bnQsXG4gICAgICAgIHVuaXRDYXBhY2l0eUt3aDogY2FuZGlkYXRlLnVuaXRDYXBhY2l0eUt3aCxcbiAgICAgICAgdW5pdFByaWNlRXVyOiByb3VuZEN1cnJlbmN5KGNhbmRpZGF0ZS51bml0UHJpY2VFdXIpLFxuICAgICAgICB0b3RhbFByaWNlRXVyXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0TWluaW11bUNvc3RCYXR0ZXJ5T3B0aW9ucyhyZXF1aXJlZEt3aDogbnVtYmVyKToge1xuICByZWNvbW1lbmRlZFByb2R1Y3Q6IEJhdHRlcnlQcm9kdWN0O1xuICBhbHRlcm5hdGl2ZVByb2R1Y3Q6IEJhdHRlcnlQcm9kdWN0IHwgbnVsbDtcbn0ge1xuICBjb25zdCBub3JtYWxpemVkUmVxdWlyZWQgPSBNYXRoLm1heCgwLCByZXF1aXJlZEt3aCk7XG4gIGNvbnN0IGNhbmRpZGF0ZXM6IEJhdHRlcnlDb25maWd1cmF0aW9uQ2FuZGlkYXRlW10gPSBbXTtcblxuICBCQVRURVJZX09QVElPTlMuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgY29uc3QgdW5pdFByaWNlRXVyID0gb3B0aW9uLnVuaXRQcmljZUV1ciA/PyAwO1xuICAgIGlmIChvcHRpb24ubW9kdWxhcikge1xuICAgICAgY29uc3QgbWF4Q291bnQgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwobm9ybWFsaXplZFJlcXVpcmVkIC8gb3B0aW9uLmNhcGFjaXR5S3doKSk7XG4gICAgICBmb3IgKGxldCBjb3VudCA9IDE7IGNvdW50IDw9IG1heENvdW50OyBjb3VudCArPSAxKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsQ2FwYWNpdHlLd2ggPSBjb3VudCAqIG9wdGlvbi5jYXBhY2l0eUt3aDtcbiAgICAgICAgaWYgKHRvdGFsQ2FwYWNpdHlLd2ggPCBub3JtYWxpemVkUmVxdWlyZWQpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB0b3RhbFByaWNlRXVyID0gY291bnQgKiB1bml0UHJpY2VFdXI7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgbGFiZWw6IGAke2NvdW50fXggJHtvcHRpb24uY2FwYWNpdHlLd2h9IGtXaCAobW9kdWxhaXIpYCxcbiAgICAgICAgICB0b3RhbENhcGFjaXR5S3doLFxuICAgICAgICAgIHRvdGFsUHJpY2VFdXIsXG4gICAgICAgICAgb3ZlckNhcGFjaXR5S3doOiB0b3RhbENhcGFjaXR5S3doIC0gbm9ybWFsaXplZFJlcXVpcmVkLFxuICAgICAgICAgIGNvdW50LFxuICAgICAgICAgIHVuaXRDYXBhY2l0eUt3aDogb3B0aW9uLmNhcGFjaXR5S3doLFxuICAgICAgICAgIHVuaXRQcmljZUV1clxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uLmNhcGFjaXR5S3doID49IG5vcm1hbGl6ZWRSZXF1aXJlZCkge1xuICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgbGFiZWw6IG9wdGlvbi5sYWJlbCxcbiAgICAgICAgdG90YWxDYXBhY2l0eUt3aDogb3B0aW9uLmNhcGFjaXR5S3doLFxuICAgICAgICB0b3RhbFByaWNlRXVyOiB1bml0UHJpY2VFdXIsXG4gICAgICAgIG92ZXJDYXBhY2l0eUt3aDogb3B0aW9uLmNhcGFjaXR5S3doIC0gbm9ybWFsaXplZFJlcXVpcmVkLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgdW5pdENhcGFjaXR5S3doOiBvcHRpb24uY2FwYWNpdHlLd2gsXG4gICAgICAgIHVuaXRQcmljZUV1clxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBzb3J0ZWQgPSBjYW5kaWRhdGVzLnNvcnQoXG4gICAgKGEsIGIpID0+XG4gICAgICBhLnRvdGFsUHJpY2VFdXIgLSBiLnRvdGFsUHJpY2VFdXIgfHxcbiAgICAgIGEub3ZlckNhcGFjaXR5S3doIC0gYi5vdmVyQ2FwYWNpdHlLd2ggfHxcbiAgICAgIGEudG90YWxDYXBhY2l0eUt3aCAtIGIudG90YWxDYXBhY2l0eUt3aFxuICApO1xuXG4gIGNvbnN0IHJlY29tbWVuZGVkUHJvZHVjdCA9IHRvQmF0dGVyeVByb2R1Y3Qoc29ydGVkWzBdKTtcbiAgY29uc3QgYWx0ZXJuYXRpdmVQcm9kdWN0ID0gc29ydGVkWzFdID8gdG9CYXR0ZXJ5UHJvZHVjdChzb3J0ZWRbMV0pIDogbnVsbDtcblxuICByZXR1cm4geyByZWNvbW1lbmRlZFByb2R1Y3QsIGFsdGVybmF0aXZlUHJvZHVjdCB9O1xufVxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzSW50ZXJ2YWxzKFxuICByb3dzOiBJbnRlcnZhbFJlY29yZFtdLFxuICBjb250cmFjdGVkUG93ZXJLdzogbnVtYmVyXG4pOiBQcm9jZXNzZWRJbnRlcnZhbFtdIHtcbiAgcmV0dXJuIHJvd3MubWFwKChyb3cpID0+IHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZVRpbWVzdGFtcChyb3cudGltZXN0YW1wKTtcbiAgICBjb25zdCBub3JtYWxpemVkVGltZXN0YW1wID0gTnVtYmVyLmlzTmFOKHRpbWVzdGFtcC5nZXRUaW1lKCkpID8gcm93LnRpbWVzdGFtcCA6IHRpbWVzdGFtcC50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IGNvbnN1bXB0aW9uS3cgPSByb3cuY29uc3VtcHRpb25Ld2ggLyAwLjI1O1xuICAgIGNvbnN0IGV4Y2Vzc0t3ID0gTWF0aC5tYXgoMCwgY29uc3VtcHRpb25LdyAtIGNvbnRyYWN0ZWRQb3dlckt3KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucm93LFxuICAgICAgdGltZXN0YW1wOiBub3JtYWxpemVkVGltZXN0YW1wLFxuICAgICAgY29uc3VtcHRpb25LdyxcbiAgICAgIGV4Y2Vzc0t3LFxuICAgICAgZXhjZXNzS3doOiBleGNlc3NLdyAqIDAuMjVcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBQZWFrRXZlbnRzKGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSk6IFBlYWtFdmVudFtdIHtcbiAgY29uc3QgZXZlbnRzOiBQZWFrRXZlbnRbXSA9IFtdO1xuICBsZXQgY3VycmVudDogUGVha0V2ZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbnRlcnZhbC5leGNlc3NLdyA+IDApIHtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICBjdXJyZW50ID0ge1xuICAgICAgICAgIHBlYWtUaW1lc3RhbXA6IGludGVydmFsLnRpbWVzdGFtcCxcbiAgICAgICAgICBkdXJhdGlvbkludGVydmFsczogMCxcbiAgICAgICAgICBtYXhFeGNlc3NLdzogMCxcbiAgICAgICAgICB0b3RhbEV4Y2Vzc0t3aDogMCxcbiAgICAgICAgICBpbnRlcnZhbEluZGV4ZXM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjdXJyZW50LmR1cmF0aW9uSW50ZXJ2YWxzICs9IDE7XG4gICAgICBpZiAoXG4gICAgICAgIGludGVydmFsLmV4Y2Vzc0t3ID4gY3VycmVudC5tYXhFeGNlc3NLdyB8fFxuICAgICAgICAoaW50ZXJ2YWwuZXhjZXNzS3cgPT09IGN1cnJlbnQubWF4RXhjZXNzS3cgJiYgaW50ZXJ2YWwudGltZXN0YW1wIDwgY3VycmVudC5wZWFrVGltZXN0YW1wKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnQubWF4RXhjZXNzS3cgPSBpbnRlcnZhbC5leGNlc3NLdztcbiAgICAgICAgY3VycmVudC5wZWFrVGltZXN0YW1wID0gaW50ZXJ2YWwudGltZXN0YW1wO1xuICAgICAgfVxuICAgICAgY3VycmVudC50b3RhbEV4Y2Vzc0t3aCArPSBpbnRlcnZhbC5leGNlc3NLd2g7XG4gICAgICBjdXJyZW50LmludGVydmFsSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGV2ZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKGN1cnJlbnQpIHtcclxuICAgIGV2ZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RQZWFrTW9tZW50cyhpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10pOiBQZWFrTW9tZW50W10ge1xuICByZXR1cm4gaW50ZXJ2YWxzXG4gICAgLmZpbHRlcigoaW50ZXJ2YWwpID0+IGludGVydmFsLmV4Y2Vzc0t3ID4gMClcbiAgICAuc29ydCgoYSwgYikgPT4gYS50aW1lc3RhbXAubG9jYWxlQ29tcGFyZShiLnRpbWVzdGFtcCkpXG4gICAgLm1hcCgoaW50ZXJ2YWwpID0+ICh7XG4gICAgICB0aW1lc3RhbXA6IGludGVydmFsLnRpbWVzdGFtcCxcbiAgICAgIGNvbnN1bXB0aW9uS3c6IGludGVydmFsLmNvbnN1bXB0aW9uS3csXG4gICAgICBleGNlc3NLdzogaW50ZXJ2YWwuZXhjZXNzS3csXG4gICAgICBleGNlc3NLd2g6IGludGVydmFsLmV4Y2Vzc0t3aFxuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gcGVyY2VudGlsZSh2YWx1ZXM6IG51bWJlcltdLCBwOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XHJcbiAgY29uc3Qgc29ydGVkID0gWy4uLnZhbHVlc10uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gIGNvbnN0IGlkeCA9IE1hdGguY2VpbCgocCAvIDEwMCkgKiBzb3J0ZWQubGVuZ3RoKSAtIDE7XHJcbiAgcmV0dXJuIHNvcnRlZFtNYXRoLm1heCgwLCBNYXRoLm1pbihpZHgsIHNvcnRlZC5sZW5ndGggLSAxKSldO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNpemluZyhwYXJhbXM6IHtcclxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW107XHJcbiAgZXZlbnRzOiBQZWFrRXZlbnRbXTtcclxuICBtZXRob2Q6IE1ldGhvZDtcclxuICBjb21wbGlhbmNlOiBudW1iZXI7XHJcbiAgc2FmZXR5RmFjdG9yOiBudW1iZXI7XHJcbiAgZWZmaWNpZW5jeTogbnVtYmVyO1xyXG59KTogU2l6aW5nUmVzdWx0IHtcclxuICBjb25zdCB7IGludGVydmFscywgZXZlbnRzLCBtZXRob2QsIGNvbXBsaWFuY2UsIHNhZmV0eUZhY3RvciwgZWZmaWNpZW5jeSB9ID0gcGFyYW1zO1xyXG5cclxuICBsZXQga1doTmVlZGVkUmF3ID0gMDtcclxuICBsZXQga1dOZWVkZWRSYXcgPSAwO1xyXG5cclxuICBpZiAobWV0aG9kID09PSAnTUFYX1BFQUsnKSB7XHJcbiAgICBjb25zdCBoaWdoZXN0RW5lcmd5RXZlbnQgPSBbLi4uZXZlbnRzXS5zb3J0KFxyXG4gICAgICAoYSwgYikgPT4gYi50b3RhbEV4Y2Vzc0t3aCAtIGEudG90YWxFeGNlc3NLd2hcclxuICAgIClbMF07XHJcbiAgICBpZiAoaGlnaGVzdEVuZXJneUV2ZW50KSB7XHJcbiAgICAgIGtXaE5lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC50b3RhbEV4Y2Vzc0t3aDtcclxuICAgICAga1dOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQubWF4RXhjZXNzS3c7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAobWV0aG9kID09PSAnUDk1Jykge1xyXG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPCAyMCkge1xyXG4gICAgICBjb25zdCBoaWdoZXN0RW5lcmd5RXZlbnQgPSBbLi4uZXZlbnRzXS5zb3J0KFxyXG4gICAgICAgIChhLCBiKSA9PiBiLnRvdGFsRXhjZXNzS3doIC0gYS50b3RhbEV4Y2Vzc0t3aFxyXG4gICAgICApWzBdO1xyXG4gICAgICBpZiAoaGlnaGVzdEVuZXJneUV2ZW50KSB7XHJcbiAgICAgICAga1doTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50LnRvdGFsRXhjZXNzS3doO1xyXG4gICAgICAgIGtXTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50Lm1heEV4Y2Vzc0t3O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBrV2hOZWVkZWRSYXcgPSBwZXJjZW50aWxlKFxyXG4gICAgICAgIGV2ZW50cy5tYXAoKGV2ZW50KSA9PiBldmVudC50b3RhbEV4Y2Vzc0t3aCksXHJcbiAgICAgICAgOTVcclxuICAgICAgKTtcclxuICAgICAga1dOZWVkZWRSYXcgPSBwZXJjZW50aWxlKFxyXG4gICAgICAgIGV2ZW50cy5tYXAoKGV2ZW50KSA9PiBldmVudC5tYXhFeGNlc3NLdyksXHJcbiAgICAgICAgOTVcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChtZXRob2QgPT09ICdGVUxMX0NPVkVSQUdFJykge1xyXG4gICAgY29uc3QgYnlEYXkgPSBuZXcgTWFwPHN0cmluZywgUHJvY2Vzc2VkSW50ZXJ2YWxbXT4oKTtcclxuICAgIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXkgPSBpbnRlcnZhbC50aW1lc3RhbXAuc2xpY2UoMCwgMTApO1xyXG4gICAgICBjb25zdCBsaXN0ID0gYnlEYXkuZ2V0KGRheSkgPz8gW107XHJcbiAgICAgIGxpc3QucHVzaChpbnRlcnZhbCk7XHJcbiAgICAgIGJ5RGF5LnNldChkYXksIGxpc3QpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IG1heERheUVuZXJneSA9IDA7XHJcbiAgICBsZXQgbWF4RGF5UGVhayA9IDA7XHJcblxyXG4gICAgYnlEYXkuZm9yRWFjaCgoZGF5SW50ZXJ2YWxzKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRheUVuZXJneSA9IGRheUludGVydmFscy5yZWR1Y2UoKHN1bSwgaW50ZXJ2YWwpID0+IHN1bSArIGludGVydmFsLmV4Y2Vzc0t3aCwgMCk7XHJcbiAgICAgIGlmIChkYXlFbmVyZ3kgPiBtYXhEYXlFbmVyZ3kpIHtcclxuICAgICAgICBtYXhEYXlFbmVyZ3kgPSBkYXlFbmVyZ3k7XHJcbiAgICAgICAgbWF4RGF5UGVhayA9IE1hdGgubWF4KC4uLmRheUludGVydmFscy5tYXAoKGludGVydmFsKSA9PiBpbnRlcnZhbC5leGNlc3NLdykpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBrV2hOZWVkZWRSYXcgPSBtYXhEYXlFbmVyZ3k7XHJcbiAgICBrV05lZWRlZFJhdyA9IG1heERheVBlYWs7XHJcbiAgfVxyXG5cclxuICBrV2hOZWVkZWRSYXcgKj0gY29tcGxpYW5jZTtcclxuICBrV05lZWRlZFJhdyAqPSBjb21wbGlhbmNlO1xyXG5cclxuICBjb25zdCBrV2hOZWVkZWQgPSAoa1doTmVlZGVkUmF3IC8gZWZmaWNpZW5jeSkgKiBzYWZldHlGYWN0b3I7XHJcbiAgY29uc3Qga1dOZWVkZWQgPSBrV05lZWRlZFJhdyAqIHNhZmV0eUZhY3RvcjtcclxuXHJcbiAgY29uc3QgeyByZWNvbW1lbmRlZFByb2R1Y3QsIGFsdGVybmF0aXZlUHJvZHVjdCB9ID0gc2VsZWN0TWluaW11bUNvc3RCYXR0ZXJ5T3B0aW9ucyhrV2hOZWVkZWQpO1xuXHJcbiAgcmV0dXJuIHtcclxuICAgIGtXaE5lZWRlZFJhdyxcclxuICAgIGtXTmVlZGVkUmF3LFxyXG4gICAga1doTmVlZGVkLFxyXG4gICAga1dOZWVkZWQsXHJcbiAgICByZWNvbW1lbmRlZFByb2R1Y3QsXHJcbiAgICBhbHRlcm5hdGl2ZVByb2R1Y3RcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXRhUXVhbGl0eVJlcG9ydChpbnRlcnZhbHM6IEludGVydmFsUmVjb3JkW10pOiBEYXRhUXVhbGl0eVJlcG9ydCB7XG4gIGlmIChpbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb3dzOiAwLFxyXG4gICAgICBzdGFydERhdGU6IG51bGwsXHJcbiAgICAgIGVuZERhdGU6IG51bGwsXHJcbiAgICAgIG1pc3NpbmdJbnRlcnZhbHNDb3VudDogMCxcclxuICAgICAgZHVwbGljYXRlQ291bnQ6IDAsXHJcbiAgICAgIG5vbjE1TWluSW50ZXJ2YWxzOiAwLFxyXG4gICAgICB3YXJuaW5nczogWydObyByb3dzIGZvdW5kIGluIGRhdGFzZXQuJ11cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdCB0aW1lc3RhbXBzID0gaW50ZXJ2YWxzXHJcbiAgICAubWFwKChyb3cpID0+IG5ldyBEYXRlKHJvdy50aW1lc3RhbXApKVxyXG4gICAgLmZpbHRlcigoZGF0ZSkgPT4gIU51bWJlci5pc05hTihkYXRlLmdldFRpbWUoKSkpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKSk7XHJcblxyXG4gIGNvbnN0IGR1cGxpY2F0ZUNvdW50ID0gdGltZXN0YW1wcy5sZW5ndGggLSBuZXcgU2V0KHRpbWVzdGFtcHMubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpKS5zaXplO1xuICBsZXQgbm9uMTVNaW5JbnRlcnZhbHMgPSAwO1xuICBsZXQgbWlzc2luZ0ludGVydmFsc0NvdW50ID0gMDtcbiAgY29uc3QgRVBTID0gMC4wMTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IHRpbWVzdGFtcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBkaWZmTWludXRlcyA9ICh0aW1lc3RhbXBzW2ldLmdldFRpbWUoKSAtIHRpbWVzdGFtcHNbaSAtIDFdLmdldFRpbWUoKSkgLyA2MDAwMDtcbiAgICBpZiAoTWF0aC5hYnMoZGlmZk1pbnV0ZXMgLSAxNSkgPiBFUFMpIHtcbiAgICAgIG5vbjE1TWluSW50ZXJ2YWxzICs9IDE7XG4gICAgICBpZiAoZGlmZk1pbnV0ZXMgPiAxNSArIEVQUykge1xuICAgICAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQgKz0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChkaWZmTWludXRlcyAvIDE1KSAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXHJcbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XHJcbiAgaWYgKGR1cGxpY2F0ZUNvdW50ID4gMCkgd2FybmluZ3MucHVzaChgRGV0ZWN0ZWQgJHtkdXBsaWNhdGVDb3VudH0gZHVwbGljYXRlIHRpbWVzdGFtcHMuYCk7XHJcbiAgaWYgKG5vbjE1TWluSW50ZXJ2YWxzID4gMCkge1xyXG4gICAgd2FybmluZ3MucHVzaChgRGV0ZWN0ZWQgJHtub24xNU1pbkludGVydmFsc30gbm9uLTE1LW1pbnV0ZSBpbnRlcnZhbCB0cmFuc2l0aW9ucy5gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByb3dzOiBpbnRlcnZhbHMubGVuZ3RoLFxyXG4gICAgc3RhcnREYXRlOiB0aW1lc3RhbXBzWzBdPy50b0lTT1N0cmluZygpID8/IG51bGwsXHJcbiAgICBlbmREYXRlOiB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0/LnRvSVNPU3RyaW5nKCkgPz8gbnVsbCxcclxuICAgIG1pc3NpbmdJbnRlcnZhbHNDb3VudCxcclxuICAgIGR1cGxpY2F0ZUNvdW50LFxyXG4gICAgbm9uMTVNaW5JbnRlcnZhbHMsXHJcbiAgICB3YXJuaW5nc1xyXG4gIH07XHJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRNYXhPYnNlcnZlZChpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10pOiB7XG4gIG1heE9ic2VydmVkS3c6IG51bWJlcjtcbiAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IHN0cmluZyB8IG51bGw7XG59IHtcbiAgaWYgKGludGVydmFscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF4T2JzZXJ2ZWRLdzogMCxcbiAgICAgIG1heE9ic2VydmVkVGltZXN0YW1wOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGxldCBtYXhPYnNlcnZlZEt3ID0gLTE7XG4gIGxldCBtYXhPYnNlcnZlZFRpbWVzdGFtcDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgaWYgKFxuICAgICAgaW50ZXJ2YWwuY29uc3VtcHRpb25LdyA+IG1heE9ic2VydmVkS3cgfHxcbiAgICAgIChpbnRlcnZhbC5jb25zdW1wdGlvbkt3ID09PSBtYXhPYnNlcnZlZEt3ICYmXG4gICAgICAgIG1heE9ic2VydmVkVGltZXN0YW1wICE9PSBudWxsICYmXG4gICAgICAgIGludGVydmFsLnRpbWVzdGFtcCA8IG1heE9ic2VydmVkVGltZXN0YW1wKVxuICAgICkge1xuICAgICAgbWF4T2JzZXJ2ZWRLdyA9IGludGVydmFsLmNvbnN1bXB0aW9uS3c7XG4gICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcCA9IGludGVydmFsLnRpbWVzdGFtcDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbWF4T2JzZXJ2ZWRLdyxcbiAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0VG9wRXhjZWVkZWRJbnRlcnZhbHMoXG4gIGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSxcbiAgZGF5OiBzdHJpbmcsXG4gIGxpbWl0ID0gMjBcbik6IEV4Y2VlZGVkSW50ZXJ2YWxbXSB7XG4gIHJldHVybiBpbnRlcnZhbHNcbiAgICAuZmlsdGVyKChpbnRlcnZhbCkgPT4gZ2V0TG9jYWxEYXlJc28oaW50ZXJ2YWwudGltZXN0YW1wKSA9PT0gZGF5ICYmIGludGVydmFsLmV4Y2Vzc0t3ID4gMClcbiAgICAuc29ydCgoYSwgYikgPT4gYi5leGNlc3NLdyAtIGEuZXhjZXNzS3cgfHwgYS50aW1lc3RhbXAubG9jYWxlQ29tcGFyZShiLnRpbWVzdGFtcCkpXG4gICAgLnNsaWNlKDAsIGxpbWl0KVxuICAgIC5tYXAoKGludGVydmFsKSA9PiAoe1xuICAgICAgdGltZXN0YW1wOiBpbnRlcnZhbC50aW1lc3RhbXAsXG4gICAgICBjb25zdW1wdGlvbl9rVzogaW50ZXJ2YWwuY29uc3VtcHRpb25LdyxcbiAgICAgIGV4Y2Vzc19rVzogaW50ZXJ2YWwuZXhjZXNzS3dcbiAgICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERheVByb2ZpbGUoXG4gIGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSxcbiAgZGF5SXNvOiBzdHJpbmcsXG4gIGludGVydmFsTWludXRlcyA9IDE1LFxuICB0aW1lWm9uZSA9ICdFdXJvcGUvQW1zdGVyZGFtJ1xuKTogRGF5UHJvZmlsZVBvaW50W10ge1xuICBjb25zdCBmdWxsRGF5U2VyaWVzID0gYnVpbGREYXlLd1NlcmllcyhcbiAgICBpbnRlcnZhbHMubWFwKChpbnRlcnZhbCkgPT4gKHtcbiAgICAgIHRpbWVzdGFtcDogaW50ZXJ2YWwudGltZXN0YW1wLFxuICAgICAgY29uc3VtcHRpb25LdzogaW50ZXJ2YWwuY29uc3VtcHRpb25Ld1xuICAgIH0pKSxcbiAgICBkYXlJc28sXG4gICAgaW50ZXJ2YWxNaW51dGVzLFxuICAgIHRpbWVab25lXG4gICk7XG5cbiAgcmV0dXJuIGZ1bGxEYXlTZXJpZXMubWFwKChzbG90KSA9PiAoe1xuICAgIHRpbWVzdGFtcExhYmVsOiBzbG90LnRpbWVMYWJlbCxcbiAgICB0aW1lc3RhbXBJc286IHNsb3QudGltZXN0YW1wSXNvLFxuICAgIG9ic2VydmVkS3c6IHNsb3QuY29uc3VtcHRpb25Ld1xuICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERheUt3U2VyaWVzKFxuICBpbnRlcnZhbHM6IHsgdGltZXN0YW1wOiBzdHJpbmc7IGNvbnN1bXB0aW9uS3c6IG51bWJlciB9W10sXG4gIGRheUlzbzogc3RyaW5nLFxuICBpbnRlcnZhbE1pbnV0ZXMgPSAxNSxcbiAgdGltZVpvbmUgPSAnRXVyb3BlL0Ftc3RlcmRhbSdcbik6IERheUt3U2VyaWVzUG9pbnRbXSB7XG4gIGlmICghZGF5SXNvIHx8IGludGVydmFsTWludXRlcyA8PSAwKSByZXR1cm4gW107XG5cbiAgY29uc3QgW3llYXIsIG1vbnRoLCBkYXldID0gZGF5SXNvLnNwbGl0KCctJykubWFwKE51bWJlcik7XG4gIGNvbnN0IGRheVN0YXJ0TG9jYWwgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMCwgMCwgMCwgMCk7XG4gIGlmIChOdW1iZXIuaXNOYU4oZGF5U3RhcnRMb2NhbC5nZXRUaW1lKCkpKSByZXR1cm4gW107XG5cbiAgY29uc3Qgc2xvdHNQZXJEYXkgPSBNYXRoLmZsb29yKCgyNCAqIDYwKSAvIGludGVydmFsTWludXRlcyk7XG4gIGNvbnN0IHByb2ZpbGUgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzbG90c1BlckRheSB9LCAoXywgaW5kZXgpOiBEYXlLd1Nlcmllc1BvaW50ID0+IHtcbiAgICBjb25zdCBtaW51dGVzID0gaW5kZXggKiBpbnRlcnZhbE1pbnV0ZXM7XG4gICAgY29uc3QgaG91ciA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBjb25zdCBtaW51dGUgPSBtaW51dGVzICUgNjA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVMYWJlbDogYCR7U3RyaW5nKGhvdXIpLnBhZFN0YXJ0KDIsICcwJyl9OiR7U3RyaW5nKG1pbnV0ZSkucGFkU3RhcnQoMiwgJzAnKX1gLFxuICAgICAgdGltZXN0YW1wSXNvOiBuZXcgRGF0ZShkYXlTdGFydExvY2FsLmdldFRpbWUoKSArIG1pbnV0ZXMgKiA2MF8wMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBjb25zdW1wdGlvbkt3OiAwXG4gICAgfTtcbiAgfSk7XG5cbiAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgaWYgKGdldExvY2FsRGF5SXNvKGludGVydmFsLnRpbWVzdGFtcCwgdGltZVpvbmUpICE9PSBkYXlJc28pIHJldHVybjtcblxuICAgIGNvbnN0IGR0ID0gcGFyc2VUaW1lc3RhbXAoaW50ZXJ2YWwudGltZXN0YW1wKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGR0LmdldFRpbWUoKSkpIHJldHVybjtcbiAgICBjb25zdCB7IGhvdXIsIG1pbnV0ZSB9ID0gZ2V0TG9jYWxIb3VyTWludXRlKGR0LCB0aW1lWm9uZSk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaG91cikgfHwgIU51bWJlci5pc0Zpbml0ZShtaW51dGUpKSByZXR1cm47XG5cbiAgICBjb25zdCBtaW51dGVPZkRheSA9IGhvdXIgKiA2MCArIG1pbnV0ZTtcbiAgICBjb25zdCBzbG90SW5kZXggPSBNYXRoLmZsb29yKG1pbnV0ZU9mRGF5IC8gaW50ZXJ2YWxNaW51dGVzKTtcbiAgICBpZiAoc2xvdEluZGV4IDwgMCB8fCBzbG90SW5kZXggPj0gc2xvdHNQZXJEYXkpIHJldHVybjtcblxuICAgIHByb2ZpbGVbc2xvdEluZGV4XS5jb25zdW1wdGlvbkt3ID0gTWF0aC5tYXgocHJvZmlsZVtzbG90SW5kZXhdLmNvbnN1bXB0aW9uS3csIGludGVydmFsLmNvbnN1bXB0aW9uS3cpO1xuICB9KTtcblxuICByZXR1cm4gcHJvZmlsZTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRMb2NhbERheUlzbyIsImdldExvY2FsSG91ck1pbnV0ZSIsInBhcnNlVGltZXN0YW1wIiwiQkFUVEVSWV9PUFRJT05TIiwibGFiZWwiLCJjYXBhY2l0eUt3aCIsIm1vZHVsYXIiLCJ1bml0UHJpY2VFdXIiLCJyb3VuZEN1cnJlbmN5IiwidmFsdWUiLCJNYXRoIiwicm91bmQiLCJ0b0JhdHRlcnlQcm9kdWN0IiwiY2FuZGlkYXRlIiwidG90YWxQcmljZUV1ciIsInRvdGFsQ2FwYWNpdHlLd2giLCJ1bml0Q2FwYWNpdHlLd2giLCJjb3VudCIsImJyZWFrZG93biIsInR5cGUiLCJzZWxlY3RNaW5pbXVtQ29zdEJhdHRlcnlPcHRpb25zIiwicmVxdWlyZWRLd2giLCJub3JtYWxpemVkUmVxdWlyZWQiLCJtYXgiLCJjYW5kaWRhdGVzIiwiZm9yRWFjaCIsIm9wdGlvbiIsIm1heENvdW50IiwiY2VpbCIsInB1c2giLCJvdmVyQ2FwYWNpdHlLd2giLCJzb3J0ZWQiLCJzb3J0IiwiYSIsImIiLCJyZWNvbW1lbmRlZFByb2R1Y3QiLCJhbHRlcm5hdGl2ZVByb2R1Y3QiLCJwcm9jZXNzSW50ZXJ2YWxzIiwicm93cyIsImNvbnRyYWN0ZWRQb3dlckt3IiwibWFwIiwicm93IiwidGltZXN0YW1wIiwibm9ybWFsaXplZFRpbWVzdGFtcCIsIk51bWJlciIsImlzTmFOIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwiY29uc3VtcHRpb25LdyIsImNvbnN1bXB0aW9uS3doIiwiZXhjZXNzS3ciLCJleGNlc3NLd2giLCJncm91cFBlYWtFdmVudHMiLCJpbnRlcnZhbHMiLCJldmVudHMiLCJjdXJyZW50IiwiaW50ZXJ2YWwiLCJpbmRleCIsInBlYWtUaW1lc3RhbXAiLCJkdXJhdGlvbkludGVydmFscyIsIm1heEV4Y2Vzc0t3IiwidG90YWxFeGNlc3NLd2giLCJpbnRlcnZhbEluZGV4ZXMiLCJsaXN0UGVha01vbWVudHMiLCJmaWx0ZXIiLCJsb2NhbGVDb21wYXJlIiwicGVyY2VudGlsZSIsInZhbHVlcyIsInAiLCJsZW5ndGgiLCJpZHgiLCJtaW4iLCJjb21wdXRlU2l6aW5nIiwicGFyYW1zIiwibWV0aG9kIiwiY29tcGxpYW5jZSIsInNhZmV0eUZhY3RvciIsImVmZmljaWVuY3kiLCJrV2hOZWVkZWRSYXciLCJrV05lZWRlZFJhdyIsImhpZ2hlc3RFbmVyZ3lFdmVudCIsImV2ZW50IiwiYnlEYXkiLCJNYXAiLCJkYXkiLCJzbGljZSIsImxpc3QiLCJnZXQiLCJzZXQiLCJtYXhEYXlFbmVyZ3kiLCJtYXhEYXlQZWFrIiwiZGF5SW50ZXJ2YWxzIiwiZGF5RW5lcmd5IiwicmVkdWNlIiwic3VtIiwia1doTmVlZGVkIiwia1dOZWVkZWQiLCJidWlsZERhdGFRdWFsaXR5UmVwb3J0IiwidGltZXN0YW1wcyIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJtaXNzaW5nSW50ZXJ2YWxzQ291bnQiLCJkdXBsaWNhdGVDb3VudCIsIm5vbjE1TWluSW50ZXJ2YWxzIiwid2FybmluZ3MiLCJEYXRlIiwiZGF0ZSIsIlNldCIsImQiLCJzaXplIiwiRVBTIiwiaSIsImRpZmZNaW51dGVzIiwiYWJzIiwiZmluZE1heE9ic2VydmVkIiwibWF4T2JzZXJ2ZWRLdyIsIm1heE9ic2VydmVkVGltZXN0YW1wIiwic2VsZWN0VG9wRXhjZWVkZWRJbnRlcnZhbHMiLCJsaW1pdCIsImNvbnN1bXB0aW9uX2tXIiwiZXhjZXNzX2tXIiwiYnVpbGREYXlQcm9maWxlIiwiZGF5SXNvIiwiaW50ZXJ2YWxNaW51dGVzIiwidGltZVpvbmUiLCJmdWxsRGF5U2VyaWVzIiwiYnVpbGREYXlLd1NlcmllcyIsInNsb3QiLCJ0aW1lc3RhbXBMYWJlbCIsInRpbWVMYWJlbCIsInRpbWVzdGFtcElzbyIsIm9ic2VydmVkS3ciLCJ5ZWFyIiwibW9udGgiLCJzcGxpdCIsImRheVN0YXJ0TG9jYWwiLCJzbG90c1BlckRheSIsImZsb29yIiwicHJvZmlsZSIsIkFycmF5IiwiZnJvbSIsIl8iLCJtaW51dGVzIiwiaG91ciIsIm1pbnV0ZSIsIlN0cmluZyIsInBhZFN0YXJ0IiwiZHQiLCJpc0Zpbml0ZSIsIm1pbnV0ZU9mRGF5Iiwic2xvdEluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});