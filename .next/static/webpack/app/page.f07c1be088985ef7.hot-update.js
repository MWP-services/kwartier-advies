"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BATTERY_OPTIONS: function() { return /* binding */ BATTERY_OPTIONS; },\n/* harmony export */   buildDataQualityReport: function() { return /* binding */ buildDataQualityReport; },\n/* harmony export */   buildDayKwSeries: function() { return /* binding */ buildDayKwSeries; },\n/* harmony export */   buildDayProfile: function() { return /* binding */ buildDayProfile; },\n/* harmony export */   computeSizing: function() { return /* binding */ computeSizing; },\n/* harmony export */   findMaxObserved: function() { return /* binding */ findMaxObserved; },\n/* harmony export */   groupPeakEvents: function() { return /* binding */ groupPeakEvents; },\n/* harmony export */   processIntervals: function() { return /* binding */ processIntervals; },\n/* harmony export */   selectMinimumCostBatteryOptions: function() { return /* binding */ selectMinimumCostBatteryOptions; },\n/* harmony export */   selectTopExceededIntervals: function() { return /* binding */ selectTopExceededIntervals; }\n/* harmony export */ });\n/* harmony import */ var _datetime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime */ \"(app-pages-browser)/./lib/datetime.ts\");\n\nconst BATTERY_OPTIONS = [\n    {\n        label: \"WattsNext ESS Cabinet 64 kWh\",\n        capacityKwh: 64,\n        modular: true,\n        unitPriceEur: 15689.33\n    },\n    {\n        label: \"WattsNext ESS Cabinet 96 kWh\",\n        capacityKwh: 96,\n        modular: true,\n        unitPriceEur: 22225.98\n    },\n    {\n        label: \"ESS All-in-one Cabinet 261 kWh\",\n        capacityKwh: 261,\n        modular: true,\n        unitPriceEur: 43995.96\n    },\n    {\n        label: \"WattsNext All-in-one Container 2.09 MWh\",\n        capacityKwh: 2090,\n        modular: false,\n        unitPriceEur: 318658.06\n    },\n    {\n        label: \"WattsNext All in-one Container 5.015 MWh\",\n        capacityKwh: 5015,\n        modular: false,\n        unitPriceEur: 675052.49\n    }\n];\nfunction roundCurrency(value) {\n    return Math.round(value * 100) / 100;\n}\nfunction toBatteryProduct(candidate) {\n    const totalPriceEur = roundCurrency(candidate.totalPriceEur);\n    return {\n        label: candidate.label,\n        capacityKwh: candidate.totalCapacityKwh,\n        unitCapacityKwh: candidate.unitCapacityKwh,\n        count: candidate.count,\n        unitPriceEur: roundCurrency(candidate.unitPriceEur),\n        totalPriceEur,\n        breakdown: [\n            {\n                type: \"\".concat(candidate.unitCapacityKwh, \" kWh\"),\n                count: candidate.count,\n                unitCapacityKwh: candidate.unitCapacityKwh,\n                unitPriceEur: roundCurrency(candidate.unitPriceEur),\n                totalPriceEur\n            }\n        ]\n    };\n}\nfunction selectMinimumCostBatteryOptions(requiredKwh) {\n    const normalizedRequired = Math.max(0, requiredKwh);\n    const candidates = [];\n    BATTERY_OPTIONS.forEach((option)=>{\n        var _option_unitPriceEur;\n        const unitPriceEur = (_option_unitPriceEur = option.unitPriceEur) !== null && _option_unitPriceEur !== void 0 ? _option_unitPriceEur : 0;\n        if (option.modular) {\n            const maxCount = Math.max(1, Math.ceil(normalizedRequired / option.capacityKwh));\n            for(let count = 1; count <= maxCount; count += 1){\n                const totalCapacityKwh = count * option.capacityKwh;\n                if (totalCapacityKwh < normalizedRequired) continue;\n                const totalPriceEur = count * unitPriceEur;\n                candidates.push({\n                    label: \"\".concat(count, \"x \").concat(option.capacityKwh, \" kWh (modulair)\"),\n                    totalCapacityKwh,\n                    totalPriceEur,\n                    overCapacityKwh: totalCapacityKwh - normalizedRequired,\n                    count,\n                    unitCapacityKwh: option.capacityKwh,\n                    unitPriceEur\n                });\n            }\n            return;\n        }\n        if (option.capacityKwh >= normalizedRequired) {\n            candidates.push({\n                label: option.label,\n                totalCapacityKwh: option.capacityKwh,\n                totalPriceEur: unitPriceEur,\n                overCapacityKwh: option.capacityKwh - normalizedRequired,\n                count: 1,\n                unitCapacityKwh: option.capacityKwh,\n                unitPriceEur\n            });\n        }\n    });\n    const sorted = candidates.sort((a, b)=>a.totalPriceEur - b.totalPriceEur || a.overCapacityKwh - b.overCapacityKwh || a.totalCapacityKwh - b.totalCapacityKwh);\n    const recommendedProduct = toBatteryProduct(sorted[0]);\n    const alternativeProduct = sorted[1] ? toBatteryProduct(sorted[1]) : null;\n    return {\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction processIntervals(rows, contractedPowerKw) {\n    return rows.map((row)=>{\n        const timestamp = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(row.timestamp);\n        const normalizedTimestamp = Number.isNaN(timestamp.getTime()) ? row.timestamp : timestamp.toISOString();\n        const consumptionKw = row.consumptionKwh / 0.25;\n        const excessKw = Math.max(0, consumptionKw - contractedPowerKw);\n        return {\n            ...row,\n            timestamp: normalizedTimestamp,\n            consumptionKw,\n            excessKw,\n            excessKwh: excessKw * 0.25\n        };\n    });\n}\nfunction groupPeakEvents(intervals) {\n    const events = [];\n    let current = null;\n    intervals.forEach((interval, index)=>{\n        if (interval.excessKw > 0) {\n            if (!current) {\n                current = {\n                    peakTimestamp: interval.timestamp,\n                    durationIntervals: 0,\n                    maxExcessKw: 0,\n                    totalExcessKwh: 0,\n                    intervalIndexes: []\n                };\n            }\n            current.durationIntervals += 1;\n            if (interval.excessKw > current.maxExcessKw || interval.excessKw === current.maxExcessKw && interval.timestamp < current.peakTimestamp) {\n                current.maxExcessKw = interval.excessKw;\n                current.peakTimestamp = interval.timestamp;\n            }\n            current.totalExcessKwh += interval.excessKwh;\n            current.intervalIndexes.push(index);\n        } else if (current) {\n            events.push(current);\n            current = null;\n        }\n    });\n    if (current) {\n        events.push(current);\n    }\n    return events;\n}\nfunction percentile(values, p) {\n    if (values.length === 0) return 0;\n    const sorted = [\n        ...values\n    ].sort((a, b)=>a - b);\n    const idx = Math.ceil(p / 100 * sorted.length) - 1;\n    return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\n}\nfunction computeSizing(params) {\n    const { intervals, events, method, compliance, safetyFactor, efficiency } = params;\n    let kWhNeededRaw = 0;\n    let kWNeededRaw = 0;\n    if (method === \"MAX_PEAK\") {\n        const highestEnergyEvent = [\n            ...events\n        ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n        if (highestEnergyEvent) {\n            kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n            kWNeededRaw = highestEnergyEvent.maxExcessKw;\n        }\n    }\n    if (method === \"P95\") {\n        if (events.length < 20) {\n            const highestEnergyEvent = [\n                ...events\n            ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n            if (highestEnergyEvent) {\n                kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n                kWNeededRaw = highestEnergyEvent.maxExcessKw;\n            }\n        } else {\n            kWhNeededRaw = percentile(events.map((event)=>event.totalExcessKwh), 95);\n            kWNeededRaw = percentile(events.map((event)=>event.maxExcessKw), 95);\n        }\n    }\n    if (method === \"FULL_COVERAGE\") {\n        const byDay = new Map();\n        intervals.forEach((interval)=>{\n            const day = interval.timestamp.slice(0, 10);\n            var _byDay_get;\n            const list = (_byDay_get = byDay.get(day)) !== null && _byDay_get !== void 0 ? _byDay_get : [];\n            list.push(interval);\n            byDay.set(day, list);\n        });\n        let maxDayEnergy = 0;\n        let maxDayPeak = 0;\n        byDay.forEach((dayIntervals)=>{\n            const dayEnergy = dayIntervals.reduce((sum, interval)=>sum + interval.excessKwh, 0);\n            if (dayEnergy > maxDayEnergy) {\n                maxDayEnergy = dayEnergy;\n                maxDayPeak = Math.max(...dayIntervals.map((interval)=>interval.excessKw));\n            }\n        });\n        kWhNeededRaw = maxDayEnergy;\n        kWNeededRaw = maxDayPeak;\n    }\n    kWhNeededRaw *= compliance;\n    kWNeededRaw *= compliance;\n    const kWhNeeded = kWhNeededRaw / efficiency * safetyFactor;\n    const kWNeeded = kWNeededRaw * safetyFactor;\n    const { recommendedProduct, alternativeProduct } = selectMinimumCostBatteryOptions(kWhNeeded);\n    return {\n        kWhNeededRaw,\n        kWNeededRaw,\n        kWhNeeded,\n        kWNeeded,\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction buildDataQualityReport(intervals) {\n    var _timestamps_, _timestamps_1;\n    if (intervals.length === 0) {\n        return {\n            rows: 0,\n            startDate: null,\n            endDate: null,\n            missingIntervalsCount: 0,\n            duplicateCount: 0,\n            non15MinIntervals: 0,\n            warnings: [\n                \"No rows found in dataset.\"\n            ]\n        };\n    }\n    const timestamps = intervals.map((row)=>new Date(row.timestamp)).filter((date)=>!Number.isNaN(date.getTime())).sort((a, b)=>a.getTime() - b.getTime());\n    const duplicateCount = timestamps.length - new Set(timestamps.map((d)=>d.toISOString())).size;\n    let non15MinIntervals = 0;\n    let missingIntervalsCount = 0;\n    for(let i = 1; i < timestamps.length; i += 1){\n        const diffMinutes = (timestamps[i].getTime() - timestamps[i - 1].getTime()) / 60000;\n        if (diffMinutes !== 15) {\n            non15MinIntervals += 1;\n            if (diffMinutes > 15) {\n                missingIntervalsCount += Math.max(0, Math.round(diffMinutes / 15) - 1);\n            }\n        }\n    }\n    const warnings = [];\n    if (duplicateCount > 0) warnings.push(\"Detected \".concat(duplicateCount, \" duplicate timestamps.\"));\n    if (non15MinIntervals > 0) {\n        warnings.push(\"Detected \".concat(non15MinIntervals, \" non-15-minute interval transitions.\"));\n    }\n    var _timestamps__toISOString, _timestamps__toISOString1;\n    return {\n        rows: intervals.length,\n        startDate: (_timestamps__toISOString = (_timestamps_ = timestamps[0]) === null || _timestamps_ === void 0 ? void 0 : _timestamps_.toISOString()) !== null && _timestamps__toISOString !== void 0 ? _timestamps__toISOString : null,\n        endDate: (_timestamps__toISOString1 = (_timestamps_1 = timestamps[timestamps.length - 1]) === null || _timestamps_1 === void 0 ? void 0 : _timestamps_1.toISOString()) !== null && _timestamps__toISOString1 !== void 0 ? _timestamps__toISOString1 : null,\n        missingIntervalsCount,\n        duplicateCount,\n        non15MinIntervals,\n        warnings\n    };\n}\nfunction findMaxObserved(intervals) {\n    if (intervals.length === 0) {\n        return {\n            maxObservedKw: 0,\n            maxObservedTimestamp: null\n        };\n    }\n    let maxObservedKw = -1;\n    let maxObservedTimestamp = null;\n    intervals.forEach((interval)=>{\n        if (interval.consumptionKw > maxObservedKw || interval.consumptionKw === maxObservedKw && maxObservedTimestamp !== null && interval.timestamp < maxObservedTimestamp) {\n            maxObservedKw = interval.consumptionKw;\n            maxObservedTimestamp = interval.timestamp;\n        }\n    });\n    return {\n        maxObservedKw,\n        maxObservedTimestamp\n    };\n}\nfunction selectTopExceededIntervals(intervals, day) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;\n    return intervals.filter((interval)=>(0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp) === day && interval.excessKw > 0).sort((a, b)=>b.excessKw - a.excessKw || a.timestamp.localeCompare(b.timestamp)).slice(0, limit).map((interval)=>({\n            timestamp: interval.timestamp,\n            consumption_kW: interval.consumptionKw,\n            excess_kW: interval.excessKw\n        }));\n}\nfunction buildDayProfile(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    const fullDaySeries = buildDayKwSeries(intervals.map((interval)=>({\n            timestamp: interval.timestamp,\n            consumptionKw: interval.consumptionKw\n        })), dayIso, intervalMinutes, timeZone);\n    return fullDaySeries.map((slot)=>({\n            timestampLabel: slot.timeLabel,\n            timestampIso: slot.timestampIso,\n            observedKw: slot.consumptionKw\n        }));\n}\nfunction buildDayKwSeries(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    if (!dayIso || intervalMinutes <= 0) return [];\n    const [year, month, day] = dayIso.split(\"-\").map(Number);\n    const dayStartLocal = new Date(year, month - 1, day, 0, 0, 0, 0);\n    if (Number.isNaN(dayStartLocal.getTime())) return [];\n    const slotsPerDay = Math.floor(24 * 60 / intervalMinutes);\n    const profile = Array.from({\n        length: slotsPerDay\n    }, (_, index)=>{\n        const minutes = index * intervalMinutes;\n        const hour = Math.floor(minutes / 60);\n        const minute = minutes % 60;\n        return {\n            timeLabel: \"\".concat(String(hour).padStart(2, \"0\"), \":\").concat(String(minute).padStart(2, \"0\")),\n            timestampIso: new Date(dayStartLocal.getTime() + minutes * 60000).toISOString(),\n            consumptionKw: 0\n        };\n    });\n    intervals.forEach((interval)=>{\n        if ((0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp, timeZone) !== dayIso) return;\n        const dt = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(interval.timestamp);\n        if (Number.isNaN(dt.getTime())) return;\n        const { hour, minute } = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalHourMinute)(dt, timeZone);\n        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return;\n        const minuteOfDay = hour * 60 + minute;\n        const slotIndex = Math.floor(minuteOfDay / intervalMinutes);\n        if (slotIndex < 0 || slotIndex >= slotsPerDay) return;\n        profile[slotIndex].consumptionKw = Math.max(profile[slotIndex].consumptionKw, interval.consumptionKw);\n    });\n    return profile;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jYWxjdWxhdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Y7QUFpRnpFLE1BQU1HLGtCQUFvQztJQUMvQztRQUNFQyxPQUFPO1FBQ1BDLGFBQWE7UUFDYkMsU0FBUztRQUNUQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsY0FBYztJQUNoQjtJQUNBO1FBQ0VILE9BQU87UUFDUEMsYUFBYTtRQUNiQyxTQUFTO1FBQ1RDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxPQUFPO1FBQ1BDLGFBQWE7UUFDYkMsU0FBUztRQUNUQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsY0FBYztJQUNoQjtDQUNELENBQUM7QUFZRixTQUFTQyxjQUFjQyxLQUFhO0lBQ2xDLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0YsUUFBUSxPQUFPO0FBQ25DO0FBRUEsU0FBU0csaUJBQWlCQyxTQUF3QztJQUNoRSxNQUFNQyxnQkFBZ0JOLGNBQWNLLFVBQVVDLGFBQWE7SUFDM0QsT0FBTztRQUNMVixPQUFPUyxVQUFVVCxLQUFLO1FBQ3RCQyxhQUFhUSxVQUFVRSxnQkFBZ0I7UUFDdkNDLGlCQUFpQkgsVUFBVUcsZUFBZTtRQUMxQ0MsT0FBT0osVUFBVUksS0FBSztRQUN0QlYsY0FBY0MsY0FBY0ssVUFBVU4sWUFBWTtRQUNsRE87UUFDQUksV0FBVztZQUNUO2dCQUNFQyxNQUFNLEdBQTZCLE9BQTFCTixVQUFVRyxlQUFlLEVBQUM7Z0JBQ25DQyxPQUFPSixVQUFVSSxLQUFLO2dCQUN0QkQsaUJBQWlCSCxVQUFVRyxlQUFlO2dCQUMxQ1QsY0FBY0MsY0FBY0ssVUFBVU4sWUFBWTtnQkFDbERPO1lBQ0Y7U0FDRDtJQUNIO0FBQ0Y7QUFFTyxTQUFTTSxnQ0FBZ0NDLFdBQW1CO0lBSWpFLE1BQU1DLHFCQUFxQlosS0FBS2EsR0FB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VTVCLE9BQU8sQ0FBQyxDQUFDK0I7UUFDakIsSUFBSXhELHlEQUFjQSxDQUFDd0QsU0FBU2QsU0FBUyxFQUFFK0UsY0FBY0YsUUFBUTtRQUU3RCxNQUFNeUIsS0FBSzlJLHlEQUFjQSxDQUFDc0QsU0FBU2QsU0FBUztRQUM1QyxJQUFJRSxPQUFPQyxLQUFLLENBQUNtRyxHQUFHbEcsT0FBTyxLQUFLO1FBQ2hDLE1BQU0sRUFBRThGLElBQUksRUFBRUMsTUFBTSxFQUFFLEdBQUc1SSw2REFBa0JBLENBQUMrSSxJQUFJdkI7UUFDaEQsSUFBSSxDQUFDN0UsT0FBT3FHLFFBQVEsQ0FBQ0wsU0FBUyxDQUFDaEcsT0FBT3FHLFFBQVEsQ0FBQ0osU0FBUztRQUV4RCxNQUFNSyxjQUFjTixPQUFPLEtBQUtDO1FBQ2hDLE1BQU1NLFlBQVl6SSxLQUFLNEgsS0FBSyxDQUFDWSxjQUFjMUI7UUFDM0MsSUFBSTJCLFlBQVksS0FBS0EsYUFBYWQsYUFBYTtRQUUvQ0UsT0FBTyxDQUFDWSxVQUFVLENBQUNuRyxhQUFhLEdBQUd0QyxLQUFLYSxHQUFHLENBQUNnSCxPQUFPLENBQUNZLFVBQVUsQ0FBQ25HLGFBQWEsRUFBRVEsU0FBU1IsYUFBYTtJQUN0RztJQUVBLE9BQU91RjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jYWxjdWxhdGlvbnMudHM/M2Y3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMb2NhbERheUlzbywgZ2V0TG9jYWxIb3VyTWludXRlLCBwYXJzZVRpbWVzdGFtcCB9IGZyb20gJy4vZGF0ZXRpbWUnO1xuXG5leHBvcnQgdHlwZSBNZXRob2QgPSAnTUFYX1BFQUsnIHwgJ1A5NScgfCAnRlVMTF9DT1ZFUkFHRSc7XG5cclxuZXhwb3J0IGludGVyZmFjZSBJbnRlcnZhbFJlY29yZCB7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgY29uc3VtcHRpb25Ld2g6IG51bWJlcjtcclxuICBleHBvcnRLd2g/OiBudW1iZXI7XHJcbiAgcHZLd2g/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2VkSW50ZXJ2YWwgZXh0ZW5kcyBJbnRlcnZhbFJlY29yZCB7XHJcbiAgY29uc3VtcHRpb25LdzogbnVtYmVyO1xyXG4gIGV4Y2Vzc0t3OiBudW1iZXI7XHJcbiAgZXhjZXNzS3doOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGVha0V2ZW50IHtcbiAgcGVha1RpbWVzdGFtcDogc3RyaW5nO1xuICBkdXJhdGlvbkludGVydmFsczogbnVtYmVyO1xuICBtYXhFeGNlc3NLdzogbnVtYmVyO1xuICB0b3RhbEV4Y2Vzc0t3aDogbnVtYmVyO1xuICBpbnRlcnZhbEluZGV4ZXM6IG51bWJlcltdO1xufVxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVF1YWxpdHlSZXBvcnQge1xyXG4gIHJvd3M6IG51bWJlcjtcclxuICBzdGFydERhdGU6IHN0cmluZyB8IG51bGw7XHJcbiAgZW5kRGF0ZTogc3RyaW5nIHwgbnVsbDtcclxuICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQ6IG51bWJlcjtcclxuICBkdXBsaWNhdGVDb3VudDogbnVtYmVyO1xyXG4gIG5vbjE1TWluSW50ZXJ2YWxzOiBudW1iZXI7XHJcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNpemluZ1Jlc3VsdCB7XHJcbiAga1doTmVlZGVkUmF3OiBudW1iZXI7XHJcbiAga1dOZWVkZWRSYXc6IG51bWJlcjtcclxuICBrV2hOZWVkZWQ6IG51bWJlcjtcclxuICBrV05lZWRlZDogbnVtYmVyO1xyXG4gIHJlY29tbWVuZGVkUHJvZHVjdDogQmF0dGVyeVByb2R1Y3Q7XHJcbiAgYWx0ZXJuYXRpdmVQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdCB8IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmF0dGVyeVByb2R1Y3Qge1xuICBsYWJlbDogc3RyaW5nO1xuICBjYXBhY2l0eUt3aDogbnVtYmVyO1xuICBtb2R1bGFyPzogYm9vbGVhbjtcbiAgdW5pdFByaWNlRXVyPzogbnVtYmVyO1xuICB1bml0Q2FwYWNpdHlLd2g/OiBudW1iZXI7XG4gIGNvdW50PzogbnVtYmVyO1xuICB0b3RhbFByaWNlRXVyPzogbnVtYmVyO1xuICBicmVha2Rvd24/OiBCYXR0ZXJ5QnJlYWtkb3duW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0dGVyeUJyZWFrZG93biB7XG4gIHR5cGU6IHN0cmluZztcbiAgY291bnQ6IG51bWJlcjtcbiAgdW5pdENhcGFjaXR5S3doOiBudW1iZXI7XG4gIHVuaXRQcmljZUV1cjogbnVtYmVyO1xuICB0b3RhbFByaWNlRXVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhjZWVkZWRJbnRlcnZhbCB7XG4gIHRpbWVzdGFtcDogc3RyaW5nO1xuICBjb25zdW1wdGlvbl9rVzogbnVtYmVyO1xuICBleGNlc3Nfa1c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXlQcm9maWxlUG9pbnQge1xuICB0aW1lc3RhbXBMYWJlbDogc3RyaW5nO1xuICB0aW1lc3RhbXBJc286IHN0cmluZztcbiAgb2JzZXJ2ZWRLdzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERheUt3U2VyaWVzUG9pbnQge1xuICB0aW1lTGFiZWw6IHN0cmluZztcbiAgdGltZXN0YW1wSXNvOiBzdHJpbmc7XG4gIGNvbnN1bXB0aW9uS3c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IEJBVFRFUllfT1BUSU9OUzogQmF0dGVyeVByb2R1Y3RbXSA9IFtcbiAge1xuICAgIGxhYmVsOiAnV2F0dHNOZXh0IEVTUyBDYWJpbmV0IDY0IGtXaCcsXG4gICAgY2FwYWNpdHlLd2g6IDY0LFxuICAgIG1vZHVsYXI6IHRydWUsXG4gICAgdW5pdFByaWNlRXVyOiAxNTY4OS4zM1xuICB9LFxuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgRVNTIENhYmluZXQgOTYga1doJyxcbiAgICBjYXBhY2l0eUt3aDogOTYsXG4gICAgbW9kdWxhcjogdHJ1ZSxcbiAgICB1bml0UHJpY2VFdXI6IDIyMjI1Ljk4XG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ0VTUyBBbGwtaW4tb25lIENhYmluZXQgMjYxIGtXaCcsXG4gICAgY2FwYWNpdHlLd2g6IDI2MSxcbiAgICBtb2R1bGFyOiB0cnVlLFxuICAgIHVuaXRQcmljZUV1cjogNDM5OTUuOTZcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnV2F0dHNOZXh0IEFsbC1pbi1vbmUgQ29udGFpbmVyIDIuMDkgTVdoJyxcbiAgICBjYXBhY2l0eUt3aDogMjA5MCxcbiAgICBtb2R1bGFyOiBmYWxzZSxcbiAgICB1bml0UHJpY2VFdXI6IDMxODY1OC4wNlxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgQWxsIGluLW9uZSBDb250YWluZXIgNS4wMTUgTVdoJyxcbiAgICBjYXBhY2l0eUt3aDogNTAxNSxcbiAgICBtb2R1bGFyOiBmYWxzZSxcbiAgICB1bml0UHJpY2VFdXI6IDY3NTA1Mi40OVxuICB9XG5dO1xuXG5pbnRlcmZhY2UgQmF0dGVyeUNvbmZpZ3VyYXRpb25DYW5kaWRhdGUge1xuICBsYWJlbDogc3RyaW5nO1xuICB0b3RhbENhcGFjaXR5S3doOiBudW1iZXI7XG4gIHRvdGFsUHJpY2VFdXI6IG51bWJlcjtcbiAgb3ZlckNhcGFjaXR5S3doOiBudW1iZXI7XG4gIGNvdW50OiBudW1iZXI7XG4gIHVuaXRDYXBhY2l0eUt3aDogbnVtYmVyO1xuICB1bml0UHJpY2VFdXI6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gcm91bmRDdXJyZW5jeSh2YWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDApIC8gMTAwO1xufVxuXG5mdW5jdGlvbiB0b0JhdHRlcnlQcm9kdWN0KGNhbmRpZGF0ZTogQmF0dGVyeUNvbmZpZ3VyYXRpb25DYW5kaWRhdGUpOiBCYXR0ZXJ5UHJvZHVjdCB7XG4gIGNvbnN0IHRvdGFsUHJpY2VFdXIgPSByb3VuZEN1cnJlbmN5KGNhbmRpZGF0ZS50b3RhbFByaWNlRXVyKTtcbiAgcmV0dXJuIHtcbiAgICBsYWJlbDogY2FuZGlkYXRlLmxhYmVsLFxuICAgIGNhcGFjaXR5S3doOiBjYW5kaWRhdGUudG90YWxDYXBhY2l0eUt3aCxcbiAgICB1bml0Q2FwYWNpdHlLd2g6IGNhbmRpZGF0ZS51bml0Q2FwYWNpdHlLd2gsXG4gICAgY291bnQ6IGNhbmRpZGF0ZS5jb3VudCxcbiAgICB1bml0UHJpY2VFdXI6IHJvdW5kQ3VycmVuY3koY2FuZGlkYXRlLnVuaXRQcmljZUV1ciksXG4gICAgdG90YWxQcmljZUV1cixcbiAgICBicmVha2Rvd246IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogYCR7Y2FuZGlkYXRlLnVuaXRDYXBhY2l0eUt3aH0ga1doYCxcbiAgICAgICAgY291bnQ6IGNhbmRpZGF0ZS5jb3VudCxcbiAgICAgICAgdW5pdENhcGFjaXR5S3doOiBjYW5kaWRhdGUudW5pdENhcGFjaXR5S3doLFxuICAgICAgICB1bml0UHJpY2VFdXI6IHJvdW5kQ3VycmVuY3koY2FuZGlkYXRlLnVuaXRQcmljZUV1ciksXG4gICAgICAgIHRvdGFsUHJpY2VFdXJcbiAgICAgIH1cbiAgICBdXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RNaW5pbXVtQ29zdEJhdHRlcnlPcHRpb25zKHJlcXVpcmVkS3doOiBudW1iZXIpOiB7XG4gIHJlY29tbWVuZGVkUHJvZHVjdDogQmF0dGVyeVByb2R1Y3Q7XG4gIGFsdGVybmF0aXZlUHJvZHVjdDogQmF0dGVyeVByb2R1Y3QgfCBudWxsO1xufSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRSZXF1aXJlZCA9IE1hdGgubWF4KDAsIHJlcXVpcmVkS3doKTtcbiAgY29uc3QgY2FuZGlkYXRlczogQmF0dGVyeUNvbmZpZ3VyYXRpb25DYW5kaWRhdGVbXSA9IFtdO1xuXG4gIEJBVFRFUllfT1BUSU9OUy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICBjb25zdCB1bml0UHJpY2VFdXIgPSBvcHRpb24udW5pdFByaWNlRXVyID8/IDA7XG4gICAgaWYgKG9wdGlvbi5tb2R1bGFyKSB7XG4gICAgICBjb25zdCBtYXhDb3VudCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChub3JtYWxpemVkUmVxdWlyZWQgLyBvcHRpb24uY2FwYWNpdHlLd2gpKTtcbiAgICAgIGZvciAobGV0IGNvdW50ID0gMTsgY291bnQgPD0gbWF4Q291bnQ7IGNvdW50ICs9IDEpIHtcbiAgICAgICAgY29uc3QgdG90YWxDYXBhY2l0eUt3aCA9IGNvdW50ICogb3B0aW9uLmNhcGFjaXR5S3doO1xuICAgICAgICBpZiAodG90YWxDYXBhY2l0eUt3aCA8IG5vcm1hbGl6ZWRSZXF1aXJlZCkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHRvdGFsUHJpY2VFdXIgPSBjb3VudCAqIHVuaXRQcmljZUV1cjtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBsYWJlbDogYCR7Y291bnR9eCAke29wdGlvbi5jYXBhY2l0eUt3aH0ga1doIChtb2R1bGFpcilgLFxuICAgICAgICAgIHRvdGFsQ2FwYWNpdHlLd2gsXG4gICAgICAgICAgdG90YWxQcmljZUV1cixcbiAgICAgICAgICBvdmVyQ2FwYWNpdHlLd2g6IHRvdGFsQ2FwYWNpdHlLd2ggLSBub3JtYWxpemVkUmVxdWlyZWQsXG4gICAgICAgICAgY291bnQsXG4gICAgICAgICAgdW5pdENhcGFjaXR5S3doOiBvcHRpb24uY2FwYWNpdHlLd2gsXG4gICAgICAgICAgdW5pdFByaWNlRXVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb24uY2FwYWNpdHlLd2ggPj0gbm9ybWFsaXplZFJlcXVpcmVkKSB7XG4gICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICBsYWJlbDogb3B0aW9uLmxhYmVsLFxuICAgICAgICB0b3RhbENhcGFjaXR5S3doOiBvcHRpb24uY2FwYWNpdHlLd2gsXG4gICAgICAgIHRvdGFsUHJpY2VFdXI6IHVuaXRQcmljZUV1cixcbiAgICAgICAgb3ZlckNhcGFjaXR5S3doOiBvcHRpb24uY2FwYWNpdHlLd2ggLSBub3JtYWxpemVkUmVxdWlyZWQsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICB1bml0Q2FwYWNpdHlLd2g6IG9wdGlvbi5jYXBhY2l0eUt3aCxcbiAgICAgICAgdW5pdFByaWNlRXVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHNvcnRlZCA9IGNhbmRpZGF0ZXMuc29ydChcbiAgICAoYSwgYikgPT5cbiAgICAgIGEudG90YWxQcmljZUV1ciAtIGIudG90YWxQcmljZUV1ciB8fFxuICAgICAgYS5vdmVyQ2FwYWNpdHlLd2ggLSBiLm92ZXJDYXBhY2l0eUt3aCB8fFxuICAgICAgYS50b3RhbENhcGFjaXR5S3doIC0gYi50b3RhbENhcGFjaXR5S3doXG4gICk7XG5cbiAgY29uc3QgcmVjb21tZW5kZWRQcm9kdWN0ID0gdG9CYXR0ZXJ5UHJvZHVjdChzb3J0ZWRbMF0pO1xuICBjb25zdCBhbHRlcm5hdGl2ZVByb2R1Y3QgPSBzb3J0ZWRbMV0gPyB0b0JhdHRlcnlQcm9kdWN0KHNvcnRlZFsxXSkgOiBudWxsO1xuXG4gIHJldHVybiB7IHJlY29tbWVuZGVkUHJvZHVjdCwgYWx0ZXJuYXRpdmVQcm9kdWN0IH07XG59XG5cclxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NJbnRlcnZhbHMoXG4gIHJvd3M6IEludGVydmFsUmVjb3JkW10sXG4gIGNvbnRyYWN0ZWRQb3dlckt3OiBudW1iZXJcbik6IFByb2Nlc3NlZEludGVydmFsW10ge1xuICByZXR1cm4gcm93cy5tYXAoKHJvdykgPT4ge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlVGltZXN0YW1wKHJvdy50aW1lc3RhbXApO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lc3RhbXAgPSBOdW1iZXIuaXNOYU4odGltZXN0YW1wLmdldFRpbWUoKSkgPyByb3cudGltZXN0YW1wIDogdGltZXN0YW1wLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgY29uc3VtcHRpb25LdyA9IHJvdy5jb25zdW1wdGlvbkt3aCAvIDAuMjU7XG4gICAgY29uc3QgZXhjZXNzS3cgPSBNYXRoLm1heCgwLCBjb25zdW1wdGlvbkt3IC0gY29udHJhY3RlZFBvd2VyS3cpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yb3csXG4gICAgICB0aW1lc3RhbXA6IG5vcm1hbGl6ZWRUaW1lc3RhbXAsXG4gICAgICBjb25zdW1wdGlvbkt3LFxuICAgICAgZXhjZXNzS3csXG4gICAgICBleGNlc3NLd2g6IGV4Y2Vzc0t3ICogMC4yNVxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBncm91cFBlYWtFdmVudHMoaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdKTogUGVha0V2ZW50W10ge1xuICBjb25zdCBldmVudHM6IFBlYWtFdmVudFtdID0gW107XG4gIGxldCBjdXJyZW50OiBQZWFrRXZlbnQgfCBudWxsID0gbnVsbDtcblxuICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwsIGluZGV4KSA9PiB7XG4gICAgaWYgKGludGVydmFsLmV4Y2Vzc0t3ID4gMCkge1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgICAgcGVha1RpbWVzdGFtcDogaW50ZXJ2YWwudGltZXN0YW1wLFxuICAgICAgICAgIGR1cmF0aW9uSW50ZXJ2YWxzOiAwLFxuICAgICAgICAgIG1heEV4Y2Vzc0t3OiAwLFxuICAgICAgICAgIHRvdGFsRXhjZXNzS3doOiAwLFxuICAgICAgICAgIGludGVydmFsSW5kZXhlczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQuZHVyYXRpb25JbnRlcnZhbHMgKz0gMTtcbiAgICAgIGlmIChcbiAgICAgICAgaW50ZXJ2YWwuZXhjZXNzS3cgPiBjdXJyZW50Lm1heEV4Y2Vzc0t3IHx8XG4gICAgICAgIChpbnRlcnZhbC5leGNlc3NLdyA9PT0gY3VycmVudC5tYXhFeGNlc3NLdyAmJiBpbnRlcnZhbC50aW1lc3RhbXAgPCBjdXJyZW50LnBlYWtUaW1lc3RhbXApXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudC5tYXhFeGNlc3NLdyA9IGludGVydmFsLmV4Y2Vzc0t3O1xuICAgICAgICBjdXJyZW50LnBlYWtUaW1lc3RhbXAgPSBpbnRlcnZhbC50aW1lc3RhbXA7XG4gICAgICB9XG4gICAgICBjdXJyZW50LnRvdGFsRXhjZXNzS3doICs9IGludGVydmFsLmV4Y2Vzc0t3aDtcbiAgICAgIGN1cnJlbnQuaW50ZXJ2YWxJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudCkge1xuICAgICAgZXZlbnRzLnB1c2goY3VycmVudCk7XHJcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpZiAoY3VycmVudCkge1xyXG4gICAgZXZlbnRzLnB1c2goY3VycmVudCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXZlbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwZXJjZW50aWxlKHZhbHVlczogbnVtYmVyW10sIHA6IG51bWJlcik6IG51bWJlciB7XHJcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xyXG4gIGNvbnN0IHNvcnRlZCA9IFsuLi52YWx1ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICBjb25zdCBpZHggPSBNYXRoLmNlaWwoKHAgLyAxMDApICogc29ydGVkLmxlbmd0aCkgLSAxO1xyXG4gIHJldHVybiBzb3J0ZWRbTWF0aC5tYXgoMCwgTWF0aC5taW4oaWR4LCBzb3J0ZWQubGVuZ3RoIC0gMSkpXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTaXppbmcocGFyYW1zOiB7XHJcbiAgaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdO1xyXG4gIGV2ZW50czogUGVha0V2ZW50W107XHJcbiAgbWV0aG9kOiBNZXRob2Q7XHJcbiAgY29tcGxpYW5jZTogbnVtYmVyO1xyXG4gIHNhZmV0eUZhY3RvcjogbnVtYmVyO1xyXG4gIGVmZmljaWVuY3k6IG51bWJlcjtcclxufSk6IFNpemluZ1Jlc3VsdCB7XHJcbiAgY29uc3QgeyBpbnRlcnZhbHMsIGV2ZW50cywgbWV0aG9kLCBjb21wbGlhbmNlLCBzYWZldHlGYWN0b3IsIGVmZmljaWVuY3kgfSA9IHBhcmFtcztcclxuXHJcbiAgbGV0IGtXaE5lZWRlZFJhdyA9IDA7XHJcbiAgbGV0IGtXTmVlZGVkUmF3ID0gMDtcclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ01BWF9QRUFLJykge1xyXG4gICAgY29uc3QgaGlnaGVzdEVuZXJneUV2ZW50ID0gWy4uLmV2ZW50c10uc29ydChcclxuICAgICAgKGEsIGIpID0+IGIudG90YWxFeGNlc3NLd2ggLSBhLnRvdGFsRXhjZXNzS3doXHJcbiAgICApWzBdO1xyXG4gICAgaWYgKGhpZ2hlc3RFbmVyZ3lFdmVudCkge1xyXG4gICAgICBrV2hOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQudG90YWxFeGNlc3NLd2g7XHJcbiAgICAgIGtXTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50Lm1heEV4Y2Vzc0t3O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ1A5NScpIHtcclxuICAgIGlmIChldmVudHMubGVuZ3RoIDwgMjApIHtcclxuICAgICAgY29uc3QgaGlnaGVzdEVuZXJneUV2ZW50ID0gWy4uLmV2ZW50c10uc29ydChcclxuICAgICAgICAoYSwgYikgPT4gYi50b3RhbEV4Y2Vzc0t3aCAtIGEudG90YWxFeGNlc3NLd2hcclxuICAgICAgKVswXTtcclxuICAgICAgaWYgKGhpZ2hlc3RFbmVyZ3lFdmVudCkge1xyXG4gICAgICAgIGtXaE5lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC50b3RhbEV4Y2Vzc0t3aDtcclxuICAgICAgICBrV05lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC5tYXhFeGNlc3NLdztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAga1doTmVlZGVkUmF3ID0gcGVyY2VudGlsZShcclxuICAgICAgICBldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQudG90YWxFeGNlc3NLd2gpLFxyXG4gICAgICAgIDk1XHJcbiAgICAgICk7XHJcbiAgICAgIGtXTmVlZGVkUmF3ID0gcGVyY2VudGlsZShcclxuICAgICAgICBldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQubWF4RXhjZXNzS3cpLFxyXG4gICAgICAgIDk1XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAobWV0aG9kID09PSAnRlVMTF9DT1ZFUkFHRScpIHtcclxuICAgIGNvbnN0IGJ5RGF5ID0gbmV3IE1hcDxzdHJpbmcsIFByb2Nlc3NlZEludGVydmFsW10+KCk7XHJcbiAgICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcclxuICAgICAgY29uc3QgZGF5ID0gaW50ZXJ2YWwudGltZXN0YW1wLnNsaWNlKDAsIDEwKTtcclxuICAgICAgY29uc3QgbGlzdCA9IGJ5RGF5LmdldChkYXkpID8/IFtdO1xyXG4gICAgICBsaXN0LnB1c2goaW50ZXJ2YWwpO1xyXG4gICAgICBieURheS5zZXQoZGF5LCBsaXN0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBtYXhEYXlFbmVyZ3kgPSAwO1xyXG4gICAgbGV0IG1heERheVBlYWsgPSAwO1xyXG5cclxuICAgIGJ5RGF5LmZvckVhY2goKGRheUludGVydmFscykgPT4ge1xyXG4gICAgICBjb25zdCBkYXlFbmVyZ3kgPSBkYXlJbnRlcnZhbHMucmVkdWNlKChzdW0sIGludGVydmFsKSA9PiBzdW0gKyBpbnRlcnZhbC5leGNlc3NLd2gsIDApO1xyXG4gICAgICBpZiAoZGF5RW5lcmd5ID4gbWF4RGF5RW5lcmd5KSB7XHJcbiAgICAgICAgbWF4RGF5RW5lcmd5ID0gZGF5RW5lcmd5O1xyXG4gICAgICAgIG1heERheVBlYWsgPSBNYXRoLm1heCguLi5kYXlJbnRlcnZhbHMubWFwKChpbnRlcnZhbCkgPT4gaW50ZXJ2YWwuZXhjZXNzS3cpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAga1doTmVlZGVkUmF3ID0gbWF4RGF5RW5lcmd5O1xyXG4gICAga1dOZWVkZWRSYXcgPSBtYXhEYXlQZWFrO1xyXG4gIH1cclxuXHJcbiAga1doTmVlZGVkUmF3ICo9IGNvbXBsaWFuY2U7XHJcbiAga1dOZWVkZWRSYXcgKj0gY29tcGxpYW5jZTtcclxuXHJcbiAgY29uc3Qga1doTmVlZGVkID0gKGtXaE5lZWRlZFJhdyAvIGVmZmljaWVuY3kpICogc2FmZXR5RmFjdG9yO1xyXG4gIGNvbnN0IGtXTmVlZGVkID0ga1dOZWVkZWRSYXcgKiBzYWZldHlGYWN0b3I7XHJcblxyXG4gIGNvbnN0IHsgcmVjb21tZW5kZWRQcm9kdWN0LCBhbHRlcm5hdGl2ZVByb2R1Y3QgfSA9IHNlbGVjdE1pbmltdW1Db3N0QmF0dGVyeU9wdGlvbnMoa1doTmVlZGVkKTtcblxyXG4gIHJldHVybiB7XHJcbiAgICBrV2hOZWVkZWRSYXcsXHJcbiAgICBrV05lZWRlZFJhdyxcclxuICAgIGtXaE5lZWRlZCxcclxuICAgIGtXTmVlZGVkLFxyXG4gICAgcmVjb21tZW5kZWRQcm9kdWN0LFxyXG4gICAgYWx0ZXJuYXRpdmVQcm9kdWN0XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGF0YVF1YWxpdHlSZXBvcnQoaW50ZXJ2YWxzOiBJbnRlcnZhbFJlY29yZFtdKTogRGF0YVF1YWxpdHlSZXBvcnQge1xuICBpZiAoaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcm93czogMCxcclxuICAgICAgc3RhcnREYXRlOiBudWxsLFxyXG4gICAgICBlbmREYXRlOiBudWxsLFxyXG4gICAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQ6IDAsXHJcbiAgICAgIGR1cGxpY2F0ZUNvdW50OiAwLFxyXG4gICAgICBub24xNU1pbkludGVydmFsczogMCxcclxuICAgICAgd2FybmluZ3M6IFsnTm8gcm93cyBmb3VuZCBpbiBkYXRhc2V0LiddXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdGltZXN0YW1wcyA9IGludGVydmFsc1xyXG4gICAgLm1hcCgocm93KSA9PiBuZXcgRGF0ZShyb3cudGltZXN0YW1wKSlcclxuICAgIC5maWx0ZXIoKGRhdGUpID0+ICFOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKVxyXG4gICAgLnNvcnQoKGEsIGIpID0+IGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCkpO1xyXG5cclxuICBjb25zdCBkdXBsaWNhdGVDb3VudCA9IHRpbWVzdGFtcHMubGVuZ3RoIC0gbmV3IFNldCh0aW1lc3RhbXBzLm1hcCgoZCkgPT4gZC50b0lTT1N0cmluZygpKSkuc2l6ZTtcclxuICBsZXQgbm9uMTVNaW5JbnRlcnZhbHMgPSAwO1xyXG4gIGxldCBtaXNzaW5nSW50ZXJ2YWxzQ291bnQgPSAwO1xyXG5cclxuICBmb3IgKGxldCBpID0gMTsgaSA8IHRpbWVzdGFtcHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgIGNvbnN0IGRpZmZNaW51dGVzID0gKHRpbWVzdGFtcHNbaV0uZ2V0VGltZSgpIC0gdGltZXN0YW1wc1tpIC0gMV0uZ2V0VGltZSgpKSAvIDYwMDAwO1xyXG4gICAgaWYgKGRpZmZNaW51dGVzICE9PSAxNSkge1xyXG4gICAgICBub24xNU1pbkludGVydmFscyArPSAxO1xyXG4gICAgICBpZiAoZGlmZk1pbnV0ZXMgPiAxNSkge1xyXG4gICAgICAgIG1pc3NpbmdJbnRlcnZhbHNDb3VudCArPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKGRpZmZNaW51dGVzIC8gMTUpIC0gMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGlmIChkdXBsaWNhdGVDb3VudCA+IDApIHdhcm5pbmdzLnB1c2goYERldGVjdGVkICR7ZHVwbGljYXRlQ291bnR9IGR1cGxpY2F0ZSB0aW1lc3RhbXBzLmApO1xyXG4gIGlmIChub24xNU1pbkludGVydmFscyA+IDApIHtcclxuICAgIHdhcm5pbmdzLnB1c2goYERldGVjdGVkICR7bm9uMTVNaW5JbnRlcnZhbHN9IG5vbi0xNS1taW51dGUgaW50ZXJ2YWwgdHJhbnNpdGlvbnMuYCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcm93czogaW50ZXJ2YWxzLmxlbmd0aCxcclxuICAgIHN0YXJ0RGF0ZTogdGltZXN0YW1wc1swXT8udG9JU09TdHJpbmcoKSA/PyBudWxsLFxyXG4gICAgZW5kRGF0ZTogdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdPy50b0lTT1N0cmluZygpID8/IG51bGwsXHJcbiAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQsXHJcbiAgICBkdXBsaWNhdGVDb3VudCxcclxuICAgIG5vbjE1TWluSW50ZXJ2YWxzLFxyXG4gICAgd2FybmluZ3NcclxuICB9O1xyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWF4T2JzZXJ2ZWQoaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdKToge1xuICBtYXhPYnNlcnZlZEt3OiBudW1iZXI7XG4gIG1heE9ic2VydmVkVGltZXN0YW1wOiBzdHJpbmcgfCBudWxsO1xufSB7XG4gIGlmIChpbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heE9ic2VydmVkS3c6IDAsXG4gICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcDogbnVsbFxuICAgIH07XG4gIH1cblxuICBsZXQgbWF4T2JzZXJ2ZWRLdyA9IC0xO1xuICBsZXQgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGludGVydmFsLmNvbnN1bXB0aW9uS3cgPiBtYXhPYnNlcnZlZEt3IHx8XG4gICAgICAoaW50ZXJ2YWwuY29uc3VtcHRpb25LdyA9PT0gbWF4T2JzZXJ2ZWRLdyAmJlxuICAgICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcCAhPT0gbnVsbCAmJlxuICAgICAgICBpbnRlcnZhbC50aW1lc3RhbXAgPCBtYXhPYnNlcnZlZFRpbWVzdGFtcClcbiAgICApIHtcbiAgICAgIG1heE9ic2VydmVkS3cgPSBpbnRlcnZhbC5jb25zdW1wdGlvbkt3O1xuICAgICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXAgPSBpbnRlcnZhbC50aW1lc3RhbXA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIG1heE9ic2VydmVkS3csXG4gICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFRvcEV4Y2VlZGVkSW50ZXJ2YWxzKFxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10sXG4gIGRheTogc3RyaW5nLFxuICBsaW1pdCA9IDIwXG4pOiBFeGNlZWRlZEludGVydmFsW10ge1xuICByZXR1cm4gaW50ZXJ2YWxzXG4gICAgLmZpbHRlcigoaW50ZXJ2YWwpID0+IGdldExvY2FsRGF5SXNvKGludGVydmFsLnRpbWVzdGFtcCkgPT09IGRheSAmJiBpbnRlcnZhbC5leGNlc3NLdyA+IDApXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuZXhjZXNzS3cgLSBhLmV4Y2Vzc0t3IHx8IGEudGltZXN0YW1wLmxvY2FsZUNvbXBhcmUoYi50aW1lc3RhbXApKVxuICAgIC5zbGljZSgwLCBsaW1pdClcbiAgICAubWFwKChpbnRlcnZhbCkgPT4gKHtcbiAgICAgIHRpbWVzdGFtcDogaW50ZXJ2YWwudGltZXN0YW1wLFxuICAgICAgY29uc3VtcHRpb25fa1c6IGludGVydmFsLmNvbnN1bXB0aW9uS3csXG4gICAgICBleGNlc3Nfa1c6IGludGVydmFsLmV4Y2Vzc0t3XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXlQcm9maWxlKFxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10sXG4gIGRheUlzbzogc3RyaW5nLFxuICBpbnRlcnZhbE1pbnV0ZXMgPSAxNSxcbiAgdGltZVpvbmUgPSAnRXVyb3BlL0Ftc3RlcmRhbSdcbik6IERheVByb2ZpbGVQb2ludFtdIHtcbiAgY29uc3QgZnVsbERheVNlcmllcyA9IGJ1aWxkRGF5S3dTZXJpZXMoXG4gICAgaW50ZXJ2YWxzLm1hcCgoaW50ZXJ2YWwpID0+ICh7XG4gICAgICB0aW1lc3RhbXA6IGludGVydmFsLnRpbWVzdGFtcCxcbiAgICAgIGNvbnN1bXB0aW9uS3c6IGludGVydmFsLmNvbnN1bXB0aW9uS3dcbiAgICB9KSksXG4gICAgZGF5SXNvLFxuICAgIGludGVydmFsTWludXRlcyxcbiAgICB0aW1lWm9uZVxuICApO1xuXG4gIHJldHVybiBmdWxsRGF5U2VyaWVzLm1hcCgoc2xvdCkgPT4gKHtcbiAgICB0aW1lc3RhbXBMYWJlbDogc2xvdC50aW1lTGFiZWwsXG4gICAgdGltZXN0YW1wSXNvOiBzbG90LnRpbWVzdGFtcElzbyxcbiAgICBvYnNlcnZlZEt3OiBzbG90LmNvbnN1bXB0aW9uS3dcbiAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXlLd1NlcmllcyhcbiAgaW50ZXJ2YWxzOiB7IHRpbWVzdGFtcDogc3RyaW5nOyBjb25zdW1wdGlvbkt3OiBudW1iZXIgfVtdLFxuICBkYXlJc286IHN0cmluZyxcbiAgaW50ZXJ2YWxNaW51dGVzID0gMTUsXG4gIHRpbWVab25lID0gJ0V1cm9wZS9BbXN0ZXJkYW0nXG4pOiBEYXlLd1Nlcmllc1BvaW50W10ge1xuICBpZiAoIWRheUlzbyB8fCBpbnRlcnZhbE1pbnV0ZXMgPD0gMCkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IFt5ZWFyLCBtb250aCwgZGF5XSA9IGRheUlzby5zcGxpdCgnLScpLm1hcChOdW1iZXIpO1xuICBjb25zdCBkYXlTdGFydExvY2FsID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIDAsIDAsIDAsIDApO1xuICBpZiAoTnVtYmVyLmlzTmFOKGRheVN0YXJ0TG9jYWwuZ2V0VGltZSgpKSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IHNsb3RzUGVyRGF5ID0gTWF0aC5mbG9vcigoMjQgKiA2MCkgLyBpbnRlcnZhbE1pbnV0ZXMpO1xuICBjb25zdCBwcm9maWxlID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogc2xvdHNQZXJEYXkgfSwgKF8sIGluZGV4KTogRGF5S3dTZXJpZXNQb2ludCA9PiB7XG4gICAgY29uc3QgbWludXRlcyA9IGluZGV4ICogaW50ZXJ2YWxNaW51dGVzO1xuICAgIGNvbnN0IGhvdXIgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgY29uc3QgbWludXRlID0gbWludXRlcyAlIDYwO1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lTGFiZWw6IGAke1N0cmluZyhob3VyKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyhtaW51dGUpLnBhZFN0YXJ0KDIsICcwJyl9YCxcbiAgICAgIHRpbWVzdGFtcElzbzogbmV3IERhdGUoZGF5U3RhcnRMb2NhbC5nZXRUaW1lKCkgKyBtaW51dGVzICogNjBfMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgY29uc3VtcHRpb25LdzogMFxuICAgIH07XG4gIH0pO1xuXG4gIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xuICAgIGlmIChnZXRMb2NhbERheUlzbyhpbnRlcnZhbC50aW1lc3RhbXAsIHRpbWVab25lKSAhPT0gZGF5SXNvKSByZXR1cm47XG5cbiAgICBjb25zdCBkdCA9IHBhcnNlVGltZXN0YW1wKGludGVydmFsLnRpbWVzdGFtcCk7XG4gICAgaWYgKE51bWJlci5pc05hTihkdC5nZXRUaW1lKCkpKSByZXR1cm47XG4gICAgY29uc3QgeyBob3VyLCBtaW51dGUgfSA9IGdldExvY2FsSG91ck1pbnV0ZShkdCwgdGltZVpvbmUpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGhvdXIpIHx8ICFOdW1iZXIuaXNGaW5pdGUobWludXRlKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgbWludXRlT2ZEYXkgPSBob3VyICogNjAgKyBtaW51dGU7XG4gICAgY29uc3Qgc2xvdEluZGV4ID0gTWF0aC5mbG9vcihtaW51dGVPZkRheSAvIGludGVydmFsTWludXRlcyk7XG4gICAgaWYgKHNsb3RJbmRleCA8IDAgfHwgc2xvdEluZGV4ID49IHNsb3RzUGVyRGF5KSByZXR1cm47XG5cbiAgICBwcm9maWxlW3Nsb3RJbmRleF0uY29uc3VtcHRpb25LdyA9IE1hdGgubWF4KHByb2ZpbGVbc2xvdEluZGV4XS5jb25zdW1wdGlvbkt3LCBpbnRlcnZhbC5jb25zdW1wdGlvbkt3KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByb2ZpbGU7XG59XG4iXSwibmFtZXMiOlsiZ2V0TG9jYWxEYXlJc28iLCJnZXRMb2NhbEhvdXJNaW51dGUiLCJwYXJzZVRpbWVzdGFtcCIsIkJBVFRFUllfT1BUSU9OUyIsImxhYmVsIiwiY2FwYWNpdHlLd2giLCJtb2R1bGFyIiwidW5pdFByaWNlRXVyIiwicm91bmRDdXJyZW5jeSIsInZhbHVlIiwiTWF0aCIsInJvdW5kIiwidG9CYXR0ZXJ5UHJvZHVjdCIsImNhbmRpZGF0ZSIsInRvdGFsUHJpY2VFdXIiLCJ0b3RhbENhcGFjaXR5S3doIiwidW5pdENhcGFjaXR5S3doIiwiY291bnQiLCJicmVha2Rvd24iLCJ0eXBlIiwic2VsZWN0TWluaW11bUNvc3RCYXR0ZXJ5T3B0aW9ucyIsInJlcXVpcmVkS3doIiwibm9ybWFsaXplZFJlcXVpcmVkIiwibWF4IiwiY2FuZGlkYXRlcyIsImZvckVhY2giLCJvcHRpb24iLCJtYXhDb3VudCIsImNlaWwiLCJwdXNoIiwib3ZlckNhcGFjaXR5S3doIiwic29ydGVkIiwic29ydCIsImEiLCJiIiwicmVjb21tZW5kZWRQcm9kdWN0IiwiYWx0ZXJuYXRpdmVQcm9kdWN0IiwicHJvY2Vzc0ludGVydmFscyIsInJvd3MiLCJjb250cmFjdGVkUG93ZXJLdyIsIm1hcCIsInJvdyIsInRpbWVzdGFtcCIsIm5vcm1hbGl6ZWRUaW1lc3RhbXAiLCJOdW1iZXIiLCJpc05hTiIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsImNvbnN1bXB0aW9uS3ciLCJjb25zdW1wdGlvbkt3aCIsImV4Y2Vzc0t3IiwiZXhjZXNzS3doIiwiZ3JvdXBQZWFrRXZlbnRzIiwiaW50ZXJ2YWxzIiwiZXZlbnRzIiwiY3VycmVudCIsImludGVydmFsIiwiaW5kZXgiLCJwZWFrVGltZXN0YW1wIiwiZHVyYXRpb25JbnRlcnZhbHMiLCJtYXhFeGNlc3NLdyIsInRvdGFsRXhjZXNzS3doIiwiaW50ZXJ2YWxJbmRleGVzIiwicGVyY2VudGlsZSIsInZhbHVlcyIsInAiLCJsZW5ndGgiLCJpZHgiLCJtaW4iLCJjb21wdXRlU2l6aW5nIiwicGFyYW1zIiwibWV0aG9kIiwiY29tcGxpYW5jZSIsInNhZmV0eUZhY3RvciIsImVmZmljaWVuY3kiLCJrV2hOZWVkZWRSYXciLCJrV05lZWRlZFJhdyIsImhpZ2hlc3RFbmVyZ3lFdmVudCIsImV2ZW50IiwiYnlEYXkiLCJNYXAiLCJkYXkiLCJzbGljZSIsImxpc3QiLCJnZXQiLCJzZXQiLCJtYXhEYXlFbmVyZ3kiLCJtYXhEYXlQZWFrIiwiZGF5SW50ZXJ2YWxzIiwiZGF5RW5lcmd5IiwicmVkdWNlIiwic3VtIiwia1doTmVlZGVkIiwia1dOZWVkZWQiLCJidWlsZERhdGFRdWFsaXR5UmVwb3J0IiwidGltZXN0YW1wcyIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJtaXNzaW5nSW50ZXJ2YWxzQ291bnQiLCJkdXBsaWNhdGVDb3VudCIsIm5vbjE1TWluSW50ZXJ2YWxzIiwid2FybmluZ3MiLCJEYXRlIiwiZmlsdGVyIiwiZGF0ZSIsIlNldCIsImQiLCJzaXplIiwiaSIsImRpZmZNaW51dGVzIiwiZmluZE1heE9ic2VydmVkIiwibWF4T2JzZXJ2ZWRLdyIsIm1heE9ic2VydmVkVGltZXN0YW1wIiwic2VsZWN0VG9wRXhjZWVkZWRJbnRlcnZhbHMiLCJsaW1pdCIsImxvY2FsZUNvbXBhcmUiLCJjb25zdW1wdGlvbl9rVyIsImV4Y2Vzc19rVyIsImJ1aWxkRGF5UHJvZmlsZSIsImRheUlzbyIsImludGVydmFsTWludXRlcyIsInRpbWVab25lIiwiZnVsbERheVNlcmllcyIsImJ1aWxkRGF5S3dTZXJpZXMiLCJzbG90IiwidGltZXN0YW1wTGFiZWwiLCJ0aW1lTGFiZWwiLCJ0aW1lc3RhbXBJc28iLCJvYnNlcnZlZEt3IiwieWVhciIsIm1vbnRoIiwic3BsaXQiLCJkYXlTdGFydExvY2FsIiwic2xvdHNQZXJEYXkiLCJmbG9vciIsInByb2ZpbGUiLCJBcnJheSIsImZyb20iLCJfIiwibWludXRlcyIsImhvdXIiLCJtaW51dGUiLCJTdHJpbmciLCJwYWRTdGFydCIsImR0IiwiaXNGaW5pdGUiLCJtaW51dGVPZkRheSIsInNsb3RJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});