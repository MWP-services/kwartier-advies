"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BATTERY_OPTIONS: function() { return /* binding */ BATTERY_OPTIONS; },\n/* harmony export */   buildDataQualityReport: function() { return /* binding */ buildDataQualityReport; },\n/* harmony export */   buildDayKwSeries: function() { return /* binding */ buildDayKwSeries; },\n/* harmony export */   buildDayProfile: function() { return /* binding */ buildDayProfile; },\n/* harmony export */   computeSizing: function() { return /* binding */ computeSizing; },\n/* harmony export */   countExceedanceIntervals: function() { return /* binding */ countExceedanceIntervals; },\n/* harmony export */   findMaxObserved: function() { return /* binding */ findMaxObserved; },\n/* harmony export */   groupPeakEvents: function() { return /* binding */ groupPeakEvents; },\n/* harmony export */   processIntervals: function() { return /* binding */ processIntervals; },\n/* harmony export */   selectMinimumCostBatteryOptions: function() { return /* binding */ selectMinimumCostBatteryOptions; },\n/* harmony export */   selectTopExceededIntervals: function() { return /* binding */ selectTopExceededIntervals; }\n/* harmony export */ });\n/* harmony import */ var _datetime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime */ \"(app-pages-browser)/./lib/datetime.ts\");\n\nconst BATTERY_OPTIONS = [\n    {\n        label: \"WattsNext ESS Cabinet 64 kWh\",\n        capacityKwh: 64,\n        modular: true,\n        unitPriceEur: 15689.33\n    },\n    {\n        label: \"WattsNext ESS Cabinet 96 kWh\",\n        capacityKwh: 96,\n        modular: true,\n        unitPriceEur: 22225.98\n    },\n    {\n        label: \"ESS All-in-one Cabinet 261 kWh\",\n        capacityKwh: 261,\n        modular: true,\n        unitPriceEur: 43995.96\n    },\n    {\n        label: \"WattsNext All-in-one Container 2.09 MWh\",\n        capacityKwh: 2090,\n        modular: false,\n        unitPriceEur: 318658.06\n    },\n    {\n        label: \"WattsNext All in-one Container 5.015 MWh\",\n        capacityKwh: 5015,\n        modular: false,\n        unitPriceEur: 675052.49\n    }\n];\nfunction roundCurrency(value) {\n    return Math.round(value * 100) / 100;\n}\nfunction toBatteryProduct(candidate) {\n    const totalPriceEur = roundCurrency(candidate.totalPriceEur);\n    return {\n        label: candidate.label,\n        capacityKwh: candidate.totalCapacityKwh,\n        unitCapacityKwh: candidate.unitCapacityKwh,\n        count: candidate.count,\n        unitPriceEur: roundCurrency(candidate.unitPriceEur),\n        totalPriceEur,\n        breakdown: [\n            {\n                type: \"\".concat(candidate.unitCapacityKwh, \" kWh\"),\n                count: candidate.count,\n                unitCapacityKwh: candidate.unitCapacityKwh,\n                unitPriceEur: roundCurrency(candidate.unitPriceEur),\n                totalPriceEur\n            }\n        ]\n    };\n}\nfunction selectMinimumCostBatteryOptions(requiredKwh) {\n    const normalizedRequired = Math.max(0, requiredKwh);\n    const candidates = [];\n    BATTERY_OPTIONS.forEach((option)=>{\n        var _option_unitPriceEur;\n        const unitPriceEur = (_option_unitPriceEur = option.unitPriceEur) !== null && _option_unitPriceEur !== void 0 ? _option_unitPriceEur : 0;\n        if (option.modular) {\n            const maxCount = Math.max(1, Math.ceil(normalizedRequired / option.capacityKwh));\n            for(let count = 1; count <= maxCount; count += 1){\n                const totalCapacityKwh = count * option.capacityKwh;\n                if (totalCapacityKwh < normalizedRequired) continue;\n                const totalPriceEur = count * unitPriceEur;\n                candidates.push({\n                    label: \"\".concat(count, \"x \").concat(option.capacityKwh, \" kWh (modulair)\"),\n                    totalCapacityKwh,\n                    totalPriceEur,\n                    overCapacityKwh: totalCapacityKwh - normalizedRequired,\n                    count,\n                    unitCapacityKwh: option.capacityKwh,\n                    unitPriceEur\n                });\n            }\n            return;\n        }\n        if (option.capacityKwh >= normalizedRequired) {\n            candidates.push({\n                label: option.label,\n                totalCapacityKwh: option.capacityKwh,\n                totalPriceEur: unitPriceEur,\n                overCapacityKwh: option.capacityKwh - normalizedRequired,\n                count: 1,\n                unitCapacityKwh: option.capacityKwh,\n                unitPriceEur\n            });\n        }\n    });\n    const sorted = candidates.sort((a, b)=>a.totalPriceEur - b.totalPriceEur || a.overCapacityKwh - b.overCapacityKwh || a.totalCapacityKwh - b.totalCapacityKwh);\n    const recommendedProduct = toBatteryProduct(sorted[0]);\n    const alternativeProduct = sorted[1] ? toBatteryProduct(sorted[1]) : null;\n    return {\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction processIntervals(rows, contractedPowerKw) {\n    return rows.map((row)=>{\n        const timestamp = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(row.timestamp);\n        const normalizedTimestamp = Number.isNaN(timestamp.getTime()) ? row.timestamp : timestamp.toISOString();\n        const consumptionKw = row.consumptionKwh / 0.25;\n        const excessKw = Math.max(0, consumptionKw - contractedPowerKw);\n        return {\n            ...row,\n            timestamp: normalizedTimestamp,\n            consumptionKw,\n            excessKw,\n            excessKwh: excessKw * 0.25\n        };\n    });\n}\nfunction groupPeakEvents(intervals) {\n    const events = [];\n    let current = null;\n    intervals.forEach((interval, index)=>{\n        if (interval.excessKw > 0) {\n            if (!current) {\n                current = {\n                    peakTimestamp: interval.timestamp,\n                    durationIntervals: 0,\n                    maxExcessKw: 0,\n                    totalExcessKwh: 0,\n                    intervalIndexes: []\n                };\n            }\n            current.durationIntervals += 1;\n            if (interval.excessKw > current.maxExcessKw || interval.excessKw === current.maxExcessKw && interval.timestamp < current.peakTimestamp) {\n                current.maxExcessKw = interval.excessKw;\n                current.peakTimestamp = interval.timestamp;\n            }\n            current.totalExcessKwh += interval.excessKwh;\n            current.intervalIndexes.push(index);\n        } else if (current) {\n            events.push(current);\n            current = null;\n        }\n    });\n    if (current) {\n        events.push(current);\n    }\n    return events;\n}\nfunction countExceedanceIntervals(events) {\n    return events.reduce((sum, event)=>sum + event.durationIntervals, 0);\n}\nfunction percentile(values, p) {\n    if (values.length === 0) return 0;\n    const sorted = [\n        ...values\n    ].sort((a, b)=>a - b);\n    const idx = Math.ceil(p / 100 * sorted.length) - 1;\n    return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\n}\nfunction computeSizing(params) {\n    const { intervals, events, method, compliance, safetyFactor, efficiency } = params;\n    let kWhNeededRaw = 0;\n    let kWNeededRaw = 0;\n    if (method === \"MAX_PEAK\") {\n        const highestEnergyEvent = [\n            ...events\n        ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n        if (highestEnergyEvent) {\n            kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n            kWNeededRaw = highestEnergyEvent.maxExcessKw;\n        }\n    }\n    if (method === \"P95\") {\n        if (events.length < 20) {\n            const highestEnergyEvent = [\n                ...events\n            ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n            if (highestEnergyEvent) {\n                kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n                kWNeededRaw = highestEnergyEvent.maxExcessKw;\n            }\n        } else {\n            kWhNeededRaw = percentile(events.map((event)=>event.totalExcessKwh), 95);\n            kWNeededRaw = percentile(events.map((event)=>event.maxExcessKw), 95);\n        }\n    }\n    if (method === \"FULL_COVERAGE\") {\n        const byDay = new Map();\n        intervals.forEach((interval)=>{\n            const day = interval.timestamp.slice(0, 10);\n            var _byDay_get;\n            const list = (_byDay_get = byDay.get(day)) !== null && _byDay_get !== void 0 ? _byDay_get : [];\n            list.push(interval);\n            byDay.set(day, list);\n        });\n        let maxDayEnergy = 0;\n        let maxDayPeak = 0;\n        byDay.forEach((dayIntervals)=>{\n            const dayEnergy = dayIntervals.reduce((sum, interval)=>sum + interval.excessKwh, 0);\n            if (dayEnergy > maxDayEnergy) {\n                maxDayEnergy = dayEnergy;\n                maxDayPeak = Math.max(...dayIntervals.map((interval)=>interval.excessKw));\n            }\n        });\n        kWhNeededRaw = maxDayEnergy;\n        kWNeededRaw = maxDayPeak;\n    }\n    kWhNeededRaw *= compliance;\n    kWNeededRaw *= compliance;\n    const kWhNeeded = kWhNeededRaw / efficiency * safetyFactor;\n    const kWNeeded = kWNeededRaw * safetyFactor;\n    const { recommendedProduct, alternativeProduct } = selectMinimumCostBatteryOptions(kWhNeeded);\n    return {\n        kWhNeededRaw,\n        kWNeededRaw,\n        kWhNeeded,\n        kWNeeded,\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction buildDataQualityReport(intervals) {\n    var _timestamps_, _timestamps_1;\n    if (intervals.length === 0) {\n        return {\n            rows: 0,\n            startDate: null,\n            endDate: null,\n            missingIntervalsCount: 0,\n            duplicateCount: 0,\n            non15MinIntervals: 0,\n            warnings: [\n                \"No rows found in dataset.\"\n            ]\n        };\n    }\n    const timestamps = intervals.map((row)=>new Date(row.timestamp)).filter((date)=>!Number.isNaN(date.getTime())).sort((a, b)=>a.getTime() - b.getTime());\n    const duplicateCount = timestamps.length - new Set(timestamps.map((d)=>d.toISOString())).size;\n    let non15MinIntervals = 0;\n    let missingIntervalsCount = 0;\n    const EPS = 0.01;\n    for(let i = 1; i < timestamps.length; i += 1){\n        const diffMinutes = (timestamps[i].getTime() - timestamps[i - 1].getTime()) / 60000;\n        if (Math.abs(diffMinutes - 15) > EPS) {\n            non15MinIntervals += 1;\n            if (diffMinutes > 15 + EPS) {\n                missingIntervalsCount += Math.max(0, Math.round(diffMinutes / 15) - 1);\n            }\n        }\n    }\n    const warnings = [];\n    if (duplicateCount > 0) warnings.push(\"Detected \".concat(duplicateCount, \" duplicate timestamps.\"));\n    if (non15MinIntervals > 0) {\n        warnings.push(\"Detected \".concat(non15MinIntervals, \" non-15-minute interval transitions.\"));\n    }\n    var _timestamps__toISOString, _timestamps__toISOString1;\n    return {\n        rows: intervals.length,\n        startDate: (_timestamps__toISOString = (_timestamps_ = timestamps[0]) === null || _timestamps_ === void 0 ? void 0 : _timestamps_.toISOString()) !== null && _timestamps__toISOString !== void 0 ? _timestamps__toISOString : null,\n        endDate: (_timestamps__toISOString1 = (_timestamps_1 = timestamps[timestamps.length - 1]) === null || _timestamps_1 === void 0 ? void 0 : _timestamps_1.toISOString()) !== null && _timestamps__toISOString1 !== void 0 ? _timestamps__toISOString1 : null,\n        missingIntervalsCount,\n        duplicateCount,\n        non15MinIntervals,\n        warnings\n    };\n}\nfunction findMaxObserved(intervals) {\n    if (intervals.length === 0) {\n        return {\n            maxObservedKw: 0,\n            maxObservedTimestamp: null\n        };\n    }\n    let maxObservedKw = -1;\n    let maxObservedTimestamp = null;\n    intervals.forEach((interval)=>{\n        if (interval.consumptionKw > maxObservedKw || interval.consumptionKw === maxObservedKw && maxObservedTimestamp !== null && interval.timestamp < maxObservedTimestamp) {\n            maxObservedKw = interval.consumptionKw;\n            maxObservedTimestamp = interval.timestamp;\n        }\n    });\n    return {\n        maxObservedKw,\n        maxObservedTimestamp\n    };\n}\nfunction selectTopExceededIntervals(intervals, day) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;\n    return intervals.filter((interval)=>(0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp) === day && interval.excessKw > 0).sort((a, b)=>b.excessKw - a.excessKw || a.timestamp.localeCompare(b.timestamp)).slice(0, limit).map((interval)=>({\n            timestamp: interval.timestamp,\n            consumption_kW: interval.consumptionKw,\n            excess_kW: interval.excessKw\n        }));\n}\nfunction buildDayProfile(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    const fullDaySeries = buildDayKwSeries(intervals.map((interval)=>({\n            timestamp: interval.timestamp,\n            consumptionKw: interval.consumptionKw\n        })), dayIso, intervalMinutes, timeZone);\n    return fullDaySeries.map((slot)=>({\n            timestampLabel: slot.timeLabel,\n            timestampIso: slot.timestampIso,\n            observedKw: slot.consumptionKw\n        }));\n}\nfunction buildDayKwSeries(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    if (!dayIso || intervalMinutes <= 0) return [];\n    const [year, month, day] = dayIso.split(\"-\").map(Number);\n    const dayStartLocal = new Date(year, month - 1, day, 0, 0, 0, 0);\n    if (Number.isNaN(dayStartLocal.getTime())) return [];\n    const slotsPerDay = Math.floor(24 * 60 / intervalMinutes);\n    const profile = Array.from({\n        length: slotsPerDay\n    }, (_, index)=>{\n        const minutes = index * intervalMinutes;\n        const hour = Math.floor(minutes / 60);\n        const minute = minutes % 60;\n        return {\n            timeLabel: \"\".concat(String(hour).padStart(2, \"0\"), \":\").concat(String(minute).padStart(2, \"0\")),\n            timestampIso: new Date(dayStartLocal.getTime() + minutes * 60000).toISOString(),\n            consumptionKw: 0\n        };\n    });\n    intervals.forEach((interval)=>{\n        if ((0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp, timeZone) !== dayIso) return;\n        const dt = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(interval.timestamp);\n        if (Number.isNaN(dt.getTime())) return;\n        const { hour, minute } = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalHourMinute)(dt, timeZone);\n        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return;\n        const minuteOfDay = hour * 60 + minute;\n        const slotIndex = Math.floor(minuteOfDay / intervalMinutes);\n        if (slotIndex < 0 || slotIndex >= slotsPerDay) return;\n        profile[slotIndex].consumptionKw = Math.max(profile[slotIndex].consumptionKw, interval.consumptionKw);\n    });\n    return profile;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jYWxjdWxhdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWdGO0FBaUZ6RSxNQUFNRyxrQkFBb0M7SUFDL0M7UUFDRUMsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsY0FBYztJQUNoQjtJQUNBO1FBQ0VILE9BQU87UUFDUEMsYUFBYTtRQUNiQyxTQUFTO1FBQ1RDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxPQUFPO1FBQ1BDLGFBQWE7UUFDYkMsU0FBUztRQUNUQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsY0FBYztJQUNoQjtJQUNBO1FBQ0VILE9BQU87UUFDUEMsYUFBYTtRQUNiQyxTQUFTO1FBQ1RDLGNBQWM7SUFDaEI7Q0FDRCxDQUFDO0FBWUYsU0FBU0MsY0FBY0MsS0FBYTtJQUNsQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNGLFFBQVEsT0FBTztBQUNuQztBQUVBLFNBQVNHLGlCQUFpQkMsU0FBd0M7SUFDaEUsTUFBTUMsZ0JBQWdCTixjQUFjSyxVQUFVQyxhQUFhO0lBQzNELE9BQU87UUFDTFYsT0FBT1MsVUFBVVQsS0FBSztRQUN0QkMsYUFBYVEsVUFBVUUsZ0JBQWdCO1FBQ3ZDQyxpQkFBaUJILFVBQVVHLGVBQWU7UUFDMUNDLE9BQU9KLFVBQVVJLEtBQUs7UUFDdEJWLGNBQWNDLGNBQWNLLFVBQVVOLFlBQVk7UUFDbERPO1FBQ0FJLFdBQVc7WUFDVDtnQkFDRUMsTUFBTSxHQUE2QixPQUExQk4sVUFBVUcsZUFBZSxFQUFDO2dCQUNuQ0MsT0FBT0osVUFBVUksS0FBSztnQkFDdEJELGlCQUFpQkgsVUFBVUcsZUFBZTtnQkFDMUNULGNBQWNDLGNBQWNLLFVBQVVOLFlBQVk7Z0JBQ2xETztZQUNGO1NBQ0Q7SUFDSDtBQUNGO0FBRU8sU0FBU00sZ0NBQWdDQyxXQUFtQjtJQUlqRSxNQUFNQyxxQkFBcUJaLEtBQUthLEdB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LEdBQUcsTUFBSyxLQUFtQyxPQUFoQ0QsT0FBT0QsUUFBUUUsUUFBUSxDQUFDLEdBQUc7WUFDMUVoQixjQUFjLElBQUkzQixLQUFLZ0MsY0FBY3pGLE9BQU8sS0FBS2dHLFVBQVUsT0FBUS9GLFdBQVc7WUFDOUVDLGVBQWU7UUFDakI7SUFDRjtJQUVBSyxVQUFVNUIsT0FBTyxDQUFDLENBQUMrQjtRQUNqQixJQUFJeEQseURBQWNBLENBQUN3RCxTQUFTZCxTQUFTLEVBQUVrRixjQUFjRixRQUFRO1FBRTdELE1BQU15QixLQUFLakoseURBQWNBLENBQUNzRCxTQUFTZCxTQUFTO1FBQzVDLElBQUlFLE9BQU9DLEtBQUssQ0FBQ3NHLEdBQUdyRyxPQUFPLEtBQUs7UUFDaEMsTUFBTSxFQUFFaUcsSUFBSSxFQUFFQyxNQUFNLEVBQUUsR0FBRy9JLDZEQUFrQkEsQ0FBQ2tKLElBQUl2QjtRQUNoRCxJQUFJLENBQUNoRixPQUFPd0csUUFBUSxDQUFDTCxTQUFTLENBQUNuRyxPQUFPd0csUUFBUSxDQUFDSixTQUFTO1FBRXhELE1BQU1LLGNBQWNOLE9BQU8sS0FBS0M7UUFDaEMsTUFBTU0sWUFBWTVJLEtBQUsrSCxLQUFLLENBQUNZLGNBQWMxQjtRQUMzQyxJQUFJMkIsWUFBWSxLQUFLQSxhQUFhZCxhQUFhO1FBRS9DRSxPQUFPLENBQUNZLFVBQVUsQ0FBQ3RHLGFBQWEsR0FBR3RDLEtBQUthLEdBQUcsQ0FBQ21ILE9BQU8sQ0FBQ1ksVUFBVSxDQUFDdEcsYUFBYSxFQUFFUSxTQUFTUixhQUFhO0lBQ3RHO0lBRUEsT0FBTzBGO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2NhbGN1bGF0aW9ucy50cz8zZjc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExvY2FsRGF5SXNvLCBnZXRMb2NhbEhvdXJNaW51dGUsIHBhcnNlVGltZXN0YW1wIH0gZnJvbSAnLi9kYXRldGltZSc7XG5cbmV4cG9ydCB0eXBlIE1ldGhvZCA9ICdNQVhfUEVBSycgfCAnUDk1JyB8ICdGVUxMX0NPVkVSQUdFJztcblxyXG5leHBvcnQgaW50ZXJmYWNlIEludGVydmFsUmVjb3JkIHtcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxuICBjb25zdW1wdGlvbkt3aDogbnVtYmVyO1xyXG4gIGV4cG9ydEt3aD86IG51bWJlcjtcclxuICBwdkt3aD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzZWRJbnRlcnZhbCBleHRlbmRzIEludGVydmFsUmVjb3JkIHtcclxuICBjb25zdW1wdGlvbkt3OiBudW1iZXI7XHJcbiAgZXhjZXNzS3c6IG51bWJlcjtcclxuICBleGNlc3NLd2g6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQZWFrRXZlbnQge1xuICBwZWFrVGltZXN0YW1wOiBzdHJpbmc7XG4gIGR1cmF0aW9uSW50ZXJ2YWxzOiBudW1iZXI7XG4gIG1heEV4Y2Vzc0t3OiBudW1iZXI7XG4gIHRvdGFsRXhjZXNzS3doOiBudW1iZXI7XG4gIGludGVydmFsSW5kZXhlczogbnVtYmVyW107XG59XG5cclxuZXhwb3J0IGludGVyZmFjZSBEYXRhUXVhbGl0eVJlcG9ydCB7XHJcbiAgcm93czogbnVtYmVyO1xyXG4gIHN0YXJ0RGF0ZTogc3RyaW5nIHwgbnVsbDtcclxuICBlbmREYXRlOiBzdHJpbmcgfCBudWxsO1xyXG4gIG1pc3NpbmdJbnRlcnZhbHNDb3VudDogbnVtYmVyO1xyXG4gIGR1cGxpY2F0ZUNvdW50OiBudW1iZXI7XHJcbiAgbm9uMTVNaW5JbnRlcnZhbHM6IG51bWJlcjtcclxuICB3YXJuaW5nczogc3RyaW5nW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2l6aW5nUmVzdWx0IHtcclxuICBrV2hOZWVkZWRSYXc6IG51bWJlcjtcclxuICBrV05lZWRlZFJhdzogbnVtYmVyO1xyXG4gIGtXaE5lZWRlZDogbnVtYmVyO1xyXG4gIGtXTmVlZGVkOiBudW1iZXI7XHJcbiAgcmVjb21tZW5kZWRQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdDtcclxuICBhbHRlcm5hdGl2ZVByb2R1Y3Q6IEJhdHRlcnlQcm9kdWN0IHwgbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXR0ZXJ5UHJvZHVjdCB7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGNhcGFjaXR5S3doOiBudW1iZXI7XG4gIG1vZHVsYXI/OiBib29sZWFuO1xuICB1bml0UHJpY2VFdXI/OiBudW1iZXI7XG4gIHVuaXRDYXBhY2l0eUt3aD86IG51bWJlcjtcbiAgY291bnQ/OiBudW1iZXI7XG4gIHRvdGFsUHJpY2VFdXI/OiBudW1iZXI7XG4gIGJyZWFrZG93bj86IEJhdHRlcnlCcmVha2Rvd25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXR0ZXJ5QnJlYWtkb3duIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb3VudDogbnVtYmVyO1xuICB1bml0Q2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgdW5pdFByaWNlRXVyOiBudW1iZXI7XG4gIHRvdGFsUHJpY2VFdXI6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeGNlZWRlZEludGVydmFsIHtcbiAgdGltZXN0YW1wOiBzdHJpbmc7XG4gIGNvbnN1bXB0aW9uX2tXOiBudW1iZXI7XG4gIGV4Y2Vzc19rVzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERheVByb2ZpbGVQb2ludCB7XG4gIHRpbWVzdGFtcExhYmVsOiBzdHJpbmc7XG4gIHRpbWVzdGFtcElzbzogc3RyaW5nO1xuICBvYnNlcnZlZEt3OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5S3dTZXJpZXNQb2ludCB7XG4gIHRpbWVMYWJlbDogc3RyaW5nO1xuICB0aW1lc3RhbXBJc286IHN0cmluZztcbiAgY29uc3VtcHRpb25LdzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgQkFUVEVSWV9PUFRJT05TOiBCYXR0ZXJ5UHJvZHVjdFtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgRVNTIENhYmluZXQgNjQga1doJyxcbiAgICBjYXBhY2l0eUt3aDogNjQsXG4gICAgbW9kdWxhcjogdHJ1ZSxcbiAgICB1bml0UHJpY2VFdXI6IDE1Njg5LjMzXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1dhdHRzTmV4dCBFU1MgQ2FiaW5ldCA5NiBrV2gnLFxuICAgIGNhcGFjaXR5S3doOiA5NixcbiAgICBtb2R1bGFyOiB0cnVlLFxuICAgIHVuaXRQcmljZUV1cjogMjIyMjUuOThcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnRVNTIEFsbC1pbi1vbmUgQ2FiaW5ldCAyNjEga1doJyxcbiAgICBjYXBhY2l0eUt3aDogMjYxLFxuICAgIG1vZHVsYXI6IHRydWUsXG4gICAgdW5pdFByaWNlRXVyOiA0Mzk5NS45NlxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgQWxsLWluLW9uZSBDb250YWluZXIgMi4wOSBNV2gnLFxuICAgIGNhcGFjaXR5S3doOiAyMDkwLFxuICAgIG1vZHVsYXI6IGZhbHNlLFxuICAgIHVuaXRQcmljZUV1cjogMzE4NjU4LjA2XG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1dhdHRzTmV4dCBBbGwgaW4tb25lIENvbnRhaW5lciA1LjAxNSBNV2gnLFxuICAgIGNhcGFjaXR5S3doOiA1MDE1LFxuICAgIG1vZHVsYXI6IGZhbHNlLFxuICAgIHVuaXRQcmljZUV1cjogNjc1MDUyLjQ5XG4gIH1cbl07XG5cbmludGVyZmFjZSBCYXR0ZXJ5Q29uZmlndXJhdGlvbkNhbmRpZGF0ZSB7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIHRvdGFsQ2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgdG90YWxQcmljZUV1cjogbnVtYmVyO1xuICBvdmVyQ2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgY291bnQ6IG51bWJlcjtcbiAgdW5pdENhcGFjaXR5S3doOiBudW1iZXI7XG4gIHVuaXRQcmljZUV1cjogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiByb3VuZEN1cnJlbmN5KHZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIHRvQmF0dGVyeVByb2R1Y3QoY2FuZGlkYXRlOiBCYXR0ZXJ5Q29uZmlndXJhdGlvbkNhbmRpZGF0ZSk6IEJhdHRlcnlQcm9kdWN0IHtcbiAgY29uc3QgdG90YWxQcmljZUV1ciA9IHJvdW5kQ3VycmVuY3koY2FuZGlkYXRlLnRvdGFsUHJpY2VFdXIpO1xuICByZXR1cm4ge1xuICAgIGxhYmVsOiBjYW5kaWRhdGUubGFiZWwsXG4gICAgY2FwYWNpdHlLd2g6IGNhbmRpZGF0ZS50b3RhbENhcGFjaXR5S3doLFxuICAgIHVuaXRDYXBhY2l0eUt3aDogY2FuZGlkYXRlLnVuaXRDYXBhY2l0eUt3aCxcbiAgICBjb3VudDogY2FuZGlkYXRlLmNvdW50LFxuICAgIHVuaXRQcmljZUV1cjogcm91bmRDdXJyZW5jeShjYW5kaWRhdGUudW5pdFByaWNlRXVyKSxcbiAgICB0b3RhbFByaWNlRXVyLFxuICAgIGJyZWFrZG93bjogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBgJHtjYW5kaWRhdGUudW5pdENhcGFjaXR5S3dofSBrV2hgLFxuICAgICAgICBjb3VudDogY2FuZGlkYXRlLmNvdW50LFxuICAgICAgICB1bml0Q2FwYWNpdHlLd2g6IGNhbmRpZGF0ZS51bml0Q2FwYWNpdHlLd2gsXG4gICAgICAgIHVuaXRQcmljZUV1cjogcm91bmRDdXJyZW5jeShjYW5kaWRhdGUudW5pdFByaWNlRXVyKSxcbiAgICAgICAgdG90YWxQcmljZUV1clxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdE1pbmltdW1Db3N0QmF0dGVyeU9wdGlvbnMocmVxdWlyZWRLd2g6IG51bWJlcik6IHtcbiAgcmVjb21tZW5kZWRQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdDtcbiAgYWx0ZXJuYXRpdmVQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdCB8IG51bGw7XG59IHtcbiAgY29uc3Qgbm9ybWFsaXplZFJlcXVpcmVkID0gTWF0aC5tYXgoMCwgcmVxdWlyZWRLd2gpO1xuICBjb25zdCBjYW5kaWRhdGVzOiBCYXR0ZXJ5Q29uZmlndXJhdGlvbkNhbmRpZGF0ZVtdID0gW107XG5cbiAgQkFUVEVSWV9PUFRJT05TLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgIGNvbnN0IHVuaXRQcmljZUV1ciA9IG9wdGlvbi51bml0UHJpY2VFdXIgPz8gMDtcbiAgICBpZiAob3B0aW9uLm1vZHVsYXIpIHtcbiAgICAgIGNvbnN0IG1heENvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKG5vcm1hbGl6ZWRSZXF1aXJlZCAvIG9wdGlvbi5jYXBhY2l0eUt3aCkpO1xuICAgICAgZm9yIChsZXQgY291bnQgPSAxOyBjb3VudCA8PSBtYXhDb3VudDsgY291bnQgKz0gMSkge1xuICAgICAgICBjb25zdCB0b3RhbENhcGFjaXR5S3doID0gY291bnQgKiBvcHRpb24uY2FwYWNpdHlLd2g7XG4gICAgICAgIGlmICh0b3RhbENhcGFjaXR5S3doIDwgbm9ybWFsaXplZFJlcXVpcmVkKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdG90YWxQcmljZUV1ciA9IGNvdW50ICogdW5pdFByaWNlRXVyO1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgIGxhYmVsOiBgJHtjb3VudH14ICR7b3B0aW9uLmNhcGFjaXR5S3dofSBrV2ggKG1vZHVsYWlyKWAsXG4gICAgICAgICAgdG90YWxDYXBhY2l0eUt3aCxcbiAgICAgICAgICB0b3RhbFByaWNlRXVyLFxuICAgICAgICAgIG92ZXJDYXBhY2l0eUt3aDogdG90YWxDYXBhY2l0eUt3aCAtIG5vcm1hbGl6ZWRSZXF1aXJlZCxcbiAgICAgICAgICBjb3VudCxcbiAgICAgICAgICB1bml0Q2FwYWNpdHlLd2g6IG9wdGlvbi5jYXBhY2l0eUt3aCxcbiAgICAgICAgICB1bml0UHJpY2VFdXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbi5jYXBhY2l0eUt3aCA+PSBub3JtYWxpemVkUmVxdWlyZWQpIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgIGxhYmVsOiBvcHRpb24ubGFiZWwsXG4gICAgICAgIHRvdGFsQ2FwYWNpdHlLd2g6IG9wdGlvbi5jYXBhY2l0eUt3aCxcbiAgICAgICAgdG90YWxQcmljZUV1cjogdW5pdFByaWNlRXVyLFxuICAgICAgICBvdmVyQ2FwYWNpdHlLd2g6IG9wdGlvbi5jYXBhY2l0eUt3aCAtIG5vcm1hbGl6ZWRSZXF1aXJlZCxcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICAgIHVuaXRDYXBhY2l0eUt3aDogb3B0aW9uLmNhcGFjaXR5S3doLFxuICAgICAgICB1bml0UHJpY2VFdXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3Qgc29ydGVkID0gY2FuZGlkYXRlcy5zb3J0KFxuICAgIChhLCBiKSA9PlxuICAgICAgYS50b3RhbFByaWNlRXVyIC0gYi50b3RhbFByaWNlRXVyIHx8XG4gICAgICBhLm92ZXJDYXBhY2l0eUt3aCAtIGIub3ZlckNhcGFjaXR5S3doIHx8XG4gICAgICBhLnRvdGFsQ2FwYWNpdHlLd2ggLSBiLnRvdGFsQ2FwYWNpdHlLd2hcbiAgKTtcblxuICBjb25zdCByZWNvbW1lbmRlZFByb2R1Y3QgPSB0b0JhdHRlcnlQcm9kdWN0KHNvcnRlZFswXSk7XG4gIGNvbnN0IGFsdGVybmF0aXZlUHJvZHVjdCA9IHNvcnRlZFsxXSA/IHRvQmF0dGVyeVByb2R1Y3Qoc29ydGVkWzFdKSA6IG51bGw7XG5cbiAgcmV0dXJuIHsgcmVjb21tZW5kZWRQcm9kdWN0LCBhbHRlcm5hdGl2ZVByb2R1Y3QgfTtcbn1cblxyXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0ludGVydmFscyhcbiAgcm93czogSW50ZXJ2YWxSZWNvcmRbXSxcbiAgY29udHJhY3RlZFBvd2VyS3c6IG51bWJlclxuKTogUHJvY2Vzc2VkSW50ZXJ2YWxbXSB7XG4gIHJldHVybiByb3dzLm1hcCgocm93KSA9PiB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VUaW1lc3RhbXAocm93LnRpbWVzdGFtcCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFRpbWVzdGFtcCA9IE51bWJlci5pc05hTih0aW1lc3RhbXAuZ2V0VGltZSgpKSA/IHJvdy50aW1lc3RhbXAgOiB0aW1lc3RhbXAudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBjb25zdW1wdGlvbkt3ID0gcm93LmNvbnN1bXB0aW9uS3doIC8gMC4yNTtcbiAgICBjb25zdCBleGNlc3NLdyA9IE1hdGgubWF4KDAsIGNvbnN1bXB0aW9uS3cgLSBjb250cmFjdGVkUG93ZXJLdyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJvdyxcbiAgICAgIHRpbWVzdGFtcDogbm9ybWFsaXplZFRpbWVzdGFtcCxcbiAgICAgIGNvbnN1bXB0aW9uS3csXG4gICAgICBleGNlc3NLdyxcbiAgICAgIGV4Y2Vzc0t3aDogZXhjZXNzS3cgKiAwLjI1XG4gICAgfTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwUGVha0V2ZW50cyhpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10pOiBQZWFrRXZlbnRbXSB7XG4gIGNvbnN0IGV2ZW50czogUGVha0V2ZW50W10gPSBbXTtcbiAgbGV0IGN1cnJlbnQ6IFBlYWtFdmVudCB8IG51bGwgPSBudWxsO1xuXG4gIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW50ZXJ2YWwuZXhjZXNzS3cgPiAwKSB7XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudCA9IHtcbiAgICAgICAgICBwZWFrVGltZXN0YW1wOiBpbnRlcnZhbC50aW1lc3RhbXAsXG4gICAgICAgICAgZHVyYXRpb25JbnRlcnZhbHM6IDAsXG4gICAgICAgICAgbWF4RXhjZXNzS3c6IDAsXG4gICAgICAgICAgdG90YWxFeGNlc3NLd2g6IDAsXG4gICAgICAgICAgaW50ZXJ2YWxJbmRleGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudC5kdXJhdGlvbkludGVydmFscyArPSAxO1xuICAgICAgaWYgKFxuICAgICAgICBpbnRlcnZhbC5leGNlc3NLdyA+IGN1cnJlbnQubWF4RXhjZXNzS3cgfHxcbiAgICAgICAgKGludGVydmFsLmV4Y2Vzc0t3ID09PSBjdXJyZW50Lm1heEV4Y2Vzc0t3ICYmIGludGVydmFsLnRpbWVzdGFtcCA8IGN1cnJlbnQucGVha1RpbWVzdGFtcClcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50Lm1heEV4Y2Vzc0t3ID0gaW50ZXJ2YWwuZXhjZXNzS3c7XG4gICAgICAgIGN1cnJlbnQucGVha1RpbWVzdGFtcCA9IGludGVydmFsLnRpbWVzdGFtcDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQudG90YWxFeGNlc3NLd2ggKz0gaW50ZXJ2YWwuZXhjZXNzS3doO1xuICAgICAgY3VycmVudC5pbnRlcnZhbEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICBldmVudHMucHVzaChjdXJyZW50KTtcclxuICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGlmIChjdXJyZW50KSB7XHJcbiAgICBldmVudHMucHVzaChjdXJyZW50KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBldmVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3VudEV4Y2VlZGFuY2VJbnRlcnZhbHMoZXZlbnRzOiBQZWFrRXZlbnRbXSk6IG51bWJlciB7XG4gIHJldHVybiBldmVudHMucmVkdWNlKChzdW0sIGV2ZW50KSA9PiBzdW0gKyBldmVudC5kdXJhdGlvbkludGVydmFscywgMCk7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRpbGUodmFsdWVzOiBudW1iZXJbXSwgcDogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xyXG4gIGNvbnN0IHNvcnRlZCA9IFsuLi52YWx1ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICBjb25zdCBpZHggPSBNYXRoLmNlaWwoKHAgLyAxMDApICogc29ydGVkLmxlbmd0aCkgLSAxO1xyXG4gIHJldHVybiBzb3J0ZWRbTWF0aC5tYXgoMCwgTWF0aC5taW4oaWR4LCBzb3J0ZWQubGVuZ3RoIC0gMSkpXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTaXppbmcocGFyYW1zOiB7XHJcbiAgaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdO1xyXG4gIGV2ZW50czogUGVha0V2ZW50W107XHJcbiAgbWV0aG9kOiBNZXRob2Q7XHJcbiAgY29tcGxpYW5jZTogbnVtYmVyO1xyXG4gIHNhZmV0eUZhY3RvcjogbnVtYmVyO1xyXG4gIGVmZmljaWVuY3k6IG51bWJlcjtcclxufSk6IFNpemluZ1Jlc3VsdCB7XHJcbiAgY29uc3QgeyBpbnRlcnZhbHMsIGV2ZW50cywgbWV0aG9kLCBjb21wbGlhbmNlLCBzYWZldHlGYWN0b3IsIGVmZmljaWVuY3kgfSA9IHBhcmFtcztcclxuXHJcbiAgbGV0IGtXaE5lZWRlZFJhdyA9IDA7XHJcbiAgbGV0IGtXTmVlZGVkUmF3ID0gMDtcclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ01BWF9QRUFLJykge1xyXG4gICAgY29uc3QgaGlnaGVzdEVuZXJneUV2ZW50ID0gWy4uLmV2ZW50c10uc29ydChcclxuICAgICAgKGEsIGIpID0+IGIudG90YWxFeGNlc3NLd2ggLSBhLnRvdGFsRXhjZXNzS3doXHJcbiAgICApWzBdO1xyXG4gICAgaWYgKGhpZ2hlc3RFbmVyZ3lFdmVudCkge1xyXG4gICAgICBrV2hOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQudG90YWxFeGNlc3NLd2g7XHJcbiAgICAgIGtXTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50Lm1heEV4Y2Vzc0t3O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ1A5NScpIHtcclxuICAgIGlmIChldmVudHMubGVuZ3RoIDwgMjApIHtcclxuICAgICAgY29uc3QgaGlnaGVzdEVuZXJneUV2ZW50ID0gWy4uLmV2ZW50c10uc29ydChcclxuICAgICAgICAoYSwgYikgPT4gYi50b3RhbEV4Y2Vzc0t3aCAtIGEudG90YWxFeGNlc3NLd2hcclxuICAgICAgKVswXTtcclxuICAgICAgaWYgKGhpZ2hlc3RFbmVyZ3lFdmVudCkge1xyXG4gICAgICAgIGtXaE5lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC50b3RhbEV4Y2Vzc0t3aDtcclxuICAgICAgICBrV05lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC5tYXhFeGNlc3NLdztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAga1doTmVlZGVkUmF3ID0gcGVyY2VudGlsZShcclxuICAgICAgICBldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQudG90YWxFeGNlc3NLd2gpLFxyXG4gICAgICAgIDk1XHJcbiAgICAgICk7XHJcbiAgICAgIGtXTmVlZGVkUmF3ID0gcGVyY2VudGlsZShcclxuICAgICAgICBldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQubWF4RXhjZXNzS3cpLFxyXG4gICAgICAgIDk1XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAobWV0aG9kID09PSAnRlVMTF9DT1ZFUkFHRScpIHtcclxuICAgIGNvbnN0IGJ5RGF5ID0gbmV3IE1hcDxzdHJpbmcsIFByb2Nlc3NlZEludGVydmFsW10+KCk7XHJcbiAgICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcclxuICAgICAgY29uc3QgZGF5ID0gaW50ZXJ2YWwudGltZXN0YW1wLnNsaWNlKDAsIDEwKTtcclxuICAgICAgY29uc3QgbGlzdCA9IGJ5RGF5LmdldChkYXkpID8/IFtdO1xyXG4gICAgICBsaXN0LnB1c2goaW50ZXJ2YWwpO1xyXG4gICAgICBieURheS5zZXQoZGF5LCBsaXN0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBtYXhEYXlFbmVyZ3kgPSAwO1xyXG4gICAgbGV0IG1heERheVBlYWsgPSAwO1xyXG5cclxuICAgIGJ5RGF5LmZvckVhY2goKGRheUludGVydmFscykgPT4ge1xyXG4gICAgICBjb25zdCBkYXlFbmVyZ3kgPSBkYXlJbnRlcnZhbHMucmVkdWNlKChzdW0sIGludGVydmFsKSA9PiBzdW0gKyBpbnRlcnZhbC5leGNlc3NLd2gsIDApO1xyXG4gICAgICBpZiAoZGF5RW5lcmd5ID4gbWF4RGF5RW5lcmd5KSB7XHJcbiAgICAgICAgbWF4RGF5RW5lcmd5ID0gZGF5RW5lcmd5O1xyXG4gICAgICAgIG1heERheVBlYWsgPSBNYXRoLm1heCguLi5kYXlJbnRlcnZhbHMubWFwKChpbnRlcnZhbCkgPT4gaW50ZXJ2YWwuZXhjZXNzS3cpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAga1doTmVlZGVkUmF3ID0gbWF4RGF5RW5lcmd5O1xyXG4gICAga1dOZWVkZWRSYXcgPSBtYXhEYXlQZWFrO1xyXG4gIH1cclxuXHJcbiAga1doTmVlZGVkUmF3ICo9IGNvbXBsaWFuY2U7XHJcbiAga1dOZWVkZWRSYXcgKj0gY29tcGxpYW5jZTtcclxuXHJcbiAgY29uc3Qga1doTmVlZGVkID0gKGtXaE5lZWRlZFJhdyAvIGVmZmljaWVuY3kpICogc2FmZXR5RmFjdG9yO1xyXG4gIGNvbnN0IGtXTmVlZGVkID0ga1dOZWVkZWRSYXcgKiBzYWZldHlGYWN0b3I7XHJcblxyXG4gIGNvbnN0IHsgcmVjb21tZW5kZWRQcm9kdWN0LCBhbHRlcm5hdGl2ZVByb2R1Y3QgfSA9IHNlbGVjdE1pbmltdW1Db3N0QmF0dGVyeU9wdGlvbnMoa1doTmVlZGVkKTtcblxyXG4gIHJldHVybiB7XHJcbiAgICBrV2hOZWVkZWRSYXcsXHJcbiAgICBrV05lZWRlZFJhdyxcclxuICAgIGtXaE5lZWRlZCxcclxuICAgIGtXTmVlZGVkLFxyXG4gICAgcmVjb21tZW5kZWRQcm9kdWN0LFxyXG4gICAgYWx0ZXJuYXRpdmVQcm9kdWN0XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGF0YVF1YWxpdHlSZXBvcnQoaW50ZXJ2YWxzOiBJbnRlcnZhbFJlY29yZFtdKTogRGF0YVF1YWxpdHlSZXBvcnQge1xuICBpZiAoaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcm93czogMCxcclxuICAgICAgc3RhcnREYXRlOiBudWxsLFxyXG4gICAgICBlbmREYXRlOiBudWxsLFxyXG4gICAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQ6IDAsXHJcbiAgICAgIGR1cGxpY2F0ZUNvdW50OiAwLFxyXG4gICAgICBub24xNU1pbkludGVydmFsczogMCxcclxuICAgICAgd2FybmluZ3M6IFsnTm8gcm93cyBmb3VuZCBpbiBkYXRhc2V0LiddXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdGltZXN0YW1wcyA9IGludGVydmFsc1xyXG4gICAgLm1hcCgocm93KSA9PiBuZXcgRGF0ZShyb3cudGltZXN0YW1wKSlcclxuICAgIC5maWx0ZXIoKGRhdGUpID0+ICFOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKVxyXG4gICAgLnNvcnQoKGEsIGIpID0+IGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCkpO1xyXG5cclxuICBjb25zdCBkdXBsaWNhdGVDb3VudCA9IHRpbWVzdGFtcHMubGVuZ3RoIC0gbmV3IFNldCh0aW1lc3RhbXBzLm1hcCgoZCkgPT4gZC50b0lTT1N0cmluZygpKSkuc2l6ZTtcbiAgbGV0IG5vbjE1TWluSW50ZXJ2YWxzID0gMDtcbiAgbGV0IG1pc3NpbmdJbnRlcnZhbHNDb3VudCA9IDA7XG4gIGNvbnN0IEVQUyA9IDAuMDE7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aW1lc3RhbXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZGlmZk1pbnV0ZXMgPSAodGltZXN0YW1wc1tpXS5nZXRUaW1lKCkgLSB0aW1lc3RhbXBzW2kgLSAxXS5nZXRUaW1lKCkpIC8gNjAwMDA7XG4gICAgaWYgKE1hdGguYWJzKGRpZmZNaW51dGVzIC0gMTUpID4gRVBTKSB7XG4gICAgICBub24xNU1pbkludGVydmFscyArPSAxO1xuICAgICAgaWYgKGRpZmZNaW51dGVzID4gMTUgKyBFUFMpIHtcbiAgICAgICAgbWlzc2luZ0ludGVydmFsc0NvdW50ICs9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoZGlmZk1pbnV0ZXMgLyAxNSkgLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxyXG4gIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGlmIChkdXBsaWNhdGVDb3VudCA+IDApIHdhcm5pbmdzLnB1c2goYERldGVjdGVkICR7ZHVwbGljYXRlQ291bnR9IGR1cGxpY2F0ZSB0aW1lc3RhbXBzLmApO1xyXG4gIGlmIChub24xNU1pbkludGVydmFscyA+IDApIHtcclxuICAgIHdhcm5pbmdzLnB1c2goYERldGVjdGVkICR7bm9uMTVNaW5JbnRlcnZhbHN9IG5vbi0xNS1taW51dGUgaW50ZXJ2YWwgdHJhbnNpdGlvbnMuYCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcm93czogaW50ZXJ2YWxzLmxlbmd0aCxcclxuICAgIHN0YXJ0RGF0ZTogdGltZXN0YW1wc1swXT8udG9JU09TdHJpbmcoKSA/PyBudWxsLFxyXG4gICAgZW5kRGF0ZTogdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdPy50b0lTT1N0cmluZygpID8/IG51bGwsXHJcbiAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQsXHJcbiAgICBkdXBsaWNhdGVDb3VudCxcclxuICAgIG5vbjE1TWluSW50ZXJ2YWxzLFxyXG4gICAgd2FybmluZ3NcclxuICB9O1xyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWF4T2JzZXJ2ZWQoaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdKToge1xuICBtYXhPYnNlcnZlZEt3OiBudW1iZXI7XG4gIG1heE9ic2VydmVkVGltZXN0YW1wOiBzdHJpbmcgfCBudWxsO1xufSB7XG4gIGlmIChpbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heE9ic2VydmVkS3c6IDAsXG4gICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcDogbnVsbFxuICAgIH07XG4gIH1cblxuICBsZXQgbWF4T2JzZXJ2ZWRLdyA9IC0xO1xuICBsZXQgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGludGVydmFsLmNvbnN1bXB0aW9uS3cgPiBtYXhPYnNlcnZlZEt3IHx8XG4gICAgICAoaW50ZXJ2YWwuY29uc3VtcHRpb25LdyA9PT0gbWF4T2JzZXJ2ZWRLdyAmJlxuICAgICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcCAhPT0gbnVsbCAmJlxuICAgICAgICBpbnRlcnZhbC50aW1lc3RhbXAgPCBtYXhPYnNlcnZlZFRpbWVzdGFtcClcbiAgICApIHtcbiAgICAgIG1heE9ic2VydmVkS3cgPSBpbnRlcnZhbC5jb25zdW1wdGlvbkt3O1xuICAgICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXAgPSBpbnRlcnZhbC50aW1lc3RhbXA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIG1heE9ic2VydmVkS3csXG4gICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFRvcEV4Y2VlZGVkSW50ZXJ2YWxzKFxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10sXG4gIGRheTogc3RyaW5nLFxuICBsaW1pdCA9IDIwXG4pOiBFeGNlZWRlZEludGVydmFsW10ge1xuICByZXR1cm4gaW50ZXJ2YWxzXG4gICAgLmZpbHRlcigoaW50ZXJ2YWwpID0+IGdldExvY2FsRGF5SXNvKGludGVydmFsLnRpbWVzdGFtcCkgPT09IGRheSAmJiBpbnRlcnZhbC5leGNlc3NLdyA+IDApXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuZXhjZXNzS3cgLSBhLmV4Y2Vzc0t3IHx8IGEudGltZXN0YW1wLmxvY2FsZUNvbXBhcmUoYi50aW1lc3RhbXApKVxuICAgIC5zbGljZSgwLCBsaW1pdClcbiAgICAubWFwKChpbnRlcnZhbCkgPT4gKHtcbiAgICAgIHRpbWVzdGFtcDogaW50ZXJ2YWwudGltZXN0YW1wLFxuICAgICAgY29uc3VtcHRpb25fa1c6IGludGVydmFsLmNvbnN1bXB0aW9uS3csXG4gICAgICBleGNlc3Nfa1c6IGludGVydmFsLmV4Y2Vzc0t3XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXlQcm9maWxlKFxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10sXG4gIGRheUlzbzogc3RyaW5nLFxuICBpbnRlcnZhbE1pbnV0ZXMgPSAxNSxcbiAgdGltZVpvbmUgPSAnRXVyb3BlL0Ftc3RlcmRhbSdcbik6IERheVByb2ZpbGVQb2ludFtdIHtcbiAgY29uc3QgZnVsbERheVNlcmllcyA9IGJ1aWxkRGF5S3dTZXJpZXMoXG4gICAgaW50ZXJ2YWxzLm1hcCgoaW50ZXJ2YWwpID0+ICh7XG4gICAgICB0aW1lc3RhbXA6IGludGVydmFsLnRpbWVzdGFtcCxcbiAgICAgIGNvbnN1bXB0aW9uS3c6IGludGVydmFsLmNvbnN1bXB0aW9uS3dcbiAgICB9KSksXG4gICAgZGF5SXNvLFxuICAgIGludGVydmFsTWludXRlcyxcbiAgICB0aW1lWm9uZVxuICApO1xuXG4gIHJldHVybiBmdWxsRGF5U2VyaWVzLm1hcCgoc2xvdCkgPT4gKHtcbiAgICB0aW1lc3RhbXBMYWJlbDogc2xvdC50aW1lTGFiZWwsXG4gICAgdGltZXN0YW1wSXNvOiBzbG90LnRpbWVzdGFtcElzbyxcbiAgICBvYnNlcnZlZEt3OiBzbG90LmNvbnN1bXB0aW9uS3dcbiAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXlLd1NlcmllcyhcbiAgaW50ZXJ2YWxzOiB7IHRpbWVzdGFtcDogc3RyaW5nOyBjb25zdW1wdGlvbkt3OiBudW1iZXIgfVtdLFxuICBkYXlJc286IHN0cmluZyxcbiAgaW50ZXJ2YWxNaW51dGVzID0gMTUsXG4gIHRpbWVab25lID0gJ0V1cm9wZS9BbXN0ZXJkYW0nXG4pOiBEYXlLd1Nlcmllc1BvaW50W10ge1xuICBpZiAoIWRheUlzbyB8fCBpbnRlcnZhbE1pbnV0ZXMgPD0gMCkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IFt5ZWFyLCBtb250aCwgZGF5XSA9IGRheUlzby5zcGxpdCgnLScpLm1hcChOdW1iZXIpO1xuICBjb25zdCBkYXlTdGFydExvY2FsID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIDAsIDAsIDAsIDApO1xuICBpZiAoTnVtYmVyLmlzTmFOKGRheVN0YXJ0TG9jYWwuZ2V0VGltZSgpKSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IHNsb3RzUGVyRGF5ID0gTWF0aC5mbG9vcigoMjQgKiA2MCkgLyBpbnRlcnZhbE1pbnV0ZXMpO1xuICBjb25zdCBwcm9maWxlID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogc2xvdHNQZXJEYXkgfSwgKF8sIGluZGV4KTogRGF5S3dTZXJpZXNQb2ludCA9PiB7XG4gICAgY29uc3QgbWludXRlcyA9IGluZGV4ICogaW50ZXJ2YWxNaW51dGVzO1xuICAgIGNvbnN0IGhvdXIgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgY29uc3QgbWludXRlID0gbWludXRlcyAlIDYwO1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lTGFiZWw6IGAke1N0cmluZyhob3VyKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyhtaW51dGUpLnBhZFN0YXJ0KDIsICcwJyl9YCxcbiAgICAgIHRpbWVzdGFtcElzbzogbmV3IERhdGUoZGF5U3RhcnRMb2NhbC5nZXRUaW1lKCkgKyBtaW51dGVzICogNjBfMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgY29uc3VtcHRpb25LdzogMFxuICAgIH07XG4gIH0pO1xuXG4gIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xuICAgIGlmIChnZXRMb2NhbERheUlzbyhpbnRlcnZhbC50aW1lc3RhbXAsIHRpbWVab25lKSAhPT0gZGF5SXNvKSByZXR1cm47XG5cbiAgICBjb25zdCBkdCA9IHBhcnNlVGltZXN0YW1wKGludGVydmFsLnRpbWVzdGFtcCk7XG4gICAgaWYgKE51bWJlci5pc05hTihkdC5nZXRUaW1lKCkpKSByZXR1cm47XG4gICAgY29uc3QgeyBob3VyLCBtaW51dGUgfSA9IGdldExvY2FsSG91ck1pbnV0ZShkdCwgdGltZVpvbmUpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGhvdXIpIHx8ICFOdW1iZXIuaXNGaW5pdGUobWludXRlKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgbWludXRlT2ZEYXkgPSBob3VyICogNjAgKyBtaW51dGU7XG4gICAgY29uc3Qgc2xvdEluZGV4ID0gTWF0aC5mbG9vcihtaW51dGVPZkRheSAvIGludGVydmFsTWludXRlcyk7XG4gICAgaWYgKHNsb3RJbmRleCA8IDAgfHwgc2xvdEluZGV4ID49IHNsb3RzUGVyRGF5KSByZXR1cm47XG5cbiAgICBwcm9maWxlW3Nsb3RJbmRleF0uY29uc3VtcHRpb25LdyA9IE1hdGgubWF4KHByb2ZpbGVbc2xvdEluZGV4XS5jb25zdW1wdGlvbkt3LCBpbnRlcnZhbC5jb25zdW1wdGlvbkt3KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByb2ZpbGU7XG59XG4iXSwibmFtZXMiOlsiZ2V0TG9jYWxEYXlJc28iLCJnZXRMb2NhbEhvdXJNaW51dGUiLCJwYXJzZVRpbWVzdGFtcCIsIkJBVFRFUllfT1BUSU9OUyIsImxhYmVsIiwiY2FwYWNpdHlLd2giLCJtb2R1bGFyIiwidW5pdFByaWNlRXVyIiwicm91bmRDdXJyZW5jeSIsInZhbHVlIiwiTWF0aCIsInJvdW5kIiwidG9CYXR0ZXJ5UHJvZHVjdCIsImNhbmRpZGF0ZSIsInRvdGFsUHJpY2VFdXIiLCJ0b3RhbENhcGFjaXR5S3doIiwidW5pdENhcGFjaXR5S3doIiwiY291bnQiLCJicmVha2Rvd24iLCJ0eXBlIiwic2VsZWN0TWluaW11bUNvc3RCYXR0ZXJ5T3B0aW9ucyIsInJlcXVpcmVkS3doIiwibm9ybWFsaXplZFJlcXVpcmVkIiwibWF4IiwiY2FuZGlkYXRlcyIsImZvckVhY2giLCJvcHRpb24iLCJtYXhDb3VudCIsImNlaWwiLCJwdXNoIiwib3ZlckNhcGFjaXR5S3doIiwic29ydGVkIiwic29ydCIsImEiLCJiIiwicmVjb21tZW5kZWRQcm9kdWN0IiwiYWx0ZXJuYXRpdmVQcm9kdWN0IiwicHJvY2Vzc0ludGVydmFscyIsInJvd3MiLCJjb250cmFjdGVkUG93ZXJLdyIsIm1hcCIsInJvdyIsInRpbWVzdGFtcCIsIm5vcm1hbGl6ZWRUaW1lc3RhbXAiLCJOdW1iZXIiLCJpc05hTiIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsImNvbnN1bXB0aW9uS3ciLCJjb25zdW1wdGlvbkt3aCIsImV4Y2Vzc0t3IiwiZXhjZXNzS3doIiwiZ3JvdXBQZWFrRXZlbnRzIiwiaW50ZXJ2YWxzIiwiZXZlbnRzIiwiY3VycmVudCIsImludGVydmFsIiwiaW5kZXgiLCJwZWFrVGltZXN0YW1wIiwiZHVyYXRpb25JbnRlcnZhbHMiLCJtYXhFeGNlc3NLdyIsInRvdGFsRXhjZXNzS3doIiwiaW50ZXJ2YWxJbmRleGVzIiwiY291bnRFeGNlZWRhbmNlSW50ZXJ2YWxzIiwicmVkdWNlIiwic3VtIiwiZXZlbnQiLCJwZXJjZW50aWxlIiwidmFsdWVzIiwicCIsImxlbmd0aCIsImlkeCIsIm1pbiIsImNvbXB1dGVTaXppbmciLCJwYXJhbXMiLCJtZXRob2QiLCJjb21wbGlhbmNlIiwic2FmZXR5RmFjdG9yIiwiZWZmaWNpZW5jeSIsImtXaE5lZWRlZFJhdyIsImtXTmVlZGVkUmF3IiwiaGlnaGVzdEVuZXJneUV2ZW50IiwiYnlEYXkiLCJNYXAiLCJkYXkiLCJzbGljZSIsImxpc3QiLCJnZXQiLCJzZXQiLCJtYXhEYXlFbmVyZ3kiLCJtYXhEYXlQZWFrIiwiZGF5SW50ZXJ2YWxzIiwiZGF5RW5lcmd5Iiwia1doTmVlZGVkIiwia1dOZWVkZWQiLCJidWlsZERhdGFRdWFsaXR5UmVwb3J0IiwidGltZXN0YW1wcyIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJtaXNzaW5nSW50ZXJ2YWxzQ291bnQiLCJkdXBsaWNhdGVDb3VudCIsIm5vbjE1TWluSW50ZXJ2YWxzIiwid2FybmluZ3MiLCJEYXRlIiwiZmlsdGVyIiwiZGF0ZSIsIlNldCIsImQiLCJzaXplIiwiRVBTIiwiaSIsImRpZmZNaW51dGVzIiwiYWJzIiwiZmluZE1heE9ic2VydmVkIiwibWF4T2JzZXJ2ZWRLdyIsIm1heE9ic2VydmVkVGltZXN0YW1wIiwic2VsZWN0VG9wRXhjZWVkZWRJbnRlcnZhbHMiLCJsaW1pdCIsImxvY2FsZUNvbXBhcmUiLCJjb25zdW1wdGlvbl9rVyIsImV4Y2Vzc19rVyIsImJ1aWxkRGF5UHJvZmlsZSIsImRheUlzbyIsImludGVydmFsTWludXRlcyIsInRpbWVab25lIiwiZnVsbERheVNlcmllcyIsImJ1aWxkRGF5S3dTZXJpZXMiLCJzbG90IiwidGltZXN0YW1wTGFiZWwiLCJ0aW1lTGFiZWwiLCJ0aW1lc3RhbXBJc28iLCJvYnNlcnZlZEt3IiwieWVhciIsIm1vbnRoIiwic3BsaXQiLCJkYXlTdGFydExvY2FsIiwic2xvdHNQZXJEYXkiLCJmbG9vciIsInByb2ZpbGUiLCJBcnJheSIsImZyb20iLCJfIiwibWludXRlcyIsImhvdXIiLCJtaW51dGUiLCJTdHJpbmciLCJwYWRTdGFydCIsImR0IiwiaXNGaW5pdGUiLCJtaW51dGVPZkRheSIsInNsb3RJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});