"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BATTERY_OPTIONS: function() { return /* binding */ BATTERY_OPTIONS; },\n/* harmony export */   buildDataQualityReport: function() { return /* binding */ buildDataQualityReport; },\n/* harmony export */   buildDayProfile: function() { return /* binding */ buildDayProfile; },\n/* harmony export */   computeSizing: function() { return /* binding */ computeSizing; },\n/* harmony export */   findMaxObserved: function() { return /* binding */ findMaxObserved; },\n/* harmony export */   groupPeakEvents: function() { return /* binding */ groupPeakEvents; },\n/* harmony export */   processIntervals: function() { return /* binding */ processIntervals; },\n/* harmony export */   selectTopExceededIntervals: function() { return /* binding */ selectTopExceededIntervals; }\n/* harmony export */ });\n/* harmony import */ var _datetime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime */ \"(app-pages-browser)/./lib/datetime.ts\");\n\nconst BATTERY_OPTIONS = [\n    {\n        label: \"WattsNext ESS Cabinet 64 kWh\",\n        capacityKwh: 64\n    },\n    {\n        label: \"WattsNext ESS Cabinet 96 kWh\",\n        capacityKwh: 96\n    },\n    {\n        label: \"ESS All-in-one Cabinet 261 kWh\",\n        capacityKwh: 261\n    },\n    {\n        label: \"WattsNext All-in-one Container 2.09 MWh\",\n        capacityKwh: 2090\n    },\n    {\n        label: \"WattsNext All in-one Container 5.01 MWh\",\n        capacityKwh: 5010\n    }\n];\nfunction processIntervals(rows, contractedPowerKw) {\n    return rows.map((row)=>{\n        const timestamp = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(row.timestamp);\n        const normalizedTimestamp = Number.isNaN(timestamp.getTime()) ? row.timestamp : timestamp.toISOString();\n        const consumptionKw = row.consumptionKwh / 0.25;\n        const excessKw = Math.max(0, consumptionKw - contractedPowerKw);\n        return {\n            ...row,\n            timestamp: normalizedTimestamp,\n            consumptionKw,\n            excessKw,\n            excessKwh: excessKw * 0.25\n        };\n    });\n}\nfunction groupPeakEvents(intervals) {\n    const events = [];\n    let current = null;\n    intervals.forEach((interval, index)=>{\n        if (interval.excessKw > 0) {\n            if (!current) {\n                current = {\n                    peakTimestamp: interval.timestamp,\n                    durationIntervals: 0,\n                    maxExcessKw: 0,\n                    totalExcessKwh: 0,\n                    intervalIndexes: []\n                };\n            }\n            current.durationIntervals += 1;\n            if (interval.excessKw > current.maxExcessKw || interval.excessKw === current.maxExcessKw && interval.timestamp < current.peakTimestamp) {\n                current.maxExcessKw = interval.excessKw;\n                current.peakTimestamp = interval.timestamp;\n            }\n            current.totalExcessKwh += interval.excessKwh;\n            current.intervalIndexes.push(index);\n        } else if (current) {\n            events.push(current);\n            current = null;\n        }\n    });\n    if (current) {\n        events.push(current);\n    }\n    return events;\n}\nfunction percentile(values, p) {\n    if (values.length === 0) return 0;\n    const sorted = [\n        ...values\n    ].sort((a, b)=>a - b);\n    const idx = Math.ceil(p / 100 * sorted.length) - 1;\n    return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\n}\nfunction computeSizing(params) {\n    const { intervals, events, method, compliance, safetyFactor, efficiency } = params;\n    let kWhNeededRaw = 0;\n    let kWNeededRaw = 0;\n    if (method === \"MAX_PEAK\") {\n        const highestEnergyEvent = [\n            ...events\n        ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n        if (highestEnergyEvent) {\n            kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n            kWNeededRaw = highestEnergyEvent.maxExcessKw;\n        }\n    }\n    if (method === \"P95\") {\n        if (events.length < 20) {\n            const highestEnergyEvent = [\n                ...events\n            ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n            if (highestEnergyEvent) {\n                kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n                kWNeededRaw = highestEnergyEvent.maxExcessKw;\n            }\n        } else {\n            kWhNeededRaw = percentile(events.map((event)=>event.totalExcessKwh), 95);\n            kWNeededRaw = percentile(events.map((event)=>event.maxExcessKw), 95);\n        }\n    }\n    if (method === \"FULL_COVERAGE\") {\n        const byDay = new Map();\n        intervals.forEach((interval)=>{\n            const day = interval.timestamp.slice(0, 10);\n            var _byDay_get;\n            const list = (_byDay_get = byDay.get(day)) !== null && _byDay_get !== void 0 ? _byDay_get : [];\n            list.push(interval);\n            byDay.set(day, list);\n        });\n        let maxDayEnergy = 0;\n        let maxDayPeak = 0;\n        byDay.forEach((dayIntervals)=>{\n            const dayEnergy = dayIntervals.reduce((sum, interval)=>sum + interval.excessKwh, 0);\n            if (dayEnergy > maxDayEnergy) {\n                maxDayEnergy = dayEnergy;\n                maxDayPeak = Math.max(...dayIntervals.map((interval)=>interval.excessKw));\n            }\n        });\n        kWhNeededRaw = maxDayEnergy;\n        kWNeededRaw = maxDayPeak;\n    }\n    kWhNeededRaw *= compliance;\n    kWNeededRaw *= compliance;\n    const kWhNeeded = kWhNeededRaw / efficiency * safetyFactor;\n    const kWNeeded = kWNeededRaw * safetyFactor;\n    var _BATTERY_OPTIONS_find;\n    const recommendedProduct = (_BATTERY_OPTIONS_find = BATTERY_OPTIONS.find((option)=>kWhNeeded <= option.capacityKwh)) !== null && _BATTERY_OPTIONS_find !== void 0 ? _BATTERY_OPTIONS_find : BATTERY_OPTIONS[BATTERY_OPTIONS.length - 1];\n    const recommendedIndex = BATTERY_OPTIONS.findIndex((option)=>option.capacityKwh === recommendedProduct.capacityKwh);\n    var _BATTERY_OPTIONS_;\n    const alternativeProduct = (_BATTERY_OPTIONS_ = BATTERY_OPTIONS[recommendedIndex + 1]) !== null && _BATTERY_OPTIONS_ !== void 0 ? _BATTERY_OPTIONS_ : null;\n    return {\n        kWhNeededRaw,\n        kWNeededRaw,\n        kWhNeeded,\n        kWNeeded,\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction buildDataQualityReport(intervals) {\n    var _timestamps_, _timestamps_1;\n    if (intervals.length === 0) {\n        return {\n            rows: 0,\n            startDate: null,\n            endDate: null,\n            missingIntervalsCount: 0,\n            duplicateCount: 0,\n            non15MinIntervals: 0,\n            warnings: [\n                \"No rows found in dataset.\"\n            ]\n        };\n    }\n    const timestamps = intervals.map((row)=>new Date(row.timestamp)).filter((date)=>!Number.isNaN(date.getTime())).sort((a, b)=>a.getTime() - b.getTime());\n    const duplicateCount = timestamps.length - new Set(timestamps.map((d)=>d.toISOString())).size;\n    let non15MinIntervals = 0;\n    let missingIntervalsCount = 0;\n    for(let i = 1; i < timestamps.length; i += 1){\n        const diffMinutes = (timestamps[i].getTime() - timestamps[i - 1].getTime()) / 60000;\n        if (diffMinutes !== 15) {\n            non15MinIntervals += 1;\n            if (diffMinutes > 15) {\n                missingIntervalsCount += Math.max(0, Math.round(diffMinutes / 15) - 1);\n            }\n        }\n    }\n    const warnings = [];\n    if (duplicateCount > 0) warnings.push(\"Detected \".concat(duplicateCount, \" duplicate timestamps.\"));\n    if (non15MinIntervals > 0) {\n        warnings.push(\"Detected \".concat(non15MinIntervals, \" non-15-minute interval transitions.\"));\n    }\n    var _timestamps__toISOString, _timestamps__toISOString1;\n    return {\n        rows: intervals.length,\n        startDate: (_timestamps__toISOString = (_timestamps_ = timestamps[0]) === null || _timestamps_ === void 0 ? void 0 : _timestamps_.toISOString()) !== null && _timestamps__toISOString !== void 0 ? _timestamps__toISOString : null,\n        endDate: (_timestamps__toISOString1 = (_timestamps_1 = timestamps[timestamps.length - 1]) === null || _timestamps_1 === void 0 ? void 0 : _timestamps_1.toISOString()) !== null && _timestamps__toISOString1 !== void 0 ? _timestamps__toISOString1 : null,\n        missingIntervalsCount,\n        duplicateCount,\n        non15MinIntervals,\n        warnings\n    };\n}\nfunction findMaxObserved(intervals) {\n    if (intervals.length === 0) {\n        return {\n            maxObservedKw: 0,\n            maxObservedTimestamp: null\n        };\n    }\n    let maxObservedKw = -1;\n    let maxObservedTimestamp = null;\n    intervals.forEach((interval)=>{\n        if (interval.consumptionKw > maxObservedKw || interval.consumptionKw === maxObservedKw && maxObservedTimestamp !== null && interval.timestamp < maxObservedTimestamp) {\n            maxObservedKw = interval.consumptionKw;\n            maxObservedTimestamp = interval.timestamp;\n        }\n    });\n    return {\n        maxObservedKw,\n        maxObservedTimestamp\n    };\n}\nfunction selectTopExceededIntervals(intervals, day) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;\n    return intervals.filter((interval)=>(0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp) === day && interval.excessKw > 0).sort((a, b)=>b.excessKw - a.excessKw || a.timestamp.localeCompare(b.timestamp)).slice(0, limit).map((interval)=>({\n            timestamp: interval.timestamp,\n            consumption_kW: interval.consumptionKw,\n            excess_kW: interval.excessKw\n        }));\n}\nfunction buildDayProfile(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    if (!dayIso || intervalMinutes <= 0) return [];\n    const [year, month, day] = dayIso.split(\"-\").map(Number);\n    const dayStartLocal = new Date(year, month - 1, day, 0, 0, 0, 0);\n    if (Number.isNaN(dayStartLocal.getTime())) return [];\n    const slotsPerDay = Math.floor(24 * 60 / intervalMinutes);\n    const profile = Array.from({\n        length: slotsPerDay\n    }, (_, index)=>{\n        const minutes = index * intervalMinutes;\n        const hour = Math.floor(minutes / 60);\n        const minute = minutes % 60;\n        return {\n            timestampLabel: \"\".concat(String(hour).padStart(2, \"0\"), \":\").concat(String(minute).padStart(2, \"0\")),\n            timestampIso: new Date(dayStartLocal.getTime() + minutes * 60000).toISOString(),\n            observedKw: 0\n        };\n    });\n    intervals.forEach((interval)=>{\n        if ((0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp, timeZone) !== dayIso) return;\n        const dt = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(interval.timestamp);\n        if (Number.isNaN(dt.getTime())) return;\n        const { hour, minute } = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalHourMinute)(dt, timeZone);\n        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return;\n        const minuteOfDay = hour * 60 + minute;\n        const slotIndex = Math.floor(minuteOfDay / intervalMinutes);\n        if (slotIndex < 0 || slotIndex >= slotsPerDay) return;\n        profile[slotIndex].observedKw = Math.max(profile[slotIndex].observedKw, interval.consumptionKw);\n    });\n    return profile;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUMsQ0FBQ0M7UUFDakIsSUFBSTVCLHlEQUFjQSxDQUFDNEIsU0FBU2pCLFNBQVMsRUFBRStGLGNBQWNGLFFBQVE7UUFFN0QsTUFBTXFCLEtBQUszSCx5REFBY0EsQ0FBQzBCLFNBQVNqQixTQUFTO1FBQzVDLElBQUlFLE9BQU9DLEtBQUssQ0FBQytHLEdBQUc5RyxPQUFPLEtBQUs7UUFDaEMsTUFBTSxFQUFFdUcsSUFBSSxFQUFFQyxNQUFNLEVBQUUsR0FBR3RILDZEQUFrQkEsQ0FBQzRILElBQUluQjtRQUNoRCxJQUFJLENBQUM3RixPQUFPaUgsUUFBUSxDQUFDUixTQUFTLENBQUN6RyxPQUFPaUgsUUFBUSxDQUFDUCxTQUFTO1FBRXhELE1BQU1RLGNBQWNULE9BQU8sS0FBS0M7UUFDaEMsTUFBTVMsWUFBWTVHLEtBQUs0RixLQUFLLENBQUNlLGNBQWN0QjtRQUMzQyxJQUFJdUIsWUFBWSxLQUFLQSxhQUFhakIsYUFBYTtRQUUvQ0UsT0FBTyxDQUFDZSxVQUFVLENBQUNKLFVBQVUsR0FBR3hHLEtBQUtDLEdBQUcsQ0FBQzRGLE9BQU8sQ0FBQ2UsVUFBVSxDQUFDSixVQUFVLEVBQUVoRyxTQUFTWCxhQUFhO0lBQ2hHO0lBRUEsT0FBT2dHO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2NhbGN1bGF0aW9ucy50cz8zZjc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExvY2FsRGF5SXNvLCBnZXRMb2NhbEhvdXJNaW51dGUsIHBhcnNlVGltZXN0YW1wIH0gZnJvbSAnLi9kYXRldGltZSc7XG5cbmV4cG9ydCB0eXBlIE1ldGhvZCA9ICdNQVhfUEVBSycgfCAnUDk1JyB8ICdGVUxMX0NPVkVSQUdFJztcblxyXG5leHBvcnQgaW50ZXJmYWNlIEludGVydmFsUmVjb3JkIHtcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxuICBjb25zdW1wdGlvbkt3aDogbnVtYmVyO1xyXG4gIGV4cG9ydEt3aD86IG51bWJlcjtcclxuICBwdkt3aD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzZWRJbnRlcnZhbCBleHRlbmRzIEludGVydmFsUmVjb3JkIHtcclxuICBjb25zdW1wdGlvbkt3OiBudW1iZXI7XHJcbiAgZXhjZXNzS3c6IG51bWJlcjtcclxuICBleGNlc3NLd2g6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQZWFrRXZlbnQge1xuICBwZWFrVGltZXN0YW1wOiBzdHJpbmc7XG4gIGR1cmF0aW9uSW50ZXJ2YWxzOiBudW1iZXI7XG4gIG1heEV4Y2Vzc0t3OiBudW1iZXI7XG4gIHRvdGFsRXhjZXNzS3doOiBudW1iZXI7XG4gIGludGVydmFsSW5kZXhlczogbnVtYmVyW107XG59XG5cclxuZXhwb3J0IGludGVyZmFjZSBEYXRhUXVhbGl0eVJlcG9ydCB7XHJcbiAgcm93czogbnVtYmVyO1xyXG4gIHN0YXJ0RGF0ZTogc3RyaW5nIHwgbnVsbDtcclxuICBlbmREYXRlOiBzdHJpbmcgfCBudWxsO1xyXG4gIG1pc3NpbmdJbnRlcnZhbHNDb3VudDogbnVtYmVyO1xyXG4gIGR1cGxpY2F0ZUNvdW50OiBudW1iZXI7XHJcbiAgbm9uMTVNaW5JbnRlcnZhbHM6IG51bWJlcjtcclxuICB3YXJuaW5nczogc3RyaW5nW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2l6aW5nUmVzdWx0IHtcclxuICBrV2hOZWVkZWRSYXc6IG51bWJlcjtcclxuICBrV05lZWRlZFJhdzogbnVtYmVyO1xyXG4gIGtXaE5lZWRlZDogbnVtYmVyO1xyXG4gIGtXTmVlZGVkOiBudW1iZXI7XHJcbiAgcmVjb21tZW5kZWRQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdDtcclxuICBhbHRlcm5hdGl2ZVByb2R1Y3Q6IEJhdHRlcnlQcm9kdWN0IHwgbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXR0ZXJ5UHJvZHVjdCB7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGNhcGFjaXR5S3doOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhjZWVkZWRJbnRlcnZhbCB7XG4gIHRpbWVzdGFtcDogc3RyaW5nO1xuICBjb25zdW1wdGlvbl9rVzogbnVtYmVyO1xuICBleGNlc3Nfa1c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXlQcm9maWxlUG9pbnQge1xuICB0aW1lc3RhbXBMYWJlbDogc3RyaW5nO1xuICB0aW1lc3RhbXBJc286IHN0cmluZztcbiAgb2JzZXJ2ZWRLdzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgQkFUVEVSWV9PUFRJT05TOiBCYXR0ZXJ5UHJvZHVjdFtdID0gW1xuICB7IGxhYmVsOiAnV2F0dHNOZXh0IEVTUyBDYWJpbmV0IDY0IGtXaCcsIGNhcGFjaXR5S3doOiA2NCB9LFxyXG4gIHsgbGFiZWw6ICdXYXR0c05leHQgRVNTIENhYmluZXQgOTYga1doJywgY2FwYWNpdHlLd2g6IDk2IH0sXHJcbiAgeyBsYWJlbDogJ0VTUyBBbGwtaW4tb25lIENhYmluZXQgMjYxIGtXaCcsIGNhcGFjaXR5S3doOiAyNjEgfSxcclxuICB7IGxhYmVsOiAnV2F0dHNOZXh0IEFsbC1pbi1vbmUgQ29udGFpbmVyIDIuMDkgTVdoJywgY2FwYWNpdHlLd2g6IDIwOTAgfSxcclxuICB7IGxhYmVsOiAnV2F0dHNOZXh0IEFsbCBpbi1vbmUgQ29udGFpbmVyIDUuMDEgTVdoJywgY2FwYWNpdHlLd2g6IDUwMTAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NJbnRlcnZhbHMoXG4gIHJvd3M6IEludGVydmFsUmVjb3JkW10sXG4gIGNvbnRyYWN0ZWRQb3dlckt3OiBudW1iZXJcbik6IFByb2Nlc3NlZEludGVydmFsW10ge1xuICByZXR1cm4gcm93cy5tYXAoKHJvdykgPT4ge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlVGltZXN0YW1wKHJvdy50aW1lc3RhbXApO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lc3RhbXAgPSBOdW1iZXIuaXNOYU4odGltZXN0YW1wLmdldFRpbWUoKSkgPyByb3cudGltZXN0YW1wIDogdGltZXN0YW1wLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgY29uc3VtcHRpb25LdyA9IHJvdy5jb25zdW1wdGlvbkt3aCAvIDAuMjU7XG4gICAgY29uc3QgZXhjZXNzS3cgPSBNYXRoLm1heCgwLCBjb25zdW1wdGlvbkt3IC0gY29udHJhY3RlZFBvd2VyS3cpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yb3csXG4gICAgICB0aW1lc3RhbXA6IG5vcm1hbGl6ZWRUaW1lc3RhbXAsXG4gICAgICBjb25zdW1wdGlvbkt3LFxuICAgICAgZXhjZXNzS3csXG4gICAgICBleGNlc3NLd2g6IGV4Y2Vzc0t3ICogMC4yNVxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBncm91cFBlYWtFdmVudHMoaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdKTogUGVha0V2ZW50W10ge1xuICBjb25zdCBldmVudHM6IFBlYWtFdmVudFtdID0gW107XG4gIGxldCBjdXJyZW50OiBQZWFrRXZlbnQgfCBudWxsID0gbnVsbDtcblxuICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwsIGluZGV4KSA9PiB7XG4gICAgaWYgKGludGVydmFsLmV4Y2Vzc0t3ID4gMCkge1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgICAgcGVha1RpbWVzdGFtcDogaW50ZXJ2YWwudGltZXN0YW1wLFxuICAgICAgICAgIGR1cmF0aW9uSW50ZXJ2YWxzOiAwLFxuICAgICAgICAgIG1heEV4Y2Vzc0t3OiAwLFxuICAgICAgICAgIHRvdGFsRXhjZXNzS3doOiAwLFxuICAgICAgICAgIGludGVydmFsSW5kZXhlczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQuZHVyYXRpb25JbnRlcnZhbHMgKz0gMTtcbiAgICAgIGlmIChcbiAgICAgICAgaW50ZXJ2YWwuZXhjZXNzS3cgPiBjdXJyZW50Lm1heEV4Y2Vzc0t3IHx8XG4gICAgICAgIChpbnRlcnZhbC5leGNlc3NLdyA9PT0gY3VycmVudC5tYXhFeGNlc3NLdyAmJiBpbnRlcnZhbC50aW1lc3RhbXAgPCBjdXJyZW50LnBlYWtUaW1lc3RhbXApXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudC5tYXhFeGNlc3NLdyA9IGludGVydmFsLmV4Y2Vzc0t3O1xuICAgICAgICBjdXJyZW50LnBlYWtUaW1lc3RhbXAgPSBpbnRlcnZhbC50aW1lc3RhbXA7XG4gICAgICB9XG4gICAgICBjdXJyZW50LnRvdGFsRXhjZXNzS3doICs9IGludGVydmFsLmV4Y2Vzc0t3aDtcbiAgICAgIGN1cnJlbnQuaW50ZXJ2YWxJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudCkge1xuICAgICAgZXZlbnRzLnB1c2goY3VycmVudCk7XHJcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpZiAoY3VycmVudCkge1xyXG4gICAgZXZlbnRzLnB1c2goY3VycmVudCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXZlbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwZXJjZW50aWxlKHZhbHVlczogbnVtYmVyW10sIHA6IG51bWJlcik6IG51bWJlciB7XHJcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xyXG4gIGNvbnN0IHNvcnRlZCA9IFsuLi52YWx1ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICBjb25zdCBpZHggPSBNYXRoLmNlaWwoKHAgLyAxMDApICogc29ydGVkLmxlbmd0aCkgLSAxO1xyXG4gIHJldHVybiBzb3J0ZWRbTWF0aC5tYXgoMCwgTWF0aC5taW4oaWR4LCBzb3J0ZWQubGVuZ3RoIC0gMSkpXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTaXppbmcocGFyYW1zOiB7XHJcbiAgaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdO1xyXG4gIGV2ZW50czogUGVha0V2ZW50W107XHJcbiAgbWV0aG9kOiBNZXRob2Q7XHJcbiAgY29tcGxpYW5jZTogbnVtYmVyO1xyXG4gIHNhZmV0eUZhY3RvcjogbnVtYmVyO1xyXG4gIGVmZmljaWVuY3k6IG51bWJlcjtcclxufSk6IFNpemluZ1Jlc3VsdCB7XHJcbiAgY29uc3QgeyBpbnRlcnZhbHMsIGV2ZW50cywgbWV0aG9kLCBjb21wbGlhbmNlLCBzYWZldHlGYWN0b3IsIGVmZmljaWVuY3kgfSA9IHBhcmFtcztcclxuXHJcbiAgbGV0IGtXaE5lZWRlZFJhdyA9IDA7XHJcbiAgbGV0IGtXTmVlZGVkUmF3ID0gMDtcclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ01BWF9QRUFLJykge1xyXG4gICAgY29uc3QgaGlnaGVzdEVuZXJneUV2ZW50ID0gWy4uLmV2ZW50c10uc29ydChcclxuICAgICAgKGEsIGIpID0+IGIudG90YWxFeGNlc3NLd2ggLSBhLnRvdGFsRXhjZXNzS3doXHJcbiAgICApWzBdO1xyXG4gICAgaWYgKGhpZ2hlc3RFbmVyZ3lFdmVudCkge1xyXG4gICAgICBrV2hOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQudG90YWxFeGNlc3NLd2g7XHJcbiAgICAgIGtXTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50Lm1heEV4Y2Vzc0t3O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ1A5NScpIHtcclxuICAgIGlmIChldmVudHMubGVuZ3RoIDwgMjApIHtcclxuICAgICAgY29uc3QgaGlnaGVzdEVuZXJneUV2ZW50ID0gWy4uLmV2ZW50c10uc29ydChcclxuICAgICAgICAoYSwgYikgPT4gYi50b3RhbEV4Y2Vzc0t3aCAtIGEudG90YWxFeGNlc3NLd2hcclxuICAgICAgKVswXTtcclxuICAgICAgaWYgKGhpZ2hlc3RFbmVyZ3lFdmVudCkge1xyXG4gICAgICAgIGtXaE5lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC50b3RhbEV4Y2Vzc0t3aDtcclxuICAgICAgICBrV05lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC5tYXhFeGNlc3NLdztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAga1doTmVlZGVkUmF3ID0gcGVyY2VudGlsZShcclxuICAgICAgICBldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQudG90YWxFeGNlc3NLd2gpLFxyXG4gICAgICAgIDk1XHJcbiAgICAgICk7XHJcbiAgICAgIGtXTmVlZGVkUmF3ID0gcGVyY2VudGlsZShcclxuICAgICAgICBldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQubWF4RXhjZXNzS3cpLFxyXG4gICAgICAgIDk1XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAobWV0aG9kID09PSAnRlVMTF9DT1ZFUkFHRScpIHtcclxuICAgIGNvbnN0IGJ5RGF5ID0gbmV3IE1hcDxzdHJpbmcsIFByb2Nlc3NlZEludGVydmFsW10+KCk7XHJcbiAgICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcclxuICAgICAgY29uc3QgZGF5ID0gaW50ZXJ2YWwudGltZXN0YW1wLnNsaWNlKDAsIDEwKTtcclxuICAgICAgY29uc3QgbGlzdCA9IGJ5RGF5LmdldChkYXkpID8/IFtdO1xyXG4gICAgICBsaXN0LnB1c2goaW50ZXJ2YWwpO1xyXG4gICAgICBieURheS5zZXQoZGF5LCBsaXN0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBtYXhEYXlFbmVyZ3kgPSAwO1xyXG4gICAgbGV0IG1heERheVBlYWsgPSAwO1xyXG5cclxuICAgIGJ5RGF5LmZvckVhY2goKGRheUludGVydmFscykgPT4ge1xyXG4gICAgICBjb25zdCBkYXlFbmVyZ3kgPSBkYXlJbnRlcnZhbHMucmVkdWNlKChzdW0sIGludGVydmFsKSA9PiBzdW0gKyBpbnRlcnZhbC5leGNlc3NLd2gsIDApO1xyXG4gICAgICBpZiAoZGF5RW5lcmd5ID4gbWF4RGF5RW5lcmd5KSB7XHJcbiAgICAgICAgbWF4RGF5RW5lcmd5ID0gZGF5RW5lcmd5O1xyXG4gICAgICAgIG1heERheVBlYWsgPSBNYXRoLm1heCguLi5kYXlJbnRlcnZhbHMubWFwKChpbnRlcnZhbCkgPT4gaW50ZXJ2YWwuZXhjZXNzS3cpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAga1doTmVlZGVkUmF3ID0gbWF4RGF5RW5lcmd5O1xyXG4gICAga1dOZWVkZWRSYXcgPSBtYXhEYXlQZWFrO1xyXG4gIH1cclxuXHJcbiAga1doTmVlZGVkUmF3ICo9IGNvbXBsaWFuY2U7XHJcbiAga1dOZWVkZWRSYXcgKj0gY29tcGxpYW5jZTtcclxuXHJcbiAgY29uc3Qga1doTmVlZGVkID0gKGtXaE5lZWRlZFJhdyAvIGVmZmljaWVuY3kpICogc2FmZXR5RmFjdG9yO1xyXG4gIGNvbnN0IGtXTmVlZGVkID0ga1dOZWVkZWRSYXcgKiBzYWZldHlGYWN0b3I7XHJcblxyXG4gIGNvbnN0IHJlY29tbWVuZGVkUHJvZHVjdCA9IEJBVFRFUllfT1BUSU9OUy5maW5kKChvcHRpb24pID0+IGtXaE5lZWRlZCA8PSBvcHRpb24uY2FwYWNpdHlLd2gpID8/XHJcbiAgICBCQVRURVJZX09QVElPTlNbQkFUVEVSWV9PUFRJT05TLmxlbmd0aCAtIDFdO1xyXG4gIGNvbnN0IHJlY29tbWVuZGVkSW5kZXggPSBCQVRURVJZX09QVElPTlMuZmluZEluZGV4KFxyXG4gICAgKG9wdGlvbikgPT4gb3B0aW9uLmNhcGFjaXR5S3doID09PSByZWNvbW1lbmRlZFByb2R1Y3QuY2FwYWNpdHlLd2hcclxuICApO1xyXG4gIGNvbnN0IGFsdGVybmF0aXZlUHJvZHVjdCA9IEJBVFRFUllfT1BUSU9OU1tyZWNvbW1lbmRlZEluZGV4ICsgMV0gPz8gbnVsbDtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGtXaE5lZWRlZFJhdyxcclxuICAgIGtXTmVlZGVkUmF3LFxyXG4gICAga1doTmVlZGVkLFxyXG4gICAga1dOZWVkZWQsXHJcbiAgICByZWNvbW1lbmRlZFByb2R1Y3QsXHJcbiAgICBhbHRlcm5hdGl2ZVByb2R1Y3RcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXRhUXVhbGl0eVJlcG9ydChpbnRlcnZhbHM6IEludGVydmFsUmVjb3JkW10pOiBEYXRhUXVhbGl0eVJlcG9ydCB7XG4gIGlmIChpbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb3dzOiAwLFxyXG4gICAgICBzdGFydERhdGU6IG51bGwsXHJcbiAgICAgIGVuZERhdGU6IG51bGwsXHJcbiAgICAgIG1pc3NpbmdJbnRlcnZhbHNDb3VudDogMCxcclxuICAgICAgZHVwbGljYXRlQ291bnQ6IDAsXHJcbiAgICAgIG5vbjE1TWluSW50ZXJ2YWxzOiAwLFxyXG4gICAgICB3YXJuaW5nczogWydObyByb3dzIGZvdW5kIGluIGRhdGFzZXQuJ11cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdCB0aW1lc3RhbXBzID0gaW50ZXJ2YWxzXHJcbiAgICAubWFwKChyb3cpID0+IG5ldyBEYXRlKHJvdy50aW1lc3RhbXApKVxyXG4gICAgLmZpbHRlcigoZGF0ZSkgPT4gIU51bWJlci5pc05hTihkYXRlLmdldFRpbWUoKSkpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKSk7XHJcblxyXG4gIGNvbnN0IGR1cGxpY2F0ZUNvdW50ID0gdGltZXN0YW1wcy5sZW5ndGggLSBuZXcgU2V0KHRpbWVzdGFtcHMubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpKS5zaXplO1xyXG4gIGxldCBub24xNU1pbkludGVydmFscyA9IDA7XHJcbiAgbGV0IG1pc3NpbmdJbnRlcnZhbHNDb3VudCA9IDA7XHJcblxyXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdGltZXN0YW1wcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgY29uc3QgZGlmZk1pbnV0ZXMgPSAodGltZXN0YW1wc1tpXS5nZXRUaW1lKCkgLSB0aW1lc3RhbXBzW2kgLSAxXS5nZXRUaW1lKCkpIC8gNjAwMDA7XHJcbiAgICBpZiAoZGlmZk1pbnV0ZXMgIT09IDE1KSB7XHJcbiAgICAgIG5vbjE1TWluSW50ZXJ2YWxzICs9IDE7XHJcbiAgICAgIGlmIChkaWZmTWludXRlcyA+IDE1KSB7XHJcbiAgICAgICAgbWlzc2luZ0ludGVydmFsc0NvdW50ICs9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoZGlmZk1pbnV0ZXMgLyAxNSkgLSAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XHJcbiAgaWYgKGR1cGxpY2F0ZUNvdW50ID4gMCkgd2FybmluZ3MucHVzaChgRGV0ZWN0ZWQgJHtkdXBsaWNhdGVDb3VudH0gZHVwbGljYXRlIHRpbWVzdGFtcHMuYCk7XHJcbiAgaWYgKG5vbjE1TWluSW50ZXJ2YWxzID4gMCkge1xyXG4gICAgd2FybmluZ3MucHVzaChgRGV0ZWN0ZWQgJHtub24xNU1pbkludGVydmFsc30gbm9uLTE1LW1pbnV0ZSBpbnRlcnZhbCB0cmFuc2l0aW9ucy5gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByb3dzOiBpbnRlcnZhbHMubGVuZ3RoLFxyXG4gICAgc3RhcnREYXRlOiB0aW1lc3RhbXBzWzBdPy50b0lTT1N0cmluZygpID8/IG51bGwsXHJcbiAgICBlbmREYXRlOiB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0/LnRvSVNPU3RyaW5nKCkgPz8gbnVsbCxcclxuICAgIG1pc3NpbmdJbnRlcnZhbHNDb3VudCxcclxuICAgIGR1cGxpY2F0ZUNvdW50LFxyXG4gICAgbm9uMTVNaW5JbnRlcnZhbHMsXHJcbiAgICB3YXJuaW5nc1xyXG4gIH07XHJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRNYXhPYnNlcnZlZChpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10pOiB7XG4gIG1heE9ic2VydmVkS3c6IG51bWJlcjtcbiAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IHN0cmluZyB8IG51bGw7XG59IHtcbiAgaWYgKGludGVydmFscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF4T2JzZXJ2ZWRLdzogMCxcbiAgICAgIG1heE9ic2VydmVkVGltZXN0YW1wOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGxldCBtYXhPYnNlcnZlZEt3ID0gLTE7XG4gIGxldCBtYXhPYnNlcnZlZFRpbWVzdGFtcDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgaWYgKFxuICAgICAgaW50ZXJ2YWwuY29uc3VtcHRpb25LdyA+IG1heE9ic2VydmVkS3cgfHxcbiAgICAgIChpbnRlcnZhbC5jb25zdW1wdGlvbkt3ID09PSBtYXhPYnNlcnZlZEt3ICYmXG4gICAgICAgIG1heE9ic2VydmVkVGltZXN0YW1wICE9PSBudWxsICYmXG4gICAgICAgIGludGVydmFsLnRpbWVzdGFtcCA8IG1heE9ic2VydmVkVGltZXN0YW1wKVxuICAgICkge1xuICAgICAgbWF4T2JzZXJ2ZWRLdyA9IGludGVydmFsLmNvbnN1bXB0aW9uS3c7XG4gICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcCA9IGludGVydmFsLnRpbWVzdGFtcDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbWF4T2JzZXJ2ZWRLdyxcbiAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0VG9wRXhjZWVkZWRJbnRlcnZhbHMoXG4gIGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSxcbiAgZGF5OiBzdHJpbmcsXG4gIGxpbWl0ID0gMjBcbik6IEV4Y2VlZGVkSW50ZXJ2YWxbXSB7XG4gIHJldHVybiBpbnRlcnZhbHNcbiAgICAuZmlsdGVyKChpbnRlcnZhbCkgPT4gZ2V0TG9jYWxEYXlJc28oaW50ZXJ2YWwudGltZXN0YW1wKSA9PT0gZGF5ICYmIGludGVydmFsLmV4Y2Vzc0t3ID4gMClcbiAgICAuc29ydCgoYSwgYikgPT4gYi5leGNlc3NLdyAtIGEuZXhjZXNzS3cgfHwgYS50aW1lc3RhbXAubG9jYWxlQ29tcGFyZShiLnRpbWVzdGFtcCkpXG4gICAgLnNsaWNlKDAsIGxpbWl0KVxuICAgIC5tYXAoKGludGVydmFsKSA9PiAoe1xuICAgICAgdGltZXN0YW1wOiBpbnRlcnZhbC50aW1lc3RhbXAsXG4gICAgICBjb25zdW1wdGlvbl9rVzogaW50ZXJ2YWwuY29uc3VtcHRpb25LdyxcbiAgICAgIGV4Y2Vzc19rVzogaW50ZXJ2YWwuZXhjZXNzS3dcbiAgICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERheVByb2ZpbGUoXG4gIGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSxcbiAgZGF5SXNvOiBzdHJpbmcsXG4gIGludGVydmFsTWludXRlcyA9IDE1LFxuICB0aW1lWm9uZSA9ICdFdXJvcGUvQW1zdGVyZGFtJ1xuKTogRGF5UHJvZmlsZVBvaW50W10ge1xuICBpZiAoIWRheUlzbyB8fCBpbnRlcnZhbE1pbnV0ZXMgPD0gMCkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IFt5ZWFyLCBtb250aCwgZGF5XSA9IGRheUlzby5zcGxpdCgnLScpLm1hcChOdW1iZXIpO1xuICBjb25zdCBkYXlTdGFydExvY2FsID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIDAsIDAsIDAsIDApO1xuICBpZiAoTnVtYmVyLmlzTmFOKGRheVN0YXJ0TG9jYWwuZ2V0VGltZSgpKSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IHNsb3RzUGVyRGF5ID0gTWF0aC5mbG9vcigoMjQgKiA2MCkgLyBpbnRlcnZhbE1pbnV0ZXMpO1xuICBjb25zdCBwcm9maWxlID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogc2xvdHNQZXJEYXkgfSwgKF8sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgbWludXRlcyA9IGluZGV4ICogaW50ZXJ2YWxNaW51dGVzO1xuICAgIGNvbnN0IGhvdXIgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgY29uc3QgbWludXRlID0gbWludXRlcyAlIDYwO1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lc3RhbXBMYWJlbDogYCR7U3RyaW5nKGhvdXIpLnBhZFN0YXJ0KDIsICcwJyl9OiR7U3RyaW5nKG1pbnV0ZSkucGFkU3RhcnQoMiwgJzAnKX1gLFxuICAgICAgdGltZXN0YW1wSXNvOiBuZXcgRGF0ZShkYXlTdGFydExvY2FsLmdldFRpbWUoKSArIG1pbnV0ZXMgKiA2MF8wMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBvYnNlcnZlZEt3OiAwXG4gICAgfTtcbiAgfSk7XG5cbiAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgaWYgKGdldExvY2FsRGF5SXNvKGludGVydmFsLnRpbWVzdGFtcCwgdGltZVpvbmUpICE9PSBkYXlJc28pIHJldHVybjtcblxuICAgIGNvbnN0IGR0ID0gcGFyc2VUaW1lc3RhbXAoaW50ZXJ2YWwudGltZXN0YW1wKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGR0LmdldFRpbWUoKSkpIHJldHVybjtcbiAgICBjb25zdCB7IGhvdXIsIG1pbnV0ZSB9ID0gZ2V0TG9jYWxIb3VyTWludXRlKGR0LCB0aW1lWm9uZSk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaG91cikgfHwgIU51bWJlci5pc0Zpbml0ZShtaW51dGUpKSByZXR1cm47XG5cbiAgICBjb25zdCBtaW51dGVPZkRheSA9IGhvdXIgKiA2MCArIG1pbnV0ZTtcbiAgICBjb25zdCBzbG90SW5kZXggPSBNYXRoLmZsb29yKG1pbnV0ZU9mRGF5IC8gaW50ZXJ2YWxNaW51dGVzKTtcbiAgICBpZiAoc2xvdEluZGV4IDwgMCB8fCBzbG90SW5kZXggPj0gc2xvdHNQZXJEYXkpIHJldHVybjtcblxuICAgIHByb2ZpbGVbc2xvdEluZGV4XS5vYnNlcnZlZEt3ID0gTWF0aC5tYXgocHJvZmlsZVtzbG90SW5kZXhdLm9ic2VydmVkS3csIGludGVydmFsLmNvbnN1bXB0aW9uS3cpO1xuICB9KTtcblxuICByZXR1cm4gcHJvZmlsZTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRMb2NhbERheUlzbyIsImdldExvY2FsSG91ck1pbnV0ZSIsInBhcnNlVGltZXN0YW1wIiwiQkFUVEVSWV9PUFRJT05TIiwibGFiZWwiLCJjYXBhY2l0eUt3aCIsInByb2Nlc3NJbnRlcnZhbHMiLCJyb3dzIiwiY29udHJhY3RlZFBvd2VyS3ciLCJtYXAiLCJyb3ciLCJ0aW1lc3RhbXAiLCJub3JtYWxpemVkVGltZXN0YW1wIiwiTnVtYmVyIiwiaXNOYU4iLCJnZXRUaW1lIiwidG9JU09TdHJpbmciLCJjb25zdW1wdGlvbkt3IiwiY29uc3VtcHRpb25Ld2giLCJleGNlc3NLdyIsIk1hdGgiLCJtYXgiLCJleGNlc3NLd2giLCJncm91cFBlYWtFdmVudHMiLCJpbnRlcnZhbHMiLCJldmVudHMiLCJjdXJyZW50IiwiZm9yRWFjaCIsImludGVydmFsIiwiaW5kZXgiLCJwZWFrVGltZXN0YW1wIiwiZHVyYXRpb25JbnRlcnZhbHMiLCJtYXhFeGNlc3NLdyIsInRvdGFsRXhjZXNzS3doIiwiaW50ZXJ2YWxJbmRleGVzIiwicHVzaCIsInBlcmNlbnRpbGUiLCJ2YWx1ZXMiLCJwIiwibGVuZ3RoIiwic29ydGVkIiwic29ydCIsImEiLCJiIiwiaWR4IiwiY2VpbCIsIm1pbiIsImNvbXB1dGVTaXppbmciLCJwYXJhbXMiLCJtZXRob2QiLCJjb21wbGlhbmNlIiwic2FmZXR5RmFjdG9yIiwiZWZmaWNpZW5jeSIsImtXaE5lZWRlZFJhdyIsImtXTmVlZGVkUmF3IiwiaGlnaGVzdEVuZXJneUV2ZW50IiwiZXZlbnQiLCJieURheSIsIk1hcCIsImRheSIsInNsaWNlIiwibGlzdCIsImdldCIsInNldCIsIm1heERheUVuZXJneSIsIm1heERheVBlYWsiLCJkYXlJbnRlcnZhbHMiLCJkYXlFbmVyZ3kiLCJyZWR1Y2UiLCJzdW0iLCJrV2hOZWVkZWQiLCJrV05lZWRlZCIsInJlY29tbWVuZGVkUHJvZHVjdCIsImZpbmQiLCJvcHRpb24iLCJyZWNvbW1lbmRlZEluZGV4IiwiZmluZEluZGV4IiwiYWx0ZXJuYXRpdmVQcm9kdWN0IiwiYnVpbGREYXRhUXVhbGl0eVJlcG9ydCIsInRpbWVzdGFtcHMiLCJzdGFydERhdGUiLCJlbmREYXRlIiwibWlzc2luZ0ludGVydmFsc0NvdW50IiwiZHVwbGljYXRlQ291bnQiLCJub24xNU1pbkludGVydmFscyIsIndhcm5pbmdzIiwiRGF0ZSIsImZpbHRlciIsImRhdGUiLCJTZXQiLCJkIiwic2l6ZSIsImkiLCJkaWZmTWludXRlcyIsInJvdW5kIiwiZmluZE1heE9ic2VydmVkIiwibWF4T2JzZXJ2ZWRLdyIsIm1heE9ic2VydmVkVGltZXN0YW1wIiwic2VsZWN0VG9wRXhjZWVkZWRJbnRlcnZhbHMiLCJsaW1pdCIsImxvY2FsZUNvbXBhcmUiLCJjb25zdW1wdGlvbl9rVyIsImV4Y2Vzc19rVyIsImJ1aWxkRGF5UHJvZmlsZSIsImRheUlzbyIsImludGVydmFsTWludXRlcyIsInRpbWVab25lIiwieWVhciIsIm1vbnRoIiwic3BsaXQiLCJkYXlTdGFydExvY2FsIiwic2xvdHNQZXJEYXkiLCJmbG9vciIsInByb2ZpbGUiLCJBcnJheSIsImZyb20iLCJfIiwibWludXRlcyIsImhvdXIiLCJtaW51dGUiLCJ0aW1lc3RhbXBMYWJlbCIsIlN0cmluZyIsInBhZFN0YXJ0IiwidGltZXN0YW1wSXNvIiwib2JzZXJ2ZWRLdyIsImR0IiwiaXNGaW5pdGUiLCJtaW51dGVPZkRheSIsInNsb3RJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});