"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BATTERY_OPTIONS: function() { return /* binding */ BATTERY_OPTIONS; },\n/* harmony export */   buildDataQualityReport: function() { return /* binding */ buildDataQualityReport; },\n/* harmony export */   buildDayProfile: function() { return /* binding */ buildDayProfile; },\n/* harmony export */   computeSizing: function() { return /* binding */ computeSizing; },\n/* harmony export */   findMaxObserved: function() { return /* binding */ findMaxObserved; },\n/* harmony export */   groupPeakEvents: function() { return /* binding */ groupPeakEvents; },\n/* harmony export */   processIntervals: function() { return /* binding */ processIntervals; },\n/* harmony export */   selectMinimumCostBatteryOptions: function() { return /* binding */ selectMinimumCostBatteryOptions; },\n/* harmony export */   selectTopExceededIntervals: function() { return /* binding */ selectTopExceededIntervals; }\n/* harmony export */ });\n/* harmony import */ var _datetime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime */ \"(app-pages-browser)/./lib/datetime.ts\");\n\nconst BATTERY_OPTIONS = [\n    {\n        label: \"WattsNext ESS Cabinet 64 kWh\",\n        capacityKwh: 64,\n        modular: true,\n        unitPriceEur: 15689.33\n    },\n    {\n        label: \"WattsNext ESS Cabinet 96 kWh\",\n        capacityKwh: 96,\n        modular: true,\n        unitPriceEur: 22225.98\n    },\n    {\n        label: \"ESS All-in-one Cabinet 261 kWh\",\n        capacityKwh: 261,\n        modular: true,\n        unitPriceEur: 43995.96\n    },\n    {\n        label: \"WattsNext All-in-one Container 2.09 MWh\",\n        capacityKwh: 2090,\n        modular: false,\n        unitPriceEur: 318658.06\n    },\n    {\n        label: \"WattsNext All in-one Container 5.015 MWh\",\n        capacityKwh: 5015,\n        modular: false,\n        unitPriceEur: 675052.49\n    }\n];\nfunction roundCurrency(value) {\n    return Math.round(value * 100) / 100;\n}\nfunction toBatteryProduct(candidate) {\n    const totalPriceEur = roundCurrency(candidate.totalPriceEur);\n    return {\n        label: candidate.label,\n        capacityKwh: candidate.totalCapacityKwh,\n        unitCapacityKwh: candidate.unitCapacityKwh,\n        count: candidate.count,\n        unitPriceEur: roundCurrency(candidate.unitPriceEur),\n        totalPriceEur,\n        breakdown: [\n            {\n                type: \"\".concat(candidate.unitCapacityKwh, \" kWh\"),\n                count: candidate.count,\n                unitCapacityKwh: candidate.unitCapacityKwh,\n                unitPriceEur: roundCurrency(candidate.unitPriceEur),\n                totalPriceEur\n            }\n        ]\n    };\n}\nfunction selectMinimumCostBatteryOptions(requiredKwh) {\n    const normalizedRequired = Math.max(0, requiredKwh);\n    const candidates = [];\n    BATTERY_OPTIONS.forEach((option)=>{\n        var _option_unitPriceEur;\n        const unitPriceEur = (_option_unitPriceEur = option.unitPriceEur) !== null && _option_unitPriceEur !== void 0 ? _option_unitPriceEur : 0;\n        if (option.modular) {\n            const maxCount = Math.max(1, Math.ceil(normalizedRequired / option.capacityKwh));\n            for(let count = 1; count <= maxCount; count += 1){\n                const totalCapacityKwh = count * option.capacityKwh;\n                const totalPriceEur = count * unitPriceEur;\n                candidates.push({\n                    label: \"\".concat(count, \"x \").concat(option.capacityKwh, \" kWh (modulair)\"),\n                    totalCapacityKwh,\n                    totalPriceEur,\n                    overCapacityKwh: totalCapacityKwh - normalizedRequired,\n                    count,\n                    unitCapacityKwh: option.capacityKwh,\n                    unitPriceEur\n                });\n            }\n            return;\n        }\n        if (option.capacityKwh >= normalizedRequired) {\n            candidates.push({\n                label: option.label,\n                totalCapacityKwh: option.capacityKwh,\n                totalPriceEur: unitPriceEur,\n                overCapacityKwh: option.capacityKwh - normalizedRequired,\n                count: 1,\n                unitCapacityKwh: option.capacityKwh,\n                unitPriceEur\n            });\n        }\n    });\n    const sorted = candidates.sort((a, b)=>a.totalPriceEur - b.totalPriceEur || a.overCapacityKwh - b.overCapacityKwh || a.totalCapacityKwh - b.totalCapacityKwh);\n    const recommendedProduct = toBatteryProduct(sorted[0]);\n    const alternativeProduct = sorted[1] ? toBatteryProduct(sorted[1]) : null;\n    return {\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction processIntervals(rows, contractedPowerKw) {\n    return rows.map((row)=>{\n        const timestamp = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(row.timestamp);\n        const normalizedTimestamp = Number.isNaN(timestamp.getTime()) ? row.timestamp : timestamp.toISOString();\n        const consumptionKw = row.consumptionKwh / 0.25;\n        const excessKw = Math.max(0, consumptionKw - contractedPowerKw);\n        return {\n            ...row,\n            timestamp: normalizedTimestamp,\n            consumptionKw,\n            excessKw,\n            excessKwh: excessKw * 0.25\n        };\n    });\n}\nfunction groupPeakEvents(intervals) {\n    const events = [];\n    let current = null;\n    intervals.forEach((interval, index)=>{\n        if (interval.excessKw > 0) {\n            if (!current) {\n                current = {\n                    peakTimestamp: interval.timestamp,\n                    durationIntervals: 0,\n                    maxExcessKw: 0,\n                    totalExcessKwh: 0,\n                    intervalIndexes: []\n                };\n            }\n            current.durationIntervals += 1;\n            if (interval.excessKw > current.maxExcessKw || interval.excessKw === current.maxExcessKw && interval.timestamp < current.peakTimestamp) {\n                current.maxExcessKw = interval.excessKw;\n                current.peakTimestamp = interval.timestamp;\n            }\n            current.totalExcessKwh += interval.excessKwh;\n            current.intervalIndexes.push(index);\n        } else if (current) {\n            events.push(current);\n            current = null;\n        }\n    });\n    if (current) {\n        events.push(current);\n    }\n    return events;\n}\nfunction percentile(values, p) {\n    if (values.length === 0) return 0;\n    const sorted = [\n        ...values\n    ].sort((a, b)=>a - b);\n    const idx = Math.ceil(p / 100 * sorted.length) - 1;\n    return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\n}\nfunction computeSizing(params) {\n    const { intervals, events, method, compliance, safetyFactor, efficiency } = params;\n    let kWhNeededRaw = 0;\n    let kWNeededRaw = 0;\n    if (method === \"MAX_PEAK\") {\n        const highestEnergyEvent = [\n            ...events\n        ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n        if (highestEnergyEvent) {\n            kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n            kWNeededRaw = highestEnergyEvent.maxExcessKw;\n        }\n    }\n    if (method === \"P95\") {\n        if (events.length < 20) {\n            const highestEnergyEvent = [\n                ...events\n            ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n            if (highestEnergyEvent) {\n                kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n                kWNeededRaw = highestEnergyEvent.maxExcessKw;\n            }\n        } else {\n            kWhNeededRaw = percentile(events.map((event)=>event.totalExcessKwh), 95);\n            kWNeededRaw = percentile(events.map((event)=>event.maxExcessKw), 95);\n        }\n    }\n    if (method === \"FULL_COVERAGE\") {\n        const byDay = new Map();\n        intervals.forEach((interval)=>{\n            const day = interval.timestamp.slice(0, 10);\n            var _byDay_get;\n            const list = (_byDay_get = byDay.get(day)) !== null && _byDay_get !== void 0 ? _byDay_get : [];\n            list.push(interval);\n            byDay.set(day, list);\n        });\n        let maxDayEnergy = 0;\n        let maxDayPeak = 0;\n        byDay.forEach((dayIntervals)=>{\n            const dayEnergy = dayIntervals.reduce((sum, interval)=>sum + interval.excessKwh, 0);\n            if (dayEnergy > maxDayEnergy) {\n                maxDayEnergy = dayEnergy;\n                maxDayPeak = Math.max(...dayIntervals.map((interval)=>interval.excessKw));\n            }\n        });\n        kWhNeededRaw = maxDayEnergy;\n        kWNeededRaw = maxDayPeak;\n    }\n    kWhNeededRaw *= compliance;\n    kWNeededRaw *= compliance;\n    const kWhNeeded = kWhNeededRaw / efficiency * safetyFactor;\n    const kWNeeded = kWNeededRaw * safetyFactor;\n    const { recommendedProduct, alternativeProduct } = selectMinimumCostBatteryOptions(kWhNeeded);\n    return {\n        kWhNeededRaw,\n        kWNeededRaw,\n        kWhNeeded,\n        kWNeeded,\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction buildDataQualityReport(intervals) {\n    var _timestamps_, _timestamps_1;\n    if (intervals.length === 0) {\n        return {\n            rows: 0,\n            startDate: null,\n            endDate: null,\n            missingIntervalsCount: 0,\n            duplicateCount: 0,\n            non15MinIntervals: 0,\n            warnings: [\n                \"No rows found in dataset.\"\n            ]\n        };\n    }\n    const timestamps = intervals.map((row)=>new Date(row.timestamp)).filter((date)=>!Number.isNaN(date.getTime())).sort((a, b)=>a.getTime() - b.getTime());\n    const duplicateCount = timestamps.length - new Set(timestamps.map((d)=>d.toISOString())).size;\n    let non15MinIntervals = 0;\n    let missingIntervalsCount = 0;\n    for(let i = 1; i < timestamps.length; i += 1){\n        const diffMinutes = (timestamps[i].getTime() - timestamps[i - 1].getTime()) / 60000;\n        if (diffMinutes !== 15) {\n            non15MinIntervals += 1;\n            if (diffMinutes > 15) {\n                missingIntervalsCount += Math.max(0, Math.round(diffMinutes / 15) - 1);\n            }\n        }\n    }\n    const warnings = [];\n    if (duplicateCount > 0) warnings.push(\"Detected \".concat(duplicateCount, \" duplicate timestamps.\"));\n    if (non15MinIntervals > 0) {\n        warnings.push(\"Detected \".concat(non15MinIntervals, \" non-15-minute interval transitions.\"));\n    }\n    var _timestamps__toISOString, _timestamps__toISOString1;\n    return {\n        rows: intervals.length,\n        startDate: (_timestamps__toISOString = (_timestamps_ = timestamps[0]) === null || _timestamps_ === void 0 ? void 0 : _timestamps_.toISOString()) !== null && _timestamps__toISOString !== void 0 ? _timestamps__toISOString : null,\n        endDate: (_timestamps__toISOString1 = (_timestamps_1 = timestamps[timestamps.length - 1]) === null || _timestamps_1 === void 0 ? void 0 : _timestamps_1.toISOString()) !== null && _timestamps__toISOString1 !== void 0 ? _timestamps__toISOString1 : null,\n        missingIntervalsCount,\n        duplicateCount,\n        non15MinIntervals,\n        warnings\n    };\n}\nfunction findMaxObserved(intervals) {\n    if (intervals.length === 0) {\n        return {\n            maxObservedKw: 0,\n            maxObservedTimestamp: null\n        };\n    }\n    let maxObservedKw = -1;\n    let maxObservedTimestamp = null;\n    intervals.forEach((interval)=>{\n        if (interval.consumptionKw > maxObservedKw || interval.consumptionKw === maxObservedKw && maxObservedTimestamp !== null && interval.timestamp < maxObservedTimestamp) {\n            maxObservedKw = interval.consumptionKw;\n            maxObservedTimestamp = interval.timestamp;\n        }\n    });\n    return {\n        maxObservedKw,\n        maxObservedTimestamp\n    };\n}\nfunction selectTopExceededIntervals(intervals, day) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;\n    return intervals.filter((interval)=>(0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp) === day && interval.excessKw > 0).sort((a, b)=>b.excessKw - a.excessKw || a.timestamp.localeCompare(b.timestamp)).slice(0, limit).map((interval)=>({\n            timestamp: interval.timestamp,\n            consumption_kW: interval.consumptionKw,\n            excess_kW: interval.excessKw\n        }));\n}\nfunction buildDayProfile(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    if (!dayIso || intervalMinutes <= 0) return [];\n    const [year, month, day] = dayIso.split(\"-\").map(Number);\n    const dayStartLocal = new Date(year, month - 1, day, 0, 0, 0, 0);\n    if (Number.isNaN(dayStartLocal.getTime())) return [];\n    const slotsPerDay = Math.floor(24 * 60 / intervalMinutes);\n    const profile = Array.from({\n        length: slotsPerDay\n    }, (_, index)=>{\n        const minutes = index * intervalMinutes;\n        const hour = Math.floor(minutes / 60);\n        const minute = minutes % 60;\n        return {\n            timestampLabel: \"\".concat(String(hour).padStart(2, \"0\"), \":\").concat(String(minute).padStart(2, \"0\")),\n            timestampIso: new Date(dayStartLocal.getTime() + minutes * 60000).toISOString(),\n            observedKw: 0\n        };\n    });\n    intervals.forEach((interval)=>{\n        if ((0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp, timeZone) !== dayIso) return;\n        const dt = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(interval.timestamp);\n        if (Number.isNaN(dt.getTime())) return;\n        const { hour, minute } = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalHourMinute)(dt, timeZone);\n        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return;\n        const minuteOfDay = hour * 60 + minute;\n        const slotIndex = Math.floor(minuteOfDay / intervalMinutes);\n        if (slotIndex < 0 || slotIndex >= slotsPerDay) return;\n        profile[slotIndex].observedKw = Math.max(profile[slotIndex].observedKw, interval.consumptionKw);\n    });\n    return profile;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBSyxDQUFDZSxjQUFjdEI7UUFDM0MsSUFBSXVCLFlBQVksS0FBS0EsYUFBYWpCLGFBQWE7UUFFL0NFLE9BQU8sQ0FBQ2UsVUFBVSxDQUFDSixVQUFVLEdBQUdqSSxLQUFLYSxHQUFHLENBQUN5RyxPQUFPLENBQUNlLFVBQVUsQ0FBQ0osVUFBVSxFQUFFbkYsU0FBU1IsYUFBYTtJQUNoRztJQUVBLE9BQU9nRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jYWxjdWxhdGlvbnMudHM/M2Y3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMb2NhbERheUlzbywgZ2V0TG9jYWxIb3VyTWludXRlLCBwYXJzZVRpbWVzdGFtcCB9IGZyb20gJy4vZGF0ZXRpbWUnO1xuXG5leHBvcnQgdHlwZSBNZXRob2QgPSAnTUFYX1BFQUsnIHwgJ1A5NScgfCAnRlVMTF9DT1ZFUkFHRSc7XG5cclxuZXhwb3J0IGludGVyZmFjZSBJbnRlcnZhbFJlY29yZCB7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgY29uc3VtcHRpb25Ld2g6IG51bWJlcjtcclxuICBleHBvcnRLd2g/OiBudW1iZXI7XHJcbiAgcHZLd2g/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2VkSW50ZXJ2YWwgZXh0ZW5kcyBJbnRlcnZhbFJlY29yZCB7XHJcbiAgY29uc3VtcHRpb25LdzogbnVtYmVyO1xyXG4gIGV4Y2Vzc0t3OiBudW1iZXI7XHJcbiAgZXhjZXNzS3doOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGVha0V2ZW50IHtcbiAgcGVha1RpbWVzdGFtcDogc3RyaW5nO1xuICBkdXJhdGlvbkludGVydmFsczogbnVtYmVyO1xuICBtYXhFeGNlc3NLdzogbnVtYmVyO1xuICB0b3RhbEV4Y2Vzc0t3aDogbnVtYmVyO1xuICBpbnRlcnZhbEluZGV4ZXM6IG51bWJlcltdO1xufVxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVF1YWxpdHlSZXBvcnQge1xyXG4gIHJvd3M6IG51bWJlcjtcclxuICBzdGFydERhdGU6IHN0cmluZyB8IG51bGw7XHJcbiAgZW5kRGF0ZTogc3RyaW5nIHwgbnVsbDtcclxuICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQ6IG51bWJlcjtcclxuICBkdXBsaWNhdGVDb3VudDogbnVtYmVyO1xyXG4gIG5vbjE1TWluSW50ZXJ2YWxzOiBudW1iZXI7XHJcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNpemluZ1Jlc3VsdCB7XHJcbiAga1doTmVlZGVkUmF3OiBudW1iZXI7XHJcbiAga1dOZWVkZWRSYXc6IG51bWJlcjtcclxuICBrV2hOZWVkZWQ6IG51bWJlcjtcclxuICBrV05lZWRlZDogbnVtYmVyO1xyXG4gIHJlY29tbWVuZGVkUHJvZHVjdDogQmF0dGVyeVByb2R1Y3Q7XHJcbiAgYWx0ZXJuYXRpdmVQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdCB8IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmF0dGVyeVByb2R1Y3Qge1xuICBsYWJlbDogc3RyaW5nO1xuICBjYXBhY2l0eUt3aDogbnVtYmVyO1xuICBtb2R1bGFyPzogYm9vbGVhbjtcbiAgdW5pdFByaWNlRXVyPzogbnVtYmVyO1xuICB1bml0Q2FwYWNpdHlLd2g/OiBudW1iZXI7XG4gIGNvdW50PzogbnVtYmVyO1xuICB0b3RhbFByaWNlRXVyPzogbnVtYmVyO1xuICBicmVha2Rvd24/OiBCYXR0ZXJ5QnJlYWtkb3duW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0dGVyeUJyZWFrZG93biB7XG4gIHR5cGU6IHN0cmluZztcbiAgY291bnQ6IG51bWJlcjtcbiAgdW5pdENhcGFjaXR5S3doOiBudW1iZXI7XG4gIHVuaXRQcmljZUV1cjogbnVtYmVyO1xuICB0b3RhbFByaWNlRXVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhjZWVkZWRJbnRlcnZhbCB7XG4gIHRpbWVzdGFtcDogc3RyaW5nO1xuICBjb25zdW1wdGlvbl9rVzogbnVtYmVyO1xuICBleGNlc3Nfa1c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXlQcm9maWxlUG9pbnQge1xuICB0aW1lc3RhbXBMYWJlbDogc3RyaW5nO1xuICB0aW1lc3RhbXBJc286IHN0cmluZztcbiAgb2JzZXJ2ZWRLdzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgQkFUVEVSWV9PUFRJT05TOiBCYXR0ZXJ5UHJvZHVjdFtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgRVNTIENhYmluZXQgNjQga1doJyxcbiAgICBjYXBhY2l0eUt3aDogNjQsXG4gICAgbW9kdWxhcjogdHJ1ZSxcbiAgICB1bml0UHJpY2VFdXI6IDE1Njg5LjMzXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1dhdHRzTmV4dCBFU1MgQ2FiaW5ldCA5NiBrV2gnLFxuICAgIGNhcGFjaXR5S3doOiA5NixcbiAgICBtb2R1bGFyOiB0cnVlLFxuICAgIHVuaXRQcmljZUV1cjogMjIyMjUuOThcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnRVNTIEFsbC1pbi1vbmUgQ2FiaW5ldCAyNjEga1doJyxcbiAgICBjYXBhY2l0eUt3aDogMjYxLFxuICAgIG1vZHVsYXI6IHRydWUsXG4gICAgdW5pdFByaWNlRXVyOiA0Mzk5NS45NlxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgQWxsLWluLW9uZSBDb250YWluZXIgMi4wOSBNV2gnLFxuICAgIGNhcGFjaXR5S3doOiAyMDkwLFxuICAgIG1vZHVsYXI6IGZhbHNlLFxuICAgIHVuaXRQcmljZUV1cjogMzE4NjU4LjA2XG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1dhdHRzTmV4dCBBbGwgaW4tb25lIENvbnRhaW5lciA1LjAxNSBNV2gnLFxuICAgIGNhcGFjaXR5S3doOiA1MDE1LFxuICAgIG1vZHVsYXI6IGZhbHNlLFxuICAgIHVuaXRQcmljZUV1cjogNjc1MDUyLjQ5XG4gIH1cbl07XG5cbmludGVyZmFjZSBCYXR0ZXJ5Q29uZmlndXJhdGlvbkNhbmRpZGF0ZSB7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIHRvdGFsQ2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgdG90YWxQcmljZUV1cjogbnVtYmVyO1xuICBvdmVyQ2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgY291bnQ6IG51bWJlcjtcbiAgdW5pdENhcGFjaXR5S3doOiBudW1iZXI7XG4gIHVuaXRQcmljZUV1cjogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiByb3VuZEN1cnJlbmN5KHZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIHRvQmF0dGVyeVByb2R1Y3QoY2FuZGlkYXRlOiBCYXR0ZXJ5Q29uZmlndXJhdGlvbkNhbmRpZGF0ZSk6IEJhdHRlcnlQcm9kdWN0IHtcbiAgY29uc3QgdG90YWxQcmljZUV1ciA9IHJvdW5kQ3VycmVuY3koY2FuZGlkYXRlLnRvdGFsUHJpY2VFdXIpO1xuICByZXR1cm4ge1xuICAgIGxhYmVsOiBjYW5kaWRhdGUubGFiZWwsXG4gICAgY2FwYWNpdHlLd2g6IGNhbmRpZGF0ZS50b3RhbENhcGFjaXR5S3doLFxuICAgIHVuaXRDYXBhY2l0eUt3aDogY2FuZGlkYXRlLnVuaXRDYXBhY2l0eUt3aCxcbiAgICBjb3VudDogY2FuZGlkYXRlLmNvdW50LFxuICAgIHVuaXRQcmljZUV1cjogcm91bmRDdXJyZW5jeShjYW5kaWRhdGUudW5pdFByaWNlRXVyKSxcbiAgICB0b3RhbFByaWNlRXVyLFxuICAgIGJyZWFrZG93bjogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBgJHtjYW5kaWRhdGUudW5pdENhcGFjaXR5S3dofSBrV2hgLFxuICAgICAgICBjb3VudDogY2FuZGlkYXRlLmNvdW50LFxuICAgICAgICB1bml0Q2FwYWNpdHlLd2g6IGNhbmRpZGF0ZS51bml0Q2FwYWNpdHlLd2gsXG4gICAgICAgIHVuaXRQcmljZUV1cjogcm91bmRDdXJyZW5jeShjYW5kaWRhdGUudW5pdFByaWNlRXVyKSxcbiAgICAgICAgdG90YWxQcmljZUV1clxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdE1pbmltdW1Db3N0QmF0dGVyeU9wdGlvbnMocmVxdWlyZWRLd2g6IG51bWJlcik6IHtcbiAgcmVjb21tZW5kZWRQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdDtcbiAgYWx0ZXJuYXRpdmVQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdCB8IG51bGw7XG59IHtcbiAgY29uc3Qgbm9ybWFsaXplZFJlcXVpcmVkID0gTWF0aC5tYXgoMCwgcmVxdWlyZWRLd2gpO1xuICBjb25zdCBjYW5kaWRhdGVzOiBCYXR0ZXJ5Q29uZmlndXJhdGlvbkNhbmRpZGF0ZVtdID0gW107XG5cbiAgQkFUVEVSWV9PUFRJT05TLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgIGNvbnN0IHVuaXRQcmljZUV1ciA9IG9wdGlvbi51bml0UHJpY2VFdXIgPz8gMDtcbiAgICBpZiAob3B0aW9uLm1vZHVsYXIpIHtcbiAgICAgIGNvbnN0IG1heENvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKG5vcm1hbGl6ZWRSZXF1aXJlZCAvIG9wdGlvbi5jYXBhY2l0eUt3aCkpO1xuICAgICAgZm9yIChsZXQgY291bnQgPSAxOyBjb3VudCA8PSBtYXhDb3VudDsgY291bnQgKz0gMSkge1xuICAgICAgICBjb25zdCB0b3RhbENhcGFjaXR5S3doID0gY291bnQgKiBvcHRpb24uY2FwYWNpdHlLd2g7XG4gICAgICAgIGNvbnN0IHRvdGFsUHJpY2VFdXIgPSBjb3VudCAqIHVuaXRQcmljZUV1cjtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBsYWJlbDogYCR7Y291bnR9eCAke29wdGlvbi5jYXBhY2l0eUt3aH0ga1doIChtb2R1bGFpcilgLFxuICAgICAgICAgIHRvdGFsQ2FwYWNpdHlLd2gsXG4gICAgICAgICAgdG90YWxQcmljZUV1cixcbiAgICAgICAgICBvdmVyQ2FwYWNpdHlLd2g6IHRvdGFsQ2FwYWNpdHlLd2ggLSBub3JtYWxpemVkUmVxdWlyZWQsXG4gICAgICAgICAgY291bnQsXG4gICAgICAgICAgdW5pdENhcGFjaXR5S3doOiBvcHRpb24uY2FwYWNpdHlLd2gsXG4gICAgICAgICAgdW5pdFByaWNlRXVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb24uY2FwYWNpdHlLd2ggPj0gbm9ybWFsaXplZFJlcXVpcmVkKSB7XG4gICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICBsYWJlbDogb3B0aW9uLmxhYmVsLFxuICAgICAgICB0b3RhbENhcGFjaXR5S3doOiBvcHRpb24uY2FwYWNpdHlLd2gsXG4gICAgICAgIHRvdGFsUHJpY2VFdXI6IHVuaXRQcmljZUV1cixcbiAgICAgICAgb3ZlckNhcGFjaXR5S3doOiBvcHRpb24uY2FwYWNpdHlLd2ggLSBub3JtYWxpemVkUmVxdWlyZWQsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICB1bml0Q2FwYWNpdHlLd2g6IG9wdGlvbi5jYXBhY2l0eUt3aCxcbiAgICAgICAgdW5pdFByaWNlRXVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHNvcnRlZCA9IGNhbmRpZGF0ZXMuc29ydChcbiAgICAoYSwgYikgPT5cbiAgICAgIGEudG90YWxQcmljZUV1ciAtIGIudG90YWxQcmljZUV1ciB8fFxuICAgICAgYS5vdmVyQ2FwYWNpdHlLd2ggLSBiLm92ZXJDYXBhY2l0eUt3aCB8fFxuICAgICAgYS50b3RhbENhcGFjaXR5S3doIC0gYi50b3RhbENhcGFjaXR5S3doXG4gICk7XG5cbiAgY29uc3QgcmVjb21tZW5kZWRQcm9kdWN0ID0gdG9CYXR0ZXJ5UHJvZHVjdChzb3J0ZWRbMF0pO1xuICBjb25zdCBhbHRlcm5hdGl2ZVByb2R1Y3QgPSBzb3J0ZWRbMV0gPyB0b0JhdHRlcnlQcm9kdWN0KHNvcnRlZFsxXSkgOiBudWxsO1xuXG4gIHJldHVybiB7IHJlY29tbWVuZGVkUHJvZHVjdCwgYWx0ZXJuYXRpdmVQcm9kdWN0IH07XG59XG5cclxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NJbnRlcnZhbHMoXG4gIHJvd3M6IEludGVydmFsUmVjb3JkW10sXG4gIGNvbnRyYWN0ZWRQb3dlckt3OiBudW1iZXJcbik6IFByb2Nlc3NlZEludGVydmFsW10ge1xuICByZXR1cm4gcm93cy5tYXAoKHJvdykgPT4ge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlVGltZXN0YW1wKHJvdy50aW1lc3RhbXApO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lc3RhbXAgPSBOdW1iZXIuaXNOYU4odGltZXN0YW1wLmdldFRpbWUoKSkgPyByb3cudGltZXN0YW1wIDogdGltZXN0YW1wLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgY29uc3VtcHRpb25LdyA9IHJvdy5jb25zdW1wdGlvbkt3aCAvIDAuMjU7XG4gICAgY29uc3QgZXhjZXNzS3cgPSBNYXRoLm1heCgwLCBjb25zdW1wdGlvbkt3IC0gY29udHJhY3RlZFBvd2VyS3cpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yb3csXG4gICAgICB0aW1lc3RhbXA6IG5vcm1hbGl6ZWRUaW1lc3RhbXAsXG4gICAgICBjb25zdW1wdGlvbkt3LFxuICAgICAgZXhjZXNzS3csXG4gICAgICBleGNlc3NLd2g6IGV4Y2Vzc0t3ICogMC4yNVxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBncm91cFBlYWtFdmVudHMoaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdKTogUGVha0V2ZW50W10ge1xuICBjb25zdCBldmVudHM6IFBlYWtFdmVudFtdID0gW107XG4gIGxldCBjdXJyZW50OiBQZWFrRXZlbnQgfCBudWxsID0gbnVsbDtcblxuICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwsIGluZGV4KSA9PiB7XG4gICAgaWYgKGludGVydmFsLmV4Y2Vzc0t3ID4gMCkge1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgICAgcGVha1RpbWVzdGFtcDogaW50ZXJ2YWwudGltZXN0YW1wLFxuICAgICAgICAgIGR1cmF0aW9uSW50ZXJ2YWxzOiAwLFxuICAgICAgICAgIG1heEV4Y2Vzc0t3OiAwLFxuICAgICAgICAgIHRvdGFsRXhjZXNzS3doOiAwLFxuICAgICAgICAgIGludGVydmFsSW5kZXhlczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQuZHVyYXRpb25JbnRlcnZhbHMgKz0gMTtcbiAgICAgIGlmIChcbiAgICAgICAgaW50ZXJ2YWwuZXhjZXNzS3cgPiBjdXJyZW50Lm1heEV4Y2Vzc0t3IHx8XG4gICAgICAgIChpbnRlcnZhbC5leGNlc3NLdyA9PT0gY3VycmVudC5tYXhFeGNlc3NLdyAmJiBpbnRlcnZhbC50aW1lc3RhbXAgPCBjdXJyZW50LnBlYWtUaW1lc3RhbXApXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudC5tYXhFeGNlc3NLdyA9IGludGVydmFsLmV4Y2Vzc0t3O1xuICAgICAgICBjdXJyZW50LnBlYWtUaW1lc3RhbXAgPSBpbnRlcnZhbC50aW1lc3RhbXA7XG4gICAgICB9XG4gICAgICBjdXJyZW50LnRvdGFsRXhjZXNzS3doICs9IGludGVydmFsLmV4Y2Vzc0t3aDtcbiAgICAgIGN1cnJlbnQuaW50ZXJ2YWxJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudCkge1xuICAgICAgZXZlbnRzLnB1c2goY3VycmVudCk7XHJcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpZiAoY3VycmVudCkge1xyXG4gICAgZXZlbnRzLnB1c2goY3VycmVudCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXZlbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwZXJjZW50aWxlKHZhbHVlczogbnVtYmVyW10sIHA6IG51bWJlcik6IG51bWJlciB7XHJcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xyXG4gIGNvbnN0IHNvcnRlZCA9IFsuLi52YWx1ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICBjb25zdCBpZHggPSBNYXRoLmNlaWwoKHAgLyAxMDApICogc29ydGVkLmxlbmd0aCkgLSAxO1xyXG4gIHJldHVybiBzb3J0ZWRbTWF0aC5tYXgoMCwgTWF0aC5taW4oaWR4LCBzb3J0ZWQubGVuZ3RoIC0gMSkpXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTaXppbmcocGFyYW1zOiB7XHJcbiAgaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdO1xyXG4gIGV2ZW50czogUGVha0V2ZW50W107XHJcbiAgbWV0aG9kOiBNZXRob2Q7XHJcbiAgY29tcGxpYW5jZTogbnVtYmVyO1xyXG4gIHNhZmV0eUZhY3RvcjogbnVtYmVyO1xyXG4gIGVmZmljaWVuY3k6IG51bWJlcjtcclxufSk6IFNpemluZ1Jlc3VsdCB7XHJcbiAgY29uc3QgeyBpbnRlcnZhbHMsIGV2ZW50cywgbWV0aG9kLCBjb21wbGlhbmNlLCBzYWZldHlGYWN0b3IsIGVmZmljaWVuY3kgfSA9IHBhcmFtcztcclxuXHJcbiAgbGV0IGtXaE5lZWRlZFJhdyA9IDA7XHJcbiAgbGV0IGtXTmVlZGVkUmF3ID0gMDtcclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ01BWF9QRUFLJykge1xyXG4gICAgY29uc3QgaGlnaGVzdEVuZXJneUV2ZW50ID0gWy4uLmV2ZW50c10uc29ydChcclxuICAgICAgKGEsIGIpID0+IGIudG90YWxFeGNlc3NLd2ggLSBhLnRvdGFsRXhjZXNzS3doXHJcbiAgICApWzBdO1xyXG4gICAgaWYgKGhpZ2hlc3RFbmVyZ3lFdmVudCkge1xyXG4gICAgICBrV2hOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQudG90YWxFeGNlc3NLd2g7XHJcbiAgICAgIGtXTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50Lm1heEV4Y2Vzc0t3O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ1A5NScpIHtcclxuICAgIGlmIChldmVudHMubGVuZ3RoIDwgMjApIHtcclxuICAgICAgY29uc3QgaGlnaGVzdEVuZXJneUV2ZW50ID0gWy4uLmV2ZW50c10uc29ydChcclxuICAgICAgICAoYSwgYikgPT4gYi50b3RhbEV4Y2Vzc0t3aCAtIGEudG90YWxFeGNlc3NLd2hcclxuICAgICAgKVswXTtcclxuICAgICAgaWYgKGhpZ2hlc3RFbmVyZ3lFdmVudCkge1xyXG4gICAgICAgIGtXaE5lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC50b3RhbEV4Y2Vzc0t3aDtcclxuICAgICAgICBrV05lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC5tYXhFeGNlc3NLdztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAga1doTmVlZGVkUmF3ID0gcGVyY2VudGlsZShcclxuICAgICAgICBldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQudG90YWxFeGNlc3NLd2gpLFxyXG4gICAgICAgIDk1XHJcbiAgICAgICk7XHJcbiAgICAgIGtXTmVlZGVkUmF3ID0gcGVyY2VudGlsZShcclxuICAgICAgICBldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQubWF4RXhjZXNzS3cpLFxyXG4gICAgICAgIDk1XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAobWV0aG9kID09PSAnRlVMTF9DT1ZFUkFHRScpIHtcclxuICAgIGNvbnN0IGJ5RGF5ID0gbmV3IE1hcDxzdHJpbmcsIFByb2Nlc3NlZEludGVydmFsW10+KCk7XHJcbiAgICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcclxuICAgICAgY29uc3QgZGF5ID0gaW50ZXJ2YWwudGltZXN0YW1wLnNsaWNlKDAsIDEwKTtcclxuICAgICAgY29uc3QgbGlzdCA9IGJ5RGF5LmdldChkYXkpID8/IFtdO1xyXG4gICAgICBsaXN0LnB1c2goaW50ZXJ2YWwpO1xyXG4gICAgICBieURheS5zZXQoZGF5LCBsaXN0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBtYXhEYXlFbmVyZ3kgPSAwO1xyXG4gICAgbGV0IG1heERheVBlYWsgPSAwO1xyXG5cclxuICAgIGJ5RGF5LmZvckVhY2goKGRheUludGVydmFscykgPT4ge1xyXG4gICAgICBjb25zdCBkYXlFbmVyZ3kgPSBkYXlJbnRlcnZhbHMucmVkdWNlKChzdW0sIGludGVydmFsKSA9PiBzdW0gKyBpbnRlcnZhbC5leGNlc3NLd2gsIDApO1xyXG4gICAgICBpZiAoZGF5RW5lcmd5ID4gbWF4RGF5RW5lcmd5KSB7XHJcbiAgICAgICAgbWF4RGF5RW5lcmd5ID0gZGF5RW5lcmd5O1xyXG4gICAgICAgIG1heERheVBlYWsgPSBNYXRoLm1heCguLi5kYXlJbnRlcnZhbHMubWFwKChpbnRlcnZhbCkgPT4gaW50ZXJ2YWwuZXhjZXNzS3cpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAga1doTmVlZGVkUmF3ID0gbWF4RGF5RW5lcmd5O1xyXG4gICAga1dOZWVkZWRSYXcgPSBtYXhEYXlQZWFrO1xyXG4gIH1cclxuXHJcbiAga1doTmVlZGVkUmF3ICo9IGNvbXBsaWFuY2U7XHJcbiAga1dOZWVkZWRSYXcgKj0gY29tcGxpYW5jZTtcclxuXHJcbiAgY29uc3Qga1doTmVlZGVkID0gKGtXaE5lZWRlZFJhdyAvIGVmZmljaWVuY3kpICogc2FmZXR5RmFjdG9yO1xyXG4gIGNvbnN0IGtXTmVlZGVkID0ga1dOZWVkZWRSYXcgKiBzYWZldHlGYWN0b3I7XHJcblxyXG4gIGNvbnN0IHsgcmVjb21tZW5kZWRQcm9kdWN0LCBhbHRlcm5hdGl2ZVByb2R1Y3QgfSA9IHNlbGVjdE1pbmltdW1Db3N0QmF0dGVyeU9wdGlvbnMoa1doTmVlZGVkKTtcblxyXG4gIHJldHVybiB7XHJcbiAgICBrV2hOZWVkZWRSYXcsXHJcbiAgICBrV05lZWRlZFJhdyxcclxuICAgIGtXaE5lZWRlZCxcclxuICAgIGtXTmVlZGVkLFxyXG4gICAgcmVjb21tZW5kZWRQcm9kdWN0LFxyXG4gICAgYWx0ZXJuYXRpdmVQcm9kdWN0XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGF0YVF1YWxpdHlSZXBvcnQoaW50ZXJ2YWxzOiBJbnRlcnZhbFJlY29yZFtdKTogRGF0YVF1YWxpdHlSZXBvcnQge1xuICBpZiAoaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcm93czogMCxcclxuICAgICAgc3RhcnREYXRlOiBudWxsLFxyXG4gICAgICBlbmREYXRlOiBudWxsLFxyXG4gICAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQ6IDAsXHJcbiAgICAgIGR1cGxpY2F0ZUNvdW50OiAwLFxyXG4gICAgICBub24xNU1pbkludGVydmFsczogMCxcclxuICAgICAgd2FybmluZ3M6IFsnTm8gcm93cyBmb3VuZCBpbiBkYXRhc2V0LiddXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdGltZXN0YW1wcyA9IGludGVydmFsc1xyXG4gICAgLm1hcCgocm93KSA9PiBuZXcgRGF0ZShyb3cudGltZXN0YW1wKSlcclxuICAgIC5maWx0ZXIoKGRhdGUpID0+ICFOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKVxyXG4gICAgLnNvcnQoKGEsIGIpID0+IGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCkpO1xyXG5cclxuICBjb25zdCBkdXBsaWNhdGVDb3VudCA9IHRpbWVzdGFtcHMubGVuZ3RoIC0gbmV3IFNldCh0aW1lc3RhbXBzLm1hcCgoZCkgPT4gZC50b0lTT1N0cmluZygpKSkuc2l6ZTtcclxuICBsZXQgbm9uMTVNaW5JbnRlcnZhbHMgPSAwO1xyXG4gIGxldCBtaXNzaW5nSW50ZXJ2YWxzQ291bnQgPSAwO1xyXG5cclxuICBmb3IgKGxldCBpID0gMTsgaSA8IHRpbWVzdGFtcHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgIGNvbnN0IGRpZmZNaW51dGVzID0gKHRpbWVzdGFtcHNbaV0uZ2V0VGltZSgpIC0gdGltZXN0YW1wc1tpIC0gMV0uZ2V0VGltZSgpKSAvIDYwMDAwO1xyXG4gICAgaWYgKGRpZmZNaW51dGVzICE9PSAxNSkge1xyXG4gICAgICBub24xNU1pbkludGVydmFscyArPSAxO1xyXG4gICAgICBpZiAoZGlmZk1pbnV0ZXMgPiAxNSkge1xyXG4gICAgICAgIG1pc3NpbmdJbnRlcnZhbHNDb3VudCArPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKGRpZmZNaW51dGVzIC8gMTUpIC0gMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGlmIChkdXBsaWNhdGVDb3VudCA+IDApIHdhcm5pbmdzLnB1c2goYERldGVjdGVkICR7ZHVwbGljYXRlQ291bnR9IGR1cGxpY2F0ZSB0aW1lc3RhbXBzLmApO1xyXG4gIGlmIChub24xNU1pbkludGVydmFscyA+IDApIHtcclxuICAgIHdhcm5pbmdzLnB1c2goYERldGVjdGVkICR7bm9uMTVNaW5JbnRlcnZhbHN9IG5vbi0xNS1taW51dGUgaW50ZXJ2YWwgdHJhbnNpdGlvbnMuYCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcm93czogaW50ZXJ2YWxzLmxlbmd0aCxcclxuICAgIHN0YXJ0RGF0ZTogdGltZXN0YW1wc1swXT8udG9JU09TdHJpbmcoKSA/PyBudWxsLFxyXG4gICAgZW5kRGF0ZTogdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdPy50b0lTT1N0cmluZygpID8/IG51bGwsXHJcbiAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQsXHJcbiAgICBkdXBsaWNhdGVDb3VudCxcclxuICAgIG5vbjE1TWluSW50ZXJ2YWxzLFxyXG4gICAgd2FybmluZ3NcclxuICB9O1xyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWF4T2JzZXJ2ZWQoaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdKToge1xuICBtYXhPYnNlcnZlZEt3OiBudW1iZXI7XG4gIG1heE9ic2VydmVkVGltZXN0YW1wOiBzdHJpbmcgfCBudWxsO1xufSB7XG4gIGlmIChpbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heE9ic2VydmVkS3c6IDAsXG4gICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcDogbnVsbFxuICAgIH07XG4gIH1cblxuICBsZXQgbWF4T2JzZXJ2ZWRLdyA9IC0xO1xuICBsZXQgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGludGVydmFsLmNvbnN1bXB0aW9uS3cgPiBtYXhPYnNlcnZlZEt3IHx8XG4gICAgICAoaW50ZXJ2YWwuY29uc3VtcHRpb25LdyA9PT0gbWF4T2JzZXJ2ZWRLdyAmJlxuICAgICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcCAhPT0gbnVsbCAmJlxuICAgICAgICBpbnRlcnZhbC50aW1lc3RhbXAgPCBtYXhPYnNlcnZlZFRpbWVzdGFtcClcbiAgICApIHtcbiAgICAgIG1heE9ic2VydmVkS3cgPSBpbnRlcnZhbC5jb25zdW1wdGlvbkt3O1xuICAgICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXAgPSBpbnRlcnZhbC50aW1lc3RhbXA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIG1heE9ic2VydmVkS3csXG4gICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFRvcEV4Y2VlZGVkSW50ZXJ2YWxzKFxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10sXG4gIGRheTogc3RyaW5nLFxuICBsaW1pdCA9IDIwXG4pOiBFeGNlZWRlZEludGVydmFsW10ge1xuICByZXR1cm4gaW50ZXJ2YWxzXG4gICAgLmZpbHRlcigoaW50ZXJ2YWwpID0+IGdldExvY2FsRGF5SXNvKGludGVydmFsLnRpbWVzdGFtcCkgPT09IGRheSAmJiBpbnRlcnZhbC5leGNlc3NLdyA+IDApXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuZXhjZXNzS3cgLSBhLmV4Y2Vzc0t3IHx8IGEudGltZXN0YW1wLmxvY2FsZUNvbXBhcmUoYi50aW1lc3RhbXApKVxuICAgIC5zbGljZSgwLCBsaW1pdClcbiAgICAubWFwKChpbnRlcnZhbCkgPT4gKHtcbiAgICAgIHRpbWVzdGFtcDogaW50ZXJ2YWwudGltZXN0YW1wLFxuICAgICAgY29uc3VtcHRpb25fa1c6IGludGVydmFsLmNvbnN1bXB0aW9uS3csXG4gICAgICBleGNlc3Nfa1c6IGludGVydmFsLmV4Y2Vzc0t3XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXlQcm9maWxlKFxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10sXG4gIGRheUlzbzogc3RyaW5nLFxuICBpbnRlcnZhbE1pbnV0ZXMgPSAxNSxcbiAgdGltZVpvbmUgPSAnRXVyb3BlL0Ftc3RlcmRhbSdcbik6IERheVByb2ZpbGVQb2ludFtdIHtcbiAgaWYgKCFkYXlJc28gfHwgaW50ZXJ2YWxNaW51dGVzIDw9IDApIHJldHVybiBbXTtcblxuICBjb25zdCBbeWVhciwgbW9udGgsIGRheV0gPSBkYXlJc28uc3BsaXQoJy0nKS5tYXAoTnVtYmVyKTtcbiAgY29uc3QgZGF5U3RhcnRMb2NhbCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCAwLCAwLCAwLCAwKTtcbiAgaWYgKE51bWJlci5pc05hTihkYXlTdGFydExvY2FsLmdldFRpbWUoKSkpIHJldHVybiBbXTtcblxuICBjb25zdCBzbG90c1BlckRheSA9IE1hdGguZmxvb3IoKDI0ICogNjApIC8gaW50ZXJ2YWxNaW51dGVzKTtcbiAgY29uc3QgcHJvZmlsZSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHNsb3RzUGVyRGF5IH0sIChfLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBpbmRleCAqIGludGVydmFsTWludXRlcztcbiAgICBjb25zdCBob3VyID0gTWF0aC5mbG9vcihtaW51dGVzIC8gNjApO1xuICAgIGNvbnN0IG1pbnV0ZSA9IG1pbnV0ZXMgJSA2MDtcbiAgICByZXR1cm4ge1xuICAgICAgdGltZXN0YW1wTGFiZWw6IGAke1N0cmluZyhob3VyKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyhtaW51dGUpLnBhZFN0YXJ0KDIsICcwJyl9YCxcbiAgICAgIHRpbWVzdGFtcElzbzogbmV3IERhdGUoZGF5U3RhcnRMb2NhbC5nZXRUaW1lKCkgKyBtaW51dGVzICogNjBfMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgb2JzZXJ2ZWRLdzogMFxuICAgIH07XG4gIH0pO1xuXG4gIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xuICAgIGlmIChnZXRMb2NhbERheUlzbyhpbnRlcnZhbC50aW1lc3RhbXAsIHRpbWVab25lKSAhPT0gZGF5SXNvKSByZXR1cm47XG5cbiAgICBjb25zdCBkdCA9IHBhcnNlVGltZXN0YW1wKGludGVydmFsLnRpbWVzdGFtcCk7XG4gICAgaWYgKE51bWJlci5pc05hTihkdC5nZXRUaW1lKCkpKSByZXR1cm47XG4gICAgY29uc3QgeyBob3VyLCBtaW51dGUgfSA9IGdldExvY2FsSG91ck1pbnV0ZShkdCwgdGltZVpvbmUpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGhvdXIpIHx8ICFOdW1iZXIuaXNGaW5pdGUobWludXRlKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgbWludXRlT2ZEYXkgPSBob3VyICogNjAgKyBtaW51dGU7XG4gICAgY29uc3Qgc2xvdEluZGV4ID0gTWF0aC5mbG9vcihtaW51dGVPZkRheSAvIGludGVydmFsTWludXRlcyk7XG4gICAgaWYgKHNsb3RJbmRleCA8IDAgfHwgc2xvdEluZGV4ID49IHNsb3RzUGVyRGF5KSByZXR1cm47XG5cbiAgICBwcm9maWxlW3Nsb3RJbmRleF0ub2JzZXJ2ZWRLdyA9IE1hdGgubWF4KHByb2ZpbGVbc2xvdEluZGV4XS5vYnNlcnZlZEt3LCBpbnRlcnZhbC5jb25zdW1wdGlvbkt3KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByb2ZpbGU7XG59XG4iXSwibmFtZXMiOlsiZ2V0TG9jYWxEYXlJc28iLCJnZXRMb2NhbEhvdXJNaW51dGUiLCJwYXJzZVRpbWVzdGFtcCIsIkJBVFRFUllfT1BUSU9OUyIsImxhYmVsIiwiY2FwYWNpdHlLd2giLCJtb2R1bGFyIiwidW5pdFByaWNlRXVyIiwicm91bmRDdXJyZW5jeSIsInZhbHVlIiwiTWF0aCIsInJvdW5kIiwidG9CYXR0ZXJ5UHJvZHVjdCIsImNhbmRpZGF0ZSIsInRvdGFsUHJpY2VFdXIiLCJ0b3RhbENhcGFjaXR5S3doIiwidW5pdENhcGFjaXR5S3doIiwiY291bnQiLCJicmVha2Rvd24iLCJ0eXBlIiwic2VsZWN0TWluaW11bUNvc3RCYXR0ZXJ5T3B0aW9ucyIsInJlcXVpcmVkS3doIiwibm9ybWFsaXplZFJlcXVpcmVkIiwibWF4IiwiY2FuZGlkYXRlcyIsImZvckVhY2giLCJvcHRpb24iLCJtYXhDb3VudCIsImNlaWwiLCJwdXNoIiwib3ZlckNhcGFjaXR5S3doIiwic29ydGVkIiwic29ydCIsImEiLCJiIiwicmVjb21tZW5kZWRQcm9kdWN0IiwiYWx0ZXJuYXRpdmVQcm9kdWN0IiwicHJvY2Vzc0ludGVydmFscyIsInJvd3MiLCJjb250cmFjdGVkUG93ZXJLdyIsIm1hcCIsInJvdyIsInRpbWVzdGFtcCIsIm5vcm1hbGl6ZWRUaW1lc3RhbXAiLCJOdW1iZXIiLCJpc05hTiIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsImNvbnN1bXB0aW9uS3ciLCJjb25zdW1wdGlvbkt3aCIsImV4Y2Vzc0t3IiwiZXhjZXNzS3doIiwiZ3JvdXBQZWFrRXZlbnRzIiwiaW50ZXJ2YWxzIiwiZXZlbnRzIiwiY3VycmVudCIsImludGVydmFsIiwiaW5kZXgiLCJwZWFrVGltZXN0YW1wIiwiZHVyYXRpb25JbnRlcnZhbHMiLCJtYXhFeGNlc3NLdyIsInRvdGFsRXhjZXNzS3doIiwiaW50ZXJ2YWxJbmRleGVzIiwicGVyY2VudGlsZSIsInZhbHVlcyIsInAiLCJsZW5ndGgiLCJpZHgiLCJtaW4iLCJjb21wdXRlU2l6aW5nIiwicGFyYW1zIiwibWV0aG9kIiwiY29tcGxpYW5jZSIsInNhZmV0eUZhY3RvciIsImVmZmljaWVuY3kiLCJrV2hOZWVkZWRSYXciLCJrV05lZWRlZFJhdyIsImhpZ2hlc3RFbmVyZ3lFdmVudCIsImV2ZW50IiwiYnlEYXkiLCJNYXAiLCJkYXkiLCJzbGljZSIsImxpc3QiLCJnZXQiLCJzZXQiLCJtYXhEYXlFbmVyZ3kiLCJtYXhEYXlQZWFrIiwiZGF5SW50ZXJ2YWxzIiwiZGF5RW5lcmd5IiwicmVkdWNlIiwic3VtIiwia1doTmVlZGVkIiwia1dOZWVkZWQiLCJidWlsZERhdGFRdWFsaXR5UmVwb3J0IiwidGltZXN0YW1wcyIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJtaXNzaW5nSW50ZXJ2YWxzQ291bnQiLCJkdXBsaWNhdGVDb3VudCIsIm5vbjE1TWluSW50ZXJ2YWxzIiwid2FybmluZ3MiLCJEYXRlIiwiZmlsdGVyIiwiZGF0ZSIsIlNldCIsImQiLCJzaXplIiwiaSIsImRpZmZNaW51dGVzIiwiZmluZE1heE9ic2VydmVkIiwibWF4T2JzZXJ2ZWRLdyIsIm1heE9ic2VydmVkVGltZXN0YW1wIiwic2VsZWN0VG9wRXhjZWVkZWRJbnRlcnZhbHMiLCJsaW1pdCIsImxvY2FsZUNvbXBhcmUiLCJjb25zdW1wdGlvbl9rVyIsImV4Y2Vzc19rVyIsImJ1aWxkRGF5UHJvZmlsZSIsImRheUlzbyIsImludGVydmFsTWludXRlcyIsInRpbWVab25lIiwieWVhciIsIm1vbnRoIiwic3BsaXQiLCJkYXlTdGFydExvY2FsIiwic2xvdHNQZXJEYXkiLCJmbG9vciIsInByb2ZpbGUiLCJBcnJheSIsImZyb20iLCJfIiwibWludXRlcyIsImhvdXIiLCJtaW51dGUiLCJ0aW1lc3RhbXBMYWJlbCIsIlN0cmluZyIsInBhZFN0YXJ0IiwidGltZXN0YW1wSXNvIiwib2JzZXJ2ZWRLdyIsImR0IiwiaXNGaW5pdGUiLCJtaW51dGVPZkRheSIsInNsb3RJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});