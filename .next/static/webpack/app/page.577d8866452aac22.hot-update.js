"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BATTERY_OPTIONS: function() { return /* binding */ BATTERY_OPTIONS; },\n/* harmony export */   buildDataQualityReport: function() { return /* binding */ buildDataQualityReport; },\n/* harmony export */   buildDayProfile: function() { return /* binding */ buildDayProfile; },\n/* harmony export */   computeSizing: function() { return /* binding */ computeSizing; },\n/* harmony export */   findMaxObserved: function() { return /* binding */ findMaxObserved; },\n/* harmony export */   groupPeakEvents: function() { return /* binding */ groupPeakEvents; },\n/* harmony export */   processIntervals: function() { return /* binding */ processIntervals; },\n/* harmony export */   selectTopExceededIntervals: function() { return /* binding */ selectTopExceededIntervals; }\n/* harmony export */ });\n/* harmony import */ var _datetime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime */ \"(app-pages-browser)/./lib/datetime.ts\");\n\nconst BATTERY_OPTIONS = [\n    {\n        label: \"WattsNext ESS Cabinet 64 kWh\",\n        capacityKwh: 64\n    },\n    {\n        label: \"WattsNext ESS Cabinet 96 kWh\",\n        capacityKwh: 96\n    },\n    {\n        label: \"ESS All-in-one Cabinet 261 kWh\",\n        capacityKwh: 261\n    },\n    {\n        label: \"WattsNext All-in-one Container 2.09 MWh\",\n        capacityKwh: 2090\n    },\n    {\n        label: \"WattsNext All in-one Container 5.01 MWh\",\n        capacityKwh: 5010\n    }\n];\nfunction processIntervals(rows, contractedPowerKw) {\n    return rows.map((row)=>{\n        const timestamp = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(row.timestamp);\n        const normalizedTimestamp = Number.isNaN(timestamp.getTime()) ? row.timestamp : timestamp.toISOString();\n        const consumptionKw = row.consumptionKwh / 0.25;\n        const excessKw = Math.max(0, consumptionKw - contractedPowerKw);\n        return {\n            ...row,\n            timestamp: normalizedTimestamp,\n            consumptionKw,\n            excessKw,\n            excessKwh: excessKw * 0.25\n        };\n    });\n}\nfunction groupPeakEvents(intervals) {\n    const events = [];\n    let current = null;\n    intervals.forEach((interval, index)=>{\n        if (interval.excessKw > 0) {\n            if (!current) {\n                current = {\n                    peakTimestamp: interval.timestamp,\n                    durationIntervals: 0,\n                    maxExcessKw: 0,\n                    totalExcessKwh: 0,\n                    intervalIndexes: []\n                };\n            }\n            current.durationIntervals += 1;\n            if (interval.excessKw > current.maxExcessKw || interval.excessKw === current.maxExcessKw && interval.timestamp < current.peakTimestamp) {\n                current.maxExcessKw = interval.excessKw;\n                current.peakTimestamp = interval.timestamp;\n            }\n            current.totalExcessKwh += interval.excessKwh;\n            current.intervalIndexes.push(index);\n        } else if (current) {\n            events.push(current);\n            current = null;\n        }\n    });\n    if (current) {\n        events.push(current);\n    }\n    return events;\n}\nfunction percentile(values, p) {\n    if (values.length === 0) return 0;\n    const sorted = [\n        ...values\n    ].sort((a, b)=>a - b);\n    const idx = Math.ceil(p / 100 * sorted.length) - 1;\n    return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\n}\nfunction computeSizing(params) {\n    const { intervals, events, method, compliance, safetyFactor, efficiency } = params;\n    let kWhNeededRaw = 0;\n    let kWNeededRaw = 0;\n    if (method === \"MAX_PEAK\") {\n        const highestEnergyEvent = [\n            ...events\n        ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n        if (highestEnergyEvent) {\n            kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n            kWNeededRaw = highestEnergyEvent.maxExcessKw;\n        }\n    }\n    if (method === \"P95\") {\n        if (events.length < 20) {\n            const highestEnergyEvent = [\n                ...events\n            ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n            if (highestEnergyEvent) {\n                kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n                kWNeededRaw = highestEnergyEvent.maxExcessKw;\n            }\n        } else {\n            kWhNeededRaw = percentile(events.map((event)=>event.totalExcessKwh), 95);\n            kWNeededRaw = percentile(events.map((event)=>event.maxExcessKw), 95);\n        }\n    }\n    if (method === \"FULL_COVERAGE\") {\n        const byDay = new Map();\n        intervals.forEach((interval)=>{\n            const day = interval.timestamp.slice(0, 10);\n            var _byDay_get;\n            const list = (_byDay_get = byDay.get(day)) !== null && _byDay_get !== void 0 ? _byDay_get : [];\n            list.push(interval);\n            byDay.set(day, list);\n        });\n        let maxDayEnergy = 0;\n        let maxDayPeak = 0;\n        byDay.forEach((dayIntervals)=>{\n            const dayEnergy = dayIntervals.reduce((sum, interval)=>sum + interval.excessKwh, 0);\n            if (dayEnergy > maxDayEnergy) {\n                maxDayEnergy = dayEnergy;\n                maxDayPeak = Math.max(...dayIntervals.map((interval)=>interval.excessKw));\n            }\n        });\n        kWhNeededRaw = maxDayEnergy;\n        kWNeededRaw = maxDayPeak;\n    }\n    kWhNeededRaw *= compliance;\n    kWNeededRaw *= compliance;\n    const kWhNeeded = kWhNeededRaw / efficiency * safetyFactor;\n    const kWNeeded = kWNeededRaw * safetyFactor;\n    var _BATTERY_OPTIONS_find;\n    const recommendedProduct = (_BATTERY_OPTIONS_find = BATTERY_OPTIONS.find((option)=>kWhNeeded <= option.capacityKwh)) !== null && _BATTERY_OPTIONS_find !== void 0 ? _BATTERY_OPTIONS_find : BATTERY_OPTIONS[BATTERY_OPTIONS.length - 1];\n    const recommendedIndex = BATTERY_OPTIONS.findIndex((option)=>option.capacityKwh === recommendedProduct.capacityKwh);\n    var _BATTERY_OPTIONS_;\n    const alternativeProduct = (_BATTERY_OPTIONS_ = BATTERY_OPTIONS[recommendedIndex + 1]) !== null && _BATTERY_OPTIONS_ !== void 0 ? _BATTERY_OPTIONS_ : null;\n    return {\n        kWhNeededRaw,\n        kWNeededRaw,\n        kWhNeeded,\n        kWNeeded,\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction buildDataQualityReport(intervals) {\n    var _timestamps_, _timestamps_1;\n    if (intervals.length === 0) {\n        return {\n            rows: 0,\n            startDate: null,\n            endDate: null,\n            missingIntervalsCount: 0,\n            duplicateCount: 0,\n            non15MinIntervals: 0,\n            warnings: [\n                \"No rows found in dataset.\"\n            ]\n        };\n    }\n    const timestamps = intervals.map((row)=>new Date(row.timestamp)).filter((date)=>!Number.isNaN(date.getTime())).sort((a, b)=>a.getTime() - b.getTime());\n    const duplicateCount = timestamps.length - new Set(timestamps.map((d)=>d.toISOString())).size;\n    let non15MinIntervals = 0;\n    let missingIntervalsCount = 0;\n    for(let i = 1; i < timestamps.length; i += 1){\n        const diffMinutes = (timestamps[i].getTime() - timestamps[i - 1].getTime()) / 60000;\n        if (diffMinutes !== 15) {\n            non15MinIntervals += 1;\n            if (diffMinutes > 15) {\n                missingIntervalsCount += Math.max(0, Math.round(diffMinutes / 15) - 1);\n            }\n        }\n    }\n    const warnings = [];\n    if (duplicateCount > 0) warnings.push(\"Detected \".concat(duplicateCount, \" duplicate timestamps.\"));\n    if (non15MinIntervals > 0) {\n        warnings.push(\"Detected \".concat(non15MinIntervals, \" non-15-minute interval transitions.\"));\n    }\n    var _timestamps__toISOString, _timestamps__toISOString1;\n    return {\n        rows: intervals.length,\n        startDate: (_timestamps__toISOString = (_timestamps_ = timestamps[0]) === null || _timestamps_ === void 0 ? void 0 : _timestamps_.toISOString()) !== null && _timestamps__toISOString !== void 0 ? _timestamps__toISOString : null,\n        endDate: (_timestamps__toISOString1 = (_timestamps_1 = timestamps[timestamps.length - 1]) === null || _timestamps_1 === void 0 ? void 0 : _timestamps_1.toISOString()) !== null && _timestamps__toISOString1 !== void 0 ? _timestamps__toISOString1 : null,\n        missingIntervalsCount,\n        duplicateCount,\n        non15MinIntervals,\n        warnings\n    };\n}\nfunction findMaxObserved(intervals) {\n    if (intervals.length === 0) {\n        return {\n            maxObservedKw: 0,\n            maxObservedTimestamp: null\n        };\n    }\n    let maxObservedKw = -1;\n    let maxObservedTimestamp = null;\n    intervals.forEach((interval)=>{\n        if (interval.consumptionKw > maxObservedKw || interval.consumptionKw === maxObservedKw && maxObservedTimestamp !== null && interval.timestamp < maxObservedTimestamp) {\n            maxObservedKw = interval.consumptionKw;\n            maxObservedTimestamp = interval.timestamp;\n        }\n    });\n    return {\n        maxObservedKw,\n        maxObservedTimestamp\n    };\n}\nfunction selectTopExceededIntervals(intervals, day) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;\n    return intervals.filter((interval)=>interval.timestamp.slice(0, 10) === day && interval.excessKw > 0).sort((a, b)=>b.excessKw - a.excessKw || a.timestamp.localeCompare(b.timestamp)).slice(0, limit).map((interval)=>({\n            timestamp: interval.timestamp,\n            consumption_kW: interval.consumptionKw,\n            excess_kW: interval.excessKw\n        }));\n}\nfunction buildDayProfile(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15;\n    if (!dayIso || intervalMinutes <= 0) return [];\n    const [year, month, day] = dayIso.split(\"-\").map(Number);\n    const dayStartLocal = new Date(year, month - 1, day, 0, 0, 0, 0);\n    if (Number.isNaN(dayStartLocal.getTime())) return [];\n    const slotsPerDay = Math.floor(24 * 60 / intervalMinutes);\n    const profile = Array.from({\n        length: slotsPerDay\n    }, (_, index)=>({\n            timestamp: new Date(dayStartLocal.getTime() + index * intervalMinutes * 60000).toISOString(),\n            observedKw: 0\n        }));\n    intervals.forEach((interval)=>{\n        if ((0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp) !== dayIso) return;\n        const dt = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(interval.timestamp);\n        if (Number.isNaN(dt.getTime())) return;\n        const minuteOfDay = dt.getHours() * 60 + dt.getMinutes();\n        const slotIndex = Math.floor(minuteOfDay / intervalMinutes);\n        if (slotIndex < 0 || slotIndex >= slotsPerDay) return;\n        profile[slotIndex].observedKw = Math.max(profile[slotIndex].observedKw, interval.consumptionKw);\n    });\n    return profile;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jYWxjdWxhdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTREO0FBNERyRCxNQUFNRSxrQkFBb0M7SUFDL0M7UUFBRUMsT0FBTztRQUFnQ0MsYUFBYTtJQUFHO0lBQ3pEO1FBQUVELE9BQU87UUFBZ0NDLGFBQWE7SUFBRztJQUN6RDtRQUFFRCxPQUFPO1FBQWtDQyxhQUFhO0lBQUk7SUFDNUQ7UUFBRUQsT0FBTztRQUEyQ0MsYUFBYTtJQUFLO0lBQ3RFO1FBQUVELE9BQU87UUFBMkNDLGFBQWE7SUFBSztDQUN2RSxDQUFDO0FBRUssU0FBU0MsaUJBQ2RDLElBQXNCLEVBQ3RCQyxpQkFBeUI7SUFFekIsT0FBT0QsS0FBS0UsR0FBRyxDQUFDLENBQUNDO1FBQ2YsTUFBTUMsWUFBWVQseURBQWNBLENBQUNRLElBQUlDLFNBQVM7UUFDOUMsTUFBTUMsc0JBQXNCQyxPQUFPQyxLQUFLLENBQUNILFVBQVVJLE9BQU8sTUFBTUwsSUFBSUMsU0FBUyxHQUFHQSxVQUFVSyxXQUFXO1FBQ3JHLE1BQU1DLGdCQUFnQlAsSUFBSVEsY0FBYyxHQUFHO1FBQzNDLE1BQU1DLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHSixnQkFBZ0JUO1FBQzdDLE9BQU87WUFDTCxHQUFHRSxHQUFHO1lBQ05DLFdBQVdDO1lBQ1hLO1lBQ0FFO1lBQ0FHLFdBQVdILFdBQVc7UUFDeEI7SUFDRjtBQUNGO0FBRU8sU0FBU0ksZ0JBQWdCQyxTQUE4QjtJQUM1RCxNQUFNQyxTQUFzQixFQUFFO0lBQzlCLElBQUlDLFVBQTRCO0lBRWhDRixVQUFVRyxPQUFPLENBQUMsQ0FBQ0MsVUFBVUM7UUFDM0IsSUFBSUQsU0FBU1QsUUFBUSxHQUFHLEdBQUc7WUFDekIsSUFBSSxDQUFDTyxTQUFTO2dCQUNaQSxVQUFVO29CQUNSSSxlQUFlRixTQUFTakIsU0FBUztvQkFDakNvQixtQkFBbUI7b0JBQ25CQyxhQUFhO29CQUNiQyxnQkFBZ0I7b0JBQ2hCQyxpQkFBaUIsRUFBRTtnQkFDckI7WUFDRjtZQUNBUixRQUFRSyxpQkFBaUIsSUFBSTtZQUM3QixJQUNFSCxTQUFTVCxRQUFRLEdBQUdPLFFBQVFNLFdBQVcsSUFDdENKLFNBQVNULFFBQVEsS0FBS08sUUFBUU0sV0FBVyxJQUFJSixTQUFTakIsU0FBUyxHQUFHZSxRQUFRSSxhQUFhLEVBQ3hGO2dCQUNBSixRQUFRTSxXQUFXLEdBQUdKLFNBQVNULFFBQVE7Z0JBQ3ZDTyxRQUFRSSxhQUFhLEdBQUdGLFNBQVNqQixTQUFTO1lBQzVDO1lBQ0FlLFFBQVFPLGNBQWMsSUFBSUwsU0FBU04sU0FBUztZQUM1Q0ksUUFBUVEsZUFBZSxDQUFDQyxJQUFJLENBQUNOO1FBQy9CLE9BQU8sSUFBSUgsU0FBUztZQUNsQkQsT0FBT1UsSUFBSSxDQUFDVDtZQUNaQSxVQUFVO1FBQ1o7SUFDRjtJQUVBLElBQUlBLFNBQVM7UUFDWEQsT0FBT1UsSUFBSSxDQUFDVDtJQUNkO0lBRUEsT0FBT0Q7QUFDVDtBQUVBLFNBQVNXLFdBQVdDLE1BQWdCLEVBQUVDLENBQVM7SUFDN0MsSUFBSUQsT0FBT0UsTUFBTSxLQUFLLEdBQUcsT0FBTztJQUNoQyxNQUFNQyxTQUFTO1dBQUlIO0tBQU8sQ0FBQ0ksSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDO0lBQzlDLE1BQU1DLE1BQU14QixLQUFLeUIsSUFBSSxDQUFDLElBQUssTUFBT0wsT0FBT0QsTUFBTSxJQUFJO0lBQ25ELE9BQU9DLE1BQU0sQ0FBQ3BCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLMEIsR0FBRyxDQUFDRixLQUFLSixPQUFPRCxNQUFNLEdBQUcsSUFBSTtBQUM5RDtBQUVPLFNBQVNRLGNBQWNDLE1BTzdCO0lBQ0MsTUFBTSxFQUFFeEIsU0FBUyxFQUFFQyxNQUFNLEVBQUV3QixNQUFNLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxFQUFFQyxVQUFVLEVBQUUsR0FBR0o7SUFFNUUsSUFBSUssZUFBZTtJQUNuQixJQUFJQyxjQUFjO0lBRWxCLElBQUlMLFdBQVcsWUFBWTtRQUN6QixNQUFNTSxxQkFBcUI7ZUFBSTlCO1NBQU8sQ0FBQ2dCLElBQUksQ0FDekMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRVYsY0FBYyxHQUFHUyxFQUFFVCxjQUFjLENBQzlDLENBQUMsRUFBRTtRQUNKLElBQUlzQixvQkFBb0I7WUFDdEJGLGVBQWVFLG1CQUFtQnRCLGNBQWM7WUFDaERxQixjQUFjQyxtQkFBbUJ2QixXQUFXO1FBQzlDO0lBQ0Y7SUFFQSxJQUFJaUIsV0FBVyxPQUFPO1FBQ3BCLElBQUl4QixPQUFPYyxNQUFNLEdBQUcsSUFBSTtZQUN0QixNQUFNZ0IscUJBQXFCO21CQUFJOUI7YUFBTyxDQUFDZ0IsSUFBSSxDQUN6QyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFVixjQUFjLEdBQUdTLEVBQUVULGNBQWMsQ0FDOUMsQ0FBQyxFQUFFO1lBQ0osSUFBSXNCLG9CQUFvQjtnQkFDdEJGLGVBQWVFLG1CQUFtQnRCLGNBQWM7Z0JBQ2hEcUIsY0FBY0MsbUJBQW1CdkIsV0FBVztZQUM5QztRQUNGLE9BQU87WUFDTHFCLGVBQWVqQixXQUNiWCxPQUFPaEIsR0FBRyxDQUFDLENBQUMrQyxRQUFVQSxNQUFNdkIsY0FBYyxHQUMxQztZQUVGcUIsY0FBY2xCLFdBQ1pYLE9BQU9oQixHQUFHLENBQUMsQ0FBQytDLFFBQVVBLE1BQU14QixXQUFXLEdBQ3ZDO1FBRUo7SUFDRjtJQUVBLElBQUlpQixXQUFXLGlCQUFpQjtRQUM5QixNQUFNUSxRQUFRLElBQUlDO1FBQ2xCbEMsVUFBVUcsT0FBTyxDQUFDLENBQUNDO1lBQ2pCLE1BQU0rQixNQUFNL0IsU0FBU2pCLFNBQVMsQ0FBQ2lELEtBQUssQ0FBQyxHQUFHO2dCQUMzQkg7WUFBYixNQUFNSSxPQUFPSixDQUFBQSxhQUFBQSxNQUFNSyxHQUFHLENBQUNILGtCQUFWRix3QkFBQUEsYUFBa0IsRUFBRTtZQUNqQ0ksS0FBSzFCLElBQUksQ0FBQ1A7WUFDVjZCLE1BQU1NLEdBQUcsQ0FBQ0osS0FBS0U7UUFDakI7UUFFQSxJQUFJRyxlQUFlO1FBQ25CLElBQUlDLGFBQWE7UUFFakJSLE1BQU05QixPQUFPLENBQUMsQ0FBQ3VDO1lBQ2IsTUFBTUMsWUFBWUQsYUFBYUUsTUFBTSxDQUFDLENBQUNDLEtBQUt6QyxXQUFheUMsTUFBTXpDLFNBQVNOLFNBQVMsRUFBRTtZQUNuRixJQUFJNkMsWUFBWUgsY0FBYztnQkFDNUJBLGVBQWVHO2dCQUNmRixhQUFhN0MsS0FBS0MsR0FBRyxJQUFJNkMsYUFBYXpELEdBQUcsQ0FBQyxDQUFDbUIsV0FBYUEsU0FBU1QsUUFBUTtZQUMzRTtRQUNGO1FBRUFrQyxlQUFlVztRQUNmVixjQUFjVztJQUNoQjtJQUVBWixnQkFBZ0JIO0lBQ2hCSSxlQUFlSjtJQUVmLE1BQU1vQixZQUFZLGVBQWdCbEIsYUFBY0Q7SUFDaEQsTUFBTW9CLFdBQVdqQixjQUFjSDtRQUVKaEQ7SUFBM0IsTUFBTXFFLHFCQUFxQnJFLENBQUFBLHdCQUFBQSxnQkFBZ0JzRSxJQUFJLENBQUMsQ0FBQ0MsU0FBV0osYUFBYUksT0FBT3JFLFdBQVcsZUFBaEVGLG1DQUFBQSx3QkFDekJBLGVBQWUsQ0FBQ0EsZ0JBQWdCb0MsTUFBTSxHQUFHLEVBQUU7SUFDN0MsTUFBTW9DLG1CQUFtQnhFLGdCQUFnQnlFLFNBQVMsQ0FDaEQsQ0FBQ0YsU0FBV0EsT0FBT3JFLFdBQVcsS0FBS21FLG1CQUFtQm5FLFdBQVc7UUFFeENGO0lBQTNCLE1BQU0wRSxxQkFBcUIxRSxDQUFBQSxvQkFBQUEsZUFBZSxDQUFDd0UsbUJBQW1CLEVBQUUsY0FBckN4RSwrQkFBQUEsb0JBQXlDO0lBRXBFLE9BQU87UUFDTGtEO1FBQ0FDO1FBQ0FnQjtRQUNBQztRQUNBQztRQUNBSztJQUNGO0FBQ0Y7QUFFTyxTQUFTQyx1QkFBdUJ0RCxTQUEyQjtRQXdDbkR1RCxjQUNGQTtJQXhDWCxJQUFJdkQsVUFBVWUsTUFBTSxLQUFLLEdBQUc7UUFDMUIsT0FBTztZQUNMaEMsTUFBTTtZQUNOeUUsV0FBVztZQUNYQyxTQUFTO1lBQ1RDLHVCQUF1QjtZQUN2QkMsZ0JBQWdCO1lBQ2hCQyxtQkFBbUI7WUFDbkJDLFVBQVU7Z0JBQUM7YUFBNEI7UUFDekM7SUFDRjtJQUVBLE1BQU1OLGFBQWF2RCxVQUNoQmYsR0FBRyxDQUFDLENBQUNDLE1BQVEsSUFBSTRFLEtBQUs1RSxJQUFJQyxTQUFTLEdBQ25DNEUsTUFBTSxDQUFDLENBQUNDLE9BQVMsQ0FBQzNFLE9BQU9DLEtBQUssQ0FBQzBFLEtBQUt6RSxPQUFPLEtBQzNDMEIsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUUzQixPQUFPLEtBQUs0QixFQUFFNUIsT0FBTztJQUV6QyxNQUFNb0UsaUJBQWlCSixXQUFXeEMsTUFBTSxHQUFHLElBQUlrRCxJQUFJVixXQUFXdEUsR0FBRyxDQUFDLENBQUNpRixJQUFNQSxFQUFFMUUsV0FBVyxLQUFLMkUsSUFBSTtJQUMvRixJQUFJUCxvQkFBb0I7SUFDeEIsSUFBSUYsd0JBQXdCO0lBRTVCLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJYixXQUFXeEMsTUFBTSxFQUFFcUQsS0FBSyxFQUFHO1FBQzdDLE1BQU1DLGNBQWMsQ0FBQ2QsVUFBVSxDQUFDYSxFQUFFLENBQUM3RSxPQUFPLEtBQUtnRSxVQUFVLENBQUNhLElBQUksRUFBRSxDQUFDN0UsT0FBTyxFQUFDLElBQUs7UUFDOUUsSUFBSThFLGdCQUFnQixJQUFJO1lBQ3RCVCxxQkFBcUI7WUFDckIsSUFBSVMsY0FBYyxJQUFJO2dCQUNwQlgseUJBQXlCOUQsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUswRSxLQUFLLENBQUNELGNBQWMsTUFBTTtZQUN0RTtRQUNGO0lBQ0Y7SUFFQSxNQUFNUixXQUFxQixFQUFFO0lBQzdCLElBQUlGLGlCQUFpQixHQUFHRSxTQUFTbEQsSUFBSSxDQUFDLFlBQTJCLE9BQWZnRCxnQkFBZTtJQUNqRSxJQUFJQyxvQkFBb0IsR0FBRztRQUN6QkMsU0FBU2xELElBQUksQ0FBQyxZQUE4QixPQUFsQmlELG1CQUFrQjtJQUM5QztRQUlhTCwwQkFDRkE7SUFIWCxPQUFPO1FBQ0x4RSxNQUFNaUIsVUFBVWUsTUFBTTtRQUN0QnlDLFdBQVdELENBQUFBLDRCQUFBQSxlQUFBQSxVQUFVLENBQUMsRUFBRSxjQUFiQSxtQ0FBQUEsYUFBZS9ELFdBQVcsZ0JBQTFCK0Qsc0NBQUFBLDJCQUFnQztRQUMzQ0UsU0FBU0YsQ0FBQUEsNkJBQUFBLGdCQUFBQSxVQUFVLENBQUNBLFdBQVd4QyxNQUFNLEdBQUcsRUFBRSxjQUFqQ3dDLG9DQUFBQSxjQUFtQy9ELFdBQVcsZ0JBQTlDK0QsdUNBQUFBLDRCQUFvRDtRQUM3REc7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtBQUNGO0FBRU8sU0FBU1UsZ0JBQWdCdkUsU0FBOEI7SUFJNUQsSUFBSUEsVUFBVWUsTUFBTSxLQUFLLEdBQUc7UUFDMUIsT0FBTztZQUNMeUQsZUFBZTtZQUNmQyxzQkFBc0I7UUFDeEI7SUFDRjtJQUVBLElBQUlELGdCQUFnQixDQUFDO0lBQ3JCLElBQUlDLHVCQUFzQztJQUUxQ3pFLFVBQVVHLE9BQU8sQ0FBQyxDQUFDQztRQUNqQixJQUNFQSxTQUFTWCxhQUFhLEdBQUcrRSxpQkFDeEJwRSxTQUFTWCxhQUFhLEtBQUsrRSxpQkFDMUJDLHlCQUF5QixRQUN6QnJFLFNBQVNqQixTQUFTLEdBQUdzRixzQkFDdkI7WUFDQUQsZ0JBQWdCcEUsU0FBU1gsYUFBYTtZQUN0Q2dGLHVCQUF1QnJFLFNBQVNqQixTQUFTO1FBQzNDO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xxRjtRQUNBQztJQUNGO0FBQ0Y7QUFFTyxTQUFTQywyQkFDZDFFLFNBQThCLEVBQzlCbUMsR0FBVztRQUNYd0MsUUFBQUEsaUVBQVE7SUFFUixPQUFPM0UsVUFDSitELE1BQU0sQ0FBQyxDQUFDM0QsV0FBYUEsU0FBU2pCLFNBQVMsQ0FBQ2lELEtBQUssQ0FBQyxHQUFHLFFBQVFELE9BQU8vQixTQUFTVCxRQUFRLEdBQUcsR0FDcEZzQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRXhCLFFBQVEsR0FBR3VCLEVBQUV2QixRQUFRLElBQUl1QixFQUFFL0IsU0FBUyxDQUFDeUYsYUFBYSxDQUFDekQsRUFBRWhDLFNBQVMsR0FDL0VpRCxLQUFLLENBQUMsR0FBR3VDLE9BQ1QxRixHQUFHLENBQUMsQ0FBQ21CLFdBQWM7WUFDbEJqQixXQUFXaUIsU0FBU2pCLFNBQVM7WUFDN0IwRixnQkFBZ0J6RSxTQUFTWCxhQUFhO1lBQ3RDcUYsV0FBVzFFLFNBQVNULFFBQVE7UUFDOUI7QUFDSjtBQUVPLFNBQVNvRixnQkFDZC9FLFNBQThCLEVBQzlCZ0YsTUFBYztRQUNkQyxrQkFBQUEsaUVBQWtCO0lBRWxCLElBQUksQ0FBQ0QsVUFBVUMsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0lBRTlDLE1BQU0sQ0FBQ0MsTUFBTUMsT0FBT2hELElBQUksR0FBRzZDLE9BQU9JLEtBQUssQ0FBQyxLQUFLbkcsR0FBRyxDQUFDSTtJQUNqRCxNQUFNZ0csZ0JBQWdCLElBQUl2QixLQUFLb0IsTUFBTUMsUUFBUSxHQUFHaEQsS0FBSyxHQUFHLEdBQUcsR0FBRztJQUM5RCxJQUFJOUMsT0FBT0MsS0FBSyxDQUFDK0YsY0FBYzlGLE9BQU8sS0FBSyxPQUFPLEVBQUU7SUFFcEQsTUFBTStGLGNBQWMxRixLQUFLMkYsS0FBSyxDQUFDLEtBQU0sS0FBTU47SUFDM0MsTUFBTU8sVUFBVUMsTUFBTUMsSUFBSSxDQUFDO1FBQUUzRSxRQUFRdUU7SUFBWSxHQUFHLENBQUNLLEdBQUd0RixRQUFXO1lBQ2pFbEIsV0FBVyxJQUFJMkUsS0FBS3VCLGNBQWM5RixPQUFPLEtBQUtjLFFBQVE0RSxrQkFBa0IsT0FBUXpGLFdBQVc7WUFDM0ZvRyxZQUFZO1FBQ2Q7SUFFQTVGLFVBQVVHLE9BQU8sQ0FBQyxDQUFDQztRQUNqQixJQUFJM0IseURBQWNBLENBQUMyQixTQUFTakIsU0FBUyxNQUFNNkYsUUFBUTtRQUVuRCxNQUFNYSxLQUFLbkgseURBQWNBLENBQUMwQixTQUFTakIsU0FBUztRQUM1QyxJQUFJRSxPQUFPQyxLQUFLLENBQUN1RyxHQUFHdEcsT0FBTyxLQUFLO1FBQ2hDLE1BQU11RyxjQUFjRCxHQUFHRSxRQUFRLEtBQUssS0FBS0YsR0FBR0csVUFBVTtRQUN0RCxNQUFNQyxZQUFZckcsS0FBSzJGLEtBQUssQ0FBQ08sY0FBY2I7UUFDM0MsSUFBSWdCLFlBQVksS0FBS0EsYUFBYVgsYUFBYTtRQUUvQ0UsT0FBTyxDQUFDUyxVQUFVLENBQUNMLFVBQVUsR0FBR2hHLEtBQUtDLEdBQUcsQ0FBQzJGLE9BQU8sQ0FBQ1MsVUFBVSxDQUFDTCxVQUFVLEVBQUV4RixTQUFTWCxhQUFhO0lBQ2hHO0lBRUEsT0FBTytGO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2NhbGN1bGF0aW9ucy50cz8zZjc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExvY2FsRGF5SXNvLCBwYXJzZVRpbWVzdGFtcCB9IGZyb20gJy4vZGF0ZXRpbWUnO1xuXG5leHBvcnQgdHlwZSBNZXRob2QgPSAnTUFYX1BFQUsnIHwgJ1A5NScgfCAnRlVMTF9DT1ZFUkFHRSc7XG5cclxuZXhwb3J0IGludGVyZmFjZSBJbnRlcnZhbFJlY29yZCB7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgY29uc3VtcHRpb25Ld2g6IG51bWJlcjtcclxuICBleHBvcnRLd2g/OiBudW1iZXI7XHJcbiAgcHZLd2g/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2VkSW50ZXJ2YWwgZXh0ZW5kcyBJbnRlcnZhbFJlY29yZCB7XHJcbiAgY29uc3VtcHRpb25LdzogbnVtYmVyO1xyXG4gIGV4Y2Vzc0t3OiBudW1iZXI7XHJcbiAgZXhjZXNzS3doOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGVha0V2ZW50IHtcbiAgcGVha1RpbWVzdGFtcDogc3RyaW5nO1xuICBkdXJhdGlvbkludGVydmFsczogbnVtYmVyO1xuICBtYXhFeGNlc3NLdzogbnVtYmVyO1xuICB0b3RhbEV4Y2Vzc0t3aDogbnVtYmVyO1xuICBpbnRlcnZhbEluZGV4ZXM6IG51bWJlcltdO1xufVxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVF1YWxpdHlSZXBvcnQge1xyXG4gIHJvd3M6IG51bWJlcjtcclxuICBzdGFydERhdGU6IHN0cmluZyB8IG51bGw7XHJcbiAgZW5kRGF0ZTogc3RyaW5nIHwgbnVsbDtcclxuICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQ6IG51bWJlcjtcclxuICBkdXBsaWNhdGVDb3VudDogbnVtYmVyO1xyXG4gIG5vbjE1TWluSW50ZXJ2YWxzOiBudW1iZXI7XHJcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNpemluZ1Jlc3VsdCB7XHJcbiAga1doTmVlZGVkUmF3OiBudW1iZXI7XHJcbiAga1dOZWVkZWRSYXc6IG51bWJlcjtcclxuICBrV2hOZWVkZWQ6IG51bWJlcjtcclxuICBrV05lZWRlZDogbnVtYmVyO1xyXG4gIHJlY29tbWVuZGVkUHJvZHVjdDogQmF0dGVyeVByb2R1Y3Q7XHJcbiAgYWx0ZXJuYXRpdmVQcm9kdWN0OiBCYXR0ZXJ5UHJvZHVjdCB8IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmF0dGVyeVByb2R1Y3Qge1xuICBsYWJlbDogc3RyaW5nO1xuICBjYXBhY2l0eUt3aDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4Y2VlZGVkSW50ZXJ2YWwge1xuICB0aW1lc3RhbXA6IHN0cmluZztcbiAgY29uc3VtcHRpb25fa1c6IG51bWJlcjtcbiAgZXhjZXNzX2tXOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5UHJvZmlsZVBvaW50IHtcbiAgdGltZXN0YW1wOiBzdHJpbmc7XG4gIG9ic2VydmVkS3c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IEJBVFRFUllfT1BUSU9OUzogQmF0dGVyeVByb2R1Y3RbXSA9IFtcbiAgeyBsYWJlbDogJ1dhdHRzTmV4dCBFU1MgQ2FiaW5ldCA2NCBrV2gnLCBjYXBhY2l0eUt3aDogNjQgfSxcclxuICB7IGxhYmVsOiAnV2F0dHNOZXh0IEVTUyBDYWJpbmV0IDk2IGtXaCcsIGNhcGFjaXR5S3doOiA5NiB9LFxyXG4gIHsgbGFiZWw6ICdFU1MgQWxsLWluLW9uZSBDYWJpbmV0IDI2MSBrV2gnLCBjYXBhY2l0eUt3aDogMjYxIH0sXHJcbiAgeyBsYWJlbDogJ1dhdHRzTmV4dCBBbGwtaW4tb25lIENvbnRhaW5lciAyLjA5IE1XaCcsIGNhcGFjaXR5S3doOiAyMDkwIH0sXHJcbiAgeyBsYWJlbDogJ1dhdHRzTmV4dCBBbGwgaW4tb25lIENvbnRhaW5lciA1LjAxIE1XaCcsIGNhcGFjaXR5S3doOiA1MDEwIH1cclxuXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzSW50ZXJ2YWxzKFxuICByb3dzOiBJbnRlcnZhbFJlY29yZFtdLFxuICBjb250cmFjdGVkUG93ZXJLdzogbnVtYmVyXG4pOiBQcm9jZXNzZWRJbnRlcnZhbFtdIHtcbiAgcmV0dXJuIHJvd3MubWFwKChyb3cpID0+IHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZVRpbWVzdGFtcChyb3cudGltZXN0YW1wKTtcbiAgICBjb25zdCBub3JtYWxpemVkVGltZXN0YW1wID0gTnVtYmVyLmlzTmFOKHRpbWVzdGFtcC5nZXRUaW1lKCkpID8gcm93LnRpbWVzdGFtcCA6IHRpbWVzdGFtcC50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IGNvbnN1bXB0aW9uS3cgPSByb3cuY29uc3VtcHRpb25Ld2ggLyAwLjI1O1xuICAgIGNvbnN0IGV4Y2Vzc0t3ID0gTWF0aC5tYXgoMCwgY29uc3VtcHRpb25LdyAtIGNvbnRyYWN0ZWRQb3dlckt3KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucm93LFxuICAgICAgdGltZXN0YW1wOiBub3JtYWxpemVkVGltZXN0YW1wLFxuICAgICAgY29uc3VtcHRpb25LdyxcbiAgICAgIGV4Y2Vzc0t3LFxuICAgICAgZXhjZXNzS3doOiBleGNlc3NLdyAqIDAuMjVcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBQZWFrRXZlbnRzKGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSk6IFBlYWtFdmVudFtdIHtcbiAgY29uc3QgZXZlbnRzOiBQZWFrRXZlbnRbXSA9IFtdO1xuICBsZXQgY3VycmVudDogUGVha0V2ZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbnRlcnZhbC5leGNlc3NLdyA+IDApIHtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICBjdXJyZW50ID0ge1xuICAgICAgICAgIHBlYWtUaW1lc3RhbXA6IGludGVydmFsLnRpbWVzdGFtcCxcbiAgICAgICAgICBkdXJhdGlvbkludGVydmFsczogMCxcbiAgICAgICAgICBtYXhFeGNlc3NLdzogMCxcbiAgICAgICAgICB0b3RhbEV4Y2Vzc0t3aDogMCxcbiAgICAgICAgICBpbnRlcnZhbEluZGV4ZXM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjdXJyZW50LmR1cmF0aW9uSW50ZXJ2YWxzICs9IDE7XG4gICAgICBpZiAoXG4gICAgICAgIGludGVydmFsLmV4Y2Vzc0t3ID4gY3VycmVudC5tYXhFeGNlc3NLdyB8fFxuICAgICAgICAoaW50ZXJ2YWwuZXhjZXNzS3cgPT09IGN1cnJlbnQubWF4RXhjZXNzS3cgJiYgaW50ZXJ2YWwudGltZXN0YW1wIDwgY3VycmVudC5wZWFrVGltZXN0YW1wKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnQubWF4RXhjZXNzS3cgPSBpbnRlcnZhbC5leGNlc3NLdztcbiAgICAgICAgY3VycmVudC5wZWFrVGltZXN0YW1wID0gaW50ZXJ2YWwudGltZXN0YW1wO1xuICAgICAgfVxuICAgICAgY3VycmVudC50b3RhbEV4Y2Vzc0t3aCArPSBpbnRlcnZhbC5leGNlc3NLd2g7XG4gICAgICBjdXJyZW50LmludGVydmFsSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGV2ZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKGN1cnJlbnQpIHtcclxuICAgIGV2ZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGV2ZW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gcGVyY2VudGlsZSh2YWx1ZXM6IG51bWJlcltdLCBwOiBudW1iZXIpOiBudW1iZXIge1xyXG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcclxuICBjb25zdCBzb3J0ZWQgPSBbLi4udmFsdWVzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgY29uc3QgaWR4ID0gTWF0aC5jZWlsKChwIC8gMTAwKSAqIHNvcnRlZC5sZW5ndGgpIC0gMTtcclxuICByZXR1cm4gc29ydGVkW01hdGgubWF4KDAsIE1hdGgubWluKGlkeCwgc29ydGVkLmxlbmd0aCAtIDEpKV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2l6aW5nKHBhcmFtczoge1xyXG4gIGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXTtcclxuICBldmVudHM6IFBlYWtFdmVudFtdO1xyXG4gIG1ldGhvZDogTWV0aG9kO1xyXG4gIGNvbXBsaWFuY2U6IG51bWJlcjtcclxuICBzYWZldHlGYWN0b3I6IG51bWJlcjtcclxuICBlZmZpY2llbmN5OiBudW1iZXI7XHJcbn0pOiBTaXppbmdSZXN1bHQge1xyXG4gIGNvbnN0IHsgaW50ZXJ2YWxzLCBldmVudHMsIG1ldGhvZCwgY29tcGxpYW5jZSwgc2FmZXR5RmFjdG9yLCBlZmZpY2llbmN5IH0gPSBwYXJhbXM7XHJcblxyXG4gIGxldCBrV2hOZWVkZWRSYXcgPSAwO1xyXG4gIGxldCBrV05lZWRlZFJhdyA9IDA7XHJcblxyXG4gIGlmIChtZXRob2QgPT09ICdNQVhfUEVBSycpIHtcclxuICAgIGNvbnN0IGhpZ2hlc3RFbmVyZ3lFdmVudCA9IFsuLi5ldmVudHNdLnNvcnQoXHJcbiAgICAgIChhLCBiKSA9PiBiLnRvdGFsRXhjZXNzS3doIC0gYS50b3RhbEV4Y2Vzc0t3aFxyXG4gICAgKVswXTtcclxuICAgIGlmIChoaWdoZXN0RW5lcmd5RXZlbnQpIHtcclxuICAgICAga1doTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50LnRvdGFsRXhjZXNzS3doO1xyXG4gICAgICBrV05lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC5tYXhFeGNlc3NLdztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChtZXRob2QgPT09ICdQOTUnKSB7XHJcbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA8IDIwKSB7XHJcbiAgICAgIGNvbnN0IGhpZ2hlc3RFbmVyZ3lFdmVudCA9IFsuLi5ldmVudHNdLnNvcnQoXHJcbiAgICAgICAgKGEsIGIpID0+IGIudG90YWxFeGNlc3NLd2ggLSBhLnRvdGFsRXhjZXNzS3doXHJcbiAgICAgIClbMF07XHJcbiAgICAgIGlmIChoaWdoZXN0RW5lcmd5RXZlbnQpIHtcclxuICAgICAgICBrV2hOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQudG90YWxFeGNlc3NLd2g7XHJcbiAgICAgICAga1dOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQubWF4RXhjZXNzS3c7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGtXaE5lZWRlZFJhdyA9IHBlcmNlbnRpbGUoXHJcbiAgICAgICAgZXZlbnRzLm1hcCgoZXZlbnQpID0+IGV2ZW50LnRvdGFsRXhjZXNzS3doKSxcclxuICAgICAgICA5NVxyXG4gICAgICApO1xyXG4gICAgICBrV05lZWRlZFJhdyA9IHBlcmNlbnRpbGUoXHJcbiAgICAgICAgZXZlbnRzLm1hcCgoZXZlbnQpID0+IGV2ZW50Lm1heEV4Y2Vzc0t3KSxcclxuICAgICAgICA5NVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ0ZVTExfQ09WRVJBR0UnKSB7XHJcbiAgICBjb25zdCBieURheSA9IG5ldyBNYXA8c3RyaW5nLCBQcm9jZXNzZWRJbnRlcnZhbFtdPigpO1xyXG4gICAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRheSA9IGludGVydmFsLnRpbWVzdGFtcC5zbGljZSgwLCAxMCk7XHJcbiAgICAgIGNvbnN0IGxpc3QgPSBieURheS5nZXQoZGF5KSA/PyBbXTtcclxuICAgICAgbGlzdC5wdXNoKGludGVydmFsKTtcclxuICAgICAgYnlEYXkuc2V0KGRheSwgbGlzdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgbWF4RGF5RW5lcmd5ID0gMDtcclxuICAgIGxldCBtYXhEYXlQZWFrID0gMDtcclxuXHJcbiAgICBieURheS5mb3JFYWNoKChkYXlJbnRlcnZhbHMpID0+IHtcclxuICAgICAgY29uc3QgZGF5RW5lcmd5ID0gZGF5SW50ZXJ2YWxzLnJlZHVjZSgoc3VtLCBpbnRlcnZhbCkgPT4gc3VtICsgaW50ZXJ2YWwuZXhjZXNzS3doLCAwKTtcclxuICAgICAgaWYgKGRheUVuZXJneSA+IG1heERheUVuZXJneSkge1xyXG4gICAgICAgIG1heERheUVuZXJneSA9IGRheUVuZXJneTtcclxuICAgICAgICBtYXhEYXlQZWFrID0gTWF0aC5tYXgoLi4uZGF5SW50ZXJ2YWxzLm1hcCgoaW50ZXJ2YWwpID0+IGludGVydmFsLmV4Y2Vzc0t3KSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGtXaE5lZWRlZFJhdyA9IG1heERheUVuZXJneTtcclxuICAgIGtXTmVlZGVkUmF3ID0gbWF4RGF5UGVhaztcclxuICB9XHJcblxyXG4gIGtXaE5lZWRlZFJhdyAqPSBjb21wbGlhbmNlO1xyXG4gIGtXTmVlZGVkUmF3ICo9IGNvbXBsaWFuY2U7XHJcblxyXG4gIGNvbnN0IGtXaE5lZWRlZCA9IChrV2hOZWVkZWRSYXcgLyBlZmZpY2llbmN5KSAqIHNhZmV0eUZhY3RvcjtcclxuICBjb25zdCBrV05lZWRlZCA9IGtXTmVlZGVkUmF3ICogc2FmZXR5RmFjdG9yO1xyXG5cclxuICBjb25zdCByZWNvbW1lbmRlZFByb2R1Y3QgPSBCQVRURVJZX09QVElPTlMuZmluZCgob3B0aW9uKSA9PiBrV2hOZWVkZWQgPD0gb3B0aW9uLmNhcGFjaXR5S3doKSA/P1xyXG4gICAgQkFUVEVSWV9PUFRJT05TW0JBVFRFUllfT1BUSU9OUy5sZW5ndGggLSAxXTtcclxuICBjb25zdCByZWNvbW1lbmRlZEluZGV4ID0gQkFUVEVSWV9PUFRJT05TLmZpbmRJbmRleChcclxuICAgIChvcHRpb24pID0+IG9wdGlvbi5jYXBhY2l0eUt3aCA9PT0gcmVjb21tZW5kZWRQcm9kdWN0LmNhcGFjaXR5S3doXHJcbiAgKTtcclxuICBjb25zdCBhbHRlcm5hdGl2ZVByb2R1Y3QgPSBCQVRURVJZX09QVElPTlNbcmVjb21tZW5kZWRJbmRleCArIDFdID8/IG51bGw7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBrV2hOZWVkZWRSYXcsXHJcbiAgICBrV05lZWRlZFJhdyxcclxuICAgIGtXaE5lZWRlZCxcclxuICAgIGtXTmVlZGVkLFxyXG4gICAgcmVjb21tZW5kZWRQcm9kdWN0LFxyXG4gICAgYWx0ZXJuYXRpdmVQcm9kdWN0XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGF0YVF1YWxpdHlSZXBvcnQoaW50ZXJ2YWxzOiBJbnRlcnZhbFJlY29yZFtdKTogRGF0YVF1YWxpdHlSZXBvcnQge1xuICBpZiAoaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcm93czogMCxcclxuICAgICAgc3RhcnREYXRlOiBudWxsLFxyXG4gICAgICBlbmREYXRlOiBudWxsLFxyXG4gICAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQ6IDAsXHJcbiAgICAgIGR1cGxpY2F0ZUNvdW50OiAwLFxyXG4gICAgICBub24xNU1pbkludGVydmFsczogMCxcclxuICAgICAgd2FybmluZ3M6IFsnTm8gcm93cyBmb3VuZCBpbiBkYXRhc2V0LiddXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdGltZXN0YW1wcyA9IGludGVydmFsc1xyXG4gICAgLm1hcCgocm93KSA9PiBuZXcgRGF0ZShyb3cudGltZXN0YW1wKSlcclxuICAgIC5maWx0ZXIoKGRhdGUpID0+ICFOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKVxyXG4gICAgLnNvcnQoKGEsIGIpID0+IGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCkpO1xyXG5cclxuICBjb25zdCBkdXBsaWNhdGVDb3VudCA9IHRpbWVzdGFtcHMubGVuZ3RoIC0gbmV3IFNldCh0aW1lc3RhbXBzLm1hcCgoZCkgPT4gZC50b0lTT1N0cmluZygpKSkuc2l6ZTtcclxuICBsZXQgbm9uMTVNaW5JbnRlcnZhbHMgPSAwO1xyXG4gIGxldCBtaXNzaW5nSW50ZXJ2YWxzQ291bnQgPSAwO1xyXG5cclxuICBmb3IgKGxldCBpID0gMTsgaSA8IHRpbWVzdGFtcHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgIGNvbnN0IGRpZmZNaW51dGVzID0gKHRpbWVzdGFtcHNbaV0uZ2V0VGltZSgpIC0gdGltZXN0YW1wc1tpIC0gMV0uZ2V0VGltZSgpKSAvIDYwMDAwO1xyXG4gICAgaWYgKGRpZmZNaW51dGVzICE9PSAxNSkge1xyXG4gICAgICBub24xNU1pbkludGVydmFscyArPSAxO1xyXG4gICAgICBpZiAoZGlmZk1pbnV0ZXMgPiAxNSkge1xyXG4gICAgICAgIG1pc3NpbmdJbnRlcnZhbHNDb3VudCArPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKGRpZmZNaW51dGVzIC8gMTUpIC0gMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGlmIChkdXBsaWNhdGVDb3VudCA+IDApIHdhcm5pbmdzLnB1c2goYERldGVjdGVkICR7ZHVwbGljYXRlQ291bnR9IGR1cGxpY2F0ZSB0aW1lc3RhbXBzLmApO1xyXG4gIGlmIChub24xNU1pbkludGVydmFscyA+IDApIHtcclxuICAgIHdhcm5pbmdzLnB1c2goYERldGVjdGVkICR7bm9uMTVNaW5JbnRlcnZhbHN9IG5vbi0xNS1taW51dGUgaW50ZXJ2YWwgdHJhbnNpdGlvbnMuYCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcm93czogaW50ZXJ2YWxzLmxlbmd0aCxcclxuICAgIHN0YXJ0RGF0ZTogdGltZXN0YW1wc1swXT8udG9JU09TdHJpbmcoKSA/PyBudWxsLFxyXG4gICAgZW5kRGF0ZTogdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdPy50b0lTT1N0cmluZygpID8/IG51bGwsXHJcbiAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQsXHJcbiAgICBkdXBsaWNhdGVDb3VudCxcclxuICAgIG5vbjE1TWluSW50ZXJ2YWxzLFxyXG4gICAgd2FybmluZ3NcclxuICB9O1xyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWF4T2JzZXJ2ZWQoaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdKToge1xuICBtYXhPYnNlcnZlZEt3OiBudW1iZXI7XG4gIG1heE9ic2VydmVkVGltZXN0YW1wOiBzdHJpbmcgfCBudWxsO1xufSB7XG4gIGlmIChpbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heE9ic2VydmVkS3c6IDAsXG4gICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcDogbnVsbFxuICAgIH07XG4gIH1cblxuICBsZXQgbWF4T2JzZXJ2ZWRLdyA9IC0xO1xuICBsZXQgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGludGVydmFsLmNvbnN1bXB0aW9uS3cgPiBtYXhPYnNlcnZlZEt3IHx8XG4gICAgICAoaW50ZXJ2YWwuY29uc3VtcHRpb25LdyA9PT0gbWF4T2JzZXJ2ZWRLdyAmJlxuICAgICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcCAhPT0gbnVsbCAmJlxuICAgICAgICBpbnRlcnZhbC50aW1lc3RhbXAgPCBtYXhPYnNlcnZlZFRpbWVzdGFtcClcbiAgICApIHtcbiAgICAgIG1heE9ic2VydmVkS3cgPSBpbnRlcnZhbC5jb25zdW1wdGlvbkt3O1xuICAgICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXAgPSBpbnRlcnZhbC50aW1lc3RhbXA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIG1heE9ic2VydmVkS3csXG4gICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFRvcEV4Y2VlZGVkSW50ZXJ2YWxzKFxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10sXG4gIGRheTogc3RyaW5nLFxuICBsaW1pdCA9IDIwXG4pOiBFeGNlZWRlZEludGVydmFsW10ge1xuICByZXR1cm4gaW50ZXJ2YWxzXG4gICAgLmZpbHRlcigoaW50ZXJ2YWwpID0+IGludGVydmFsLnRpbWVzdGFtcC5zbGljZSgwLCAxMCkgPT09IGRheSAmJiBpbnRlcnZhbC5leGNlc3NLdyA+IDApXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuZXhjZXNzS3cgLSBhLmV4Y2Vzc0t3IHx8IGEudGltZXN0YW1wLmxvY2FsZUNvbXBhcmUoYi50aW1lc3RhbXApKVxuICAgIC5zbGljZSgwLCBsaW1pdClcbiAgICAubWFwKChpbnRlcnZhbCkgPT4gKHtcbiAgICAgIHRpbWVzdGFtcDogaW50ZXJ2YWwudGltZXN0YW1wLFxuICAgICAgY29uc3VtcHRpb25fa1c6IGludGVydmFsLmNvbnN1bXB0aW9uS3csXG4gICAgICBleGNlc3Nfa1c6IGludGVydmFsLmV4Y2Vzc0t3XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXlQcm9maWxlKFxuICBpbnRlcnZhbHM6IFByb2Nlc3NlZEludGVydmFsW10sXG4gIGRheUlzbzogc3RyaW5nLFxuICBpbnRlcnZhbE1pbnV0ZXMgPSAxNVxuKTogRGF5UHJvZmlsZVBvaW50W10ge1xuICBpZiAoIWRheUlzbyB8fCBpbnRlcnZhbE1pbnV0ZXMgPD0gMCkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IFt5ZWFyLCBtb250aCwgZGF5XSA9IGRheUlzby5zcGxpdCgnLScpLm1hcChOdW1iZXIpO1xuICBjb25zdCBkYXlTdGFydExvY2FsID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIDAsIDAsIDAsIDApO1xuICBpZiAoTnVtYmVyLmlzTmFOKGRheVN0YXJ0TG9jYWwuZ2V0VGltZSgpKSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IHNsb3RzUGVyRGF5ID0gTWF0aC5mbG9vcigoMjQgKiA2MCkgLyBpbnRlcnZhbE1pbnV0ZXMpO1xuICBjb25zdCBwcm9maWxlID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogc2xvdHNQZXJEYXkgfSwgKF8sIGluZGV4KSA9PiAoe1xuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoZGF5U3RhcnRMb2NhbC5nZXRUaW1lKCkgKyBpbmRleCAqIGludGVydmFsTWludXRlcyAqIDYwXzAwMCkudG9JU09TdHJpbmcoKSxcbiAgICBvYnNlcnZlZEt3OiAwXG4gIH0pKTtcblxuICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcbiAgICBpZiAoZ2V0TG9jYWxEYXlJc28oaW50ZXJ2YWwudGltZXN0YW1wKSAhPT0gZGF5SXNvKSByZXR1cm47XG5cbiAgICBjb25zdCBkdCA9IHBhcnNlVGltZXN0YW1wKGludGVydmFsLnRpbWVzdGFtcCk7XG4gICAgaWYgKE51bWJlci5pc05hTihkdC5nZXRUaW1lKCkpKSByZXR1cm47XG4gICAgY29uc3QgbWludXRlT2ZEYXkgPSBkdC5nZXRIb3VycygpICogNjAgKyBkdC5nZXRNaW51dGVzKCk7XG4gICAgY29uc3Qgc2xvdEluZGV4ID0gTWF0aC5mbG9vcihtaW51dGVPZkRheSAvIGludGVydmFsTWludXRlcyk7XG4gICAgaWYgKHNsb3RJbmRleCA8IDAgfHwgc2xvdEluZGV4ID49IHNsb3RzUGVyRGF5KSByZXR1cm47XG5cbiAgICBwcm9maWxlW3Nsb3RJbmRleF0ub2JzZXJ2ZWRLdyA9IE1hdGgubWF4KHByb2ZpbGVbc2xvdEluZGV4XS5vYnNlcnZlZEt3LCBpbnRlcnZhbC5jb25zdW1wdGlvbkt3KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByb2ZpbGU7XG59XG4iXSwibmFtZXMiOlsiZ2V0TG9jYWxEYXlJc28iLCJwYXJzZVRpbWVzdGFtcCIsIkJBVFRFUllfT1BUSU9OUyIsImxhYmVsIiwiY2FwYWNpdHlLd2giLCJwcm9jZXNzSW50ZXJ2YWxzIiwicm93cyIsImNvbnRyYWN0ZWRQb3dlckt3IiwibWFwIiwicm93IiwidGltZXN0YW1wIiwibm9ybWFsaXplZFRpbWVzdGFtcCIsIk51bWJlciIsImlzTmFOIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwiY29uc3VtcHRpb25LdyIsImNvbnN1bXB0aW9uS3doIiwiZXhjZXNzS3ciLCJNYXRoIiwibWF4IiwiZXhjZXNzS3doIiwiZ3JvdXBQZWFrRXZlbnRzIiwiaW50ZXJ2YWxzIiwiZXZlbnRzIiwiY3VycmVudCIsImZvckVhY2giLCJpbnRlcnZhbCIsImluZGV4IiwicGVha1RpbWVzdGFtcCIsImR1cmF0aW9uSW50ZXJ2YWxzIiwibWF4RXhjZXNzS3ciLCJ0b3RhbEV4Y2Vzc0t3aCIsImludGVydmFsSW5kZXhlcyIsInB1c2giLCJwZXJjZW50aWxlIiwidmFsdWVzIiwicCIsImxlbmd0aCIsInNvcnRlZCIsInNvcnQiLCJhIiwiYiIsImlkeCIsImNlaWwiLCJtaW4iLCJjb21wdXRlU2l6aW5nIiwicGFyYW1zIiwibWV0aG9kIiwiY29tcGxpYW5jZSIsInNhZmV0eUZhY3RvciIsImVmZmljaWVuY3kiLCJrV2hOZWVkZWRSYXciLCJrV05lZWRlZFJhdyIsImhpZ2hlc3RFbmVyZ3lFdmVudCIsImV2ZW50IiwiYnlEYXkiLCJNYXAiLCJkYXkiLCJzbGljZSIsImxpc3QiLCJnZXQiLCJzZXQiLCJtYXhEYXlFbmVyZ3kiLCJtYXhEYXlQZWFrIiwiZGF5SW50ZXJ2YWxzIiwiZGF5RW5lcmd5IiwicmVkdWNlIiwic3VtIiwia1doTmVlZGVkIiwia1dOZWVkZWQiLCJyZWNvbW1lbmRlZFByb2R1Y3QiLCJmaW5kIiwib3B0aW9uIiwicmVjb21tZW5kZWRJbmRleCIsImZpbmRJbmRleCIsImFsdGVybmF0aXZlUHJvZHVjdCIsImJ1aWxkRGF0YVF1YWxpdHlSZXBvcnQiLCJ0aW1lc3RhbXBzIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsIm1pc3NpbmdJbnRlcnZhbHNDb3VudCIsImR1cGxpY2F0ZUNvdW50Iiwibm9uMTVNaW5JbnRlcnZhbHMiLCJ3YXJuaW5ncyIsIkRhdGUiLCJmaWx0ZXIiLCJkYXRlIiwiU2V0IiwiZCIsInNpemUiLCJpIiwiZGlmZk1pbnV0ZXMiLCJyb3VuZCIsImZpbmRNYXhPYnNlcnZlZCIsIm1heE9ic2VydmVkS3ciLCJtYXhPYnNlcnZlZFRpbWVzdGFtcCIsInNlbGVjdFRvcEV4Y2VlZGVkSW50ZXJ2YWxzIiwibGltaXQiLCJsb2NhbGVDb21wYXJlIiwiY29uc3VtcHRpb25fa1ciLCJleGNlc3Nfa1ciLCJidWlsZERheVByb2ZpbGUiLCJkYXlJc28iLCJpbnRlcnZhbE1pbnV0ZXMiLCJ5ZWFyIiwibW9udGgiLCJzcGxpdCIsImRheVN0YXJ0TG9jYWwiLCJzbG90c1BlckRheSIsImZsb29yIiwicHJvZmlsZSIsIkFycmF5IiwiZnJvbSIsIl8iLCJvYnNlcnZlZEt3IiwiZHQiLCJtaW51dGVPZkRheSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsInNsb3RJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});