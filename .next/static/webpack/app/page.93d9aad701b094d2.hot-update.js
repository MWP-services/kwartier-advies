"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BATTERY_OPTIONS: function() { return /* binding */ BATTERY_OPTIONS; },\n/* harmony export */   buildDataQualityReport: function() { return /* binding */ buildDataQualityReport; },\n/* harmony export */   buildDayProfile: function() { return /* binding */ buildDayProfile; },\n/* harmony export */   computeSizing: function() { return /* binding */ computeSizing; },\n/* harmony export */   findMaxObserved: function() { return /* binding */ findMaxObserved; },\n/* harmony export */   groupPeakEvents: function() { return /* binding */ groupPeakEvents; },\n/* harmony export */   processIntervals: function() { return /* binding */ processIntervals; },\n/* harmony export */   selectMinimumCostBatteryOptions: function() { return /* binding */ selectMinimumCostBatteryOptions; },\n/* harmony export */   selectTopExceededIntervals: function() { return /* binding */ selectTopExceededIntervals; }\n/* harmony export */ });\n/* harmony import */ var _datetime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime */ \"(app-pages-browser)/./lib/datetime.ts\");\n\nconst BATTERY_OPTIONS = [\n    {\n        label: \"WattsNext ESS Cabinet 64 kWh\",\n        capacityKwh: 64,\n        modular: true,\n        unitPriceEur: 15689.33\n    },\n    {\n        label: \"WattsNext ESS Cabinet 96 kWh\",\n        capacityKwh: 96,\n        modular: true,\n        unitPriceEur: 22225.98\n    },\n    {\n        label: \"ESS All-in-one Cabinet 261 kWh\",\n        capacityKwh: 261,\n        modular: true,\n        unitPriceEur: 43995.96\n    },\n    {\n        label: \"WattsNext All-in-one Container 2.09 MWh\",\n        capacityKwh: 2090,\n        modular: false,\n        unitPriceEur: 318658.06\n    },\n    {\n        label: \"WattsNext All in-one Container 5.015 MWh\",\n        capacityKwh: 5015,\n        modular: false,\n        unitPriceEur: 675052.49\n    }\n];\nfunction roundCurrency(value) {\n    return Math.round(value * 100) / 100;\n}\nfunction toBatteryProduct(candidate) {\n    const totalPriceEur = roundCurrency(candidate.totalPriceEur);\n    return {\n        label: candidate.label,\n        capacityKwh: candidate.totalCapacityKwh,\n        unitCapacityKwh: candidate.unitCapacityKwh,\n        count: candidate.count,\n        unitPriceEur: roundCurrency(candidate.unitPriceEur),\n        totalPriceEur,\n        breakdown: [\n            {\n                type: \"\".concat(candidate.unitCapacityKwh, \" kWh\"),\n                count: candidate.count,\n                unitCapacityKwh: candidate.unitCapacityKwh,\n                unitPriceEur: roundCurrency(candidate.unitPriceEur),\n                totalPriceEur\n            }\n        ]\n    };\n}\nfunction selectMinimumCostBatteryOptions(requiredKwh) {\n    const normalizedRequired = Math.max(0, requiredKwh);\n    const candidates = [];\n    BATTERY_OPTIONS.forEach((option)=>{\n        var _option_unitPriceEur;\n        const unitPriceEur = (_option_unitPriceEur = option.unitPriceEur) !== null && _option_unitPriceEur !== void 0 ? _option_unitPriceEur : 0;\n        if (option.modular) {\n            const maxCount = Math.max(1, Math.ceil(normalizedRequired / option.capacityKwh));\n            for(let count = 1; count <= maxCount; count += 1){\n                const totalCapacityKwh = count * option.capacityKwh;\n                const totalPriceEur = count * unitPriceEur;\n                candidates.push({\n                    label: \"\".concat(count, \"\\xd7 \").concat(option.capacityKwh, \" kWh (modulair)\"),\n                    totalCapacityKwh,\n                    totalPriceEur,\n                    overCapacityKwh: totalCapacityKwh - normalizedRequired,\n                    count,\n                    unitCapacityKwh: option.capacityKwh,\n                    unitPriceEur\n                });\n            }\n            return;\n        }\n        if (option.capacityKwh >= normalizedRequired) {\n            candidates.push({\n                label: option.label,\n                totalCapacityKwh: option.capacityKwh,\n                totalPriceEur: unitPriceEur,\n                overCapacityKwh: option.capacityKwh - normalizedRequired,\n                count: 1,\n                unitCapacityKwh: option.capacityKwh,\n                unitPriceEur\n            });\n        }\n    });\n    const sorted = candidates.sort((a, b)=>a.totalPriceEur - b.totalPriceEur || a.overCapacityKwh - b.overCapacityKwh || a.totalCapacityKwh - b.totalCapacityKwh);\n    const recommendedProduct = toBatteryProduct(sorted[0]);\n    const alternativeProduct = sorted[1] ? toBatteryProduct(sorted[1]) : null;\n    return {\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction processIntervals(rows, contractedPowerKw) {\n    return rows.map((row)=>{\n        const timestamp = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(row.timestamp);\n        const normalizedTimestamp = Number.isNaN(timestamp.getTime()) ? row.timestamp : timestamp.toISOString();\n        const consumptionKw = row.consumptionKwh / 0.25;\n        const excessKw = Math.max(0, consumptionKw - contractedPowerKw);\n        return {\n            ...row,\n            timestamp: normalizedTimestamp,\n            consumptionKw,\n            excessKw,\n            excessKwh: excessKw * 0.25\n        };\n    });\n}\nfunction groupPeakEvents(intervals) {\n    const events = [];\n    let current = null;\n    intervals.forEach((interval, index)=>{\n        if (interval.excessKw > 0) {\n            if (!current) {\n                current = {\n                    peakTimestamp: interval.timestamp,\n                    durationIntervals: 0,\n                    maxExcessKw: 0,\n                    totalExcessKwh: 0,\n                    intervalIndexes: []\n                };\n            }\n            current.durationIntervals += 1;\n            if (interval.excessKw > current.maxExcessKw || interval.excessKw === current.maxExcessKw && interval.timestamp < current.peakTimestamp) {\n                current.maxExcessKw = interval.excessKw;\n                current.peakTimestamp = interval.timestamp;\n            }\n            current.totalExcessKwh += interval.excessKwh;\n            current.intervalIndexes.push(index);\n        } else if (current) {\n            events.push(current);\n            current = null;\n        }\n    });\n    if (current) {\n        events.push(current);\n    }\n    return events;\n}\nfunction percentile(values, p) {\n    if (values.length === 0) return 0;\n    const sorted = [\n        ...values\n    ].sort((a, b)=>a - b);\n    const idx = Math.ceil(p / 100 * sorted.length) - 1;\n    return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\n}\nfunction computeSizing(params) {\n    const { intervals, events, method, compliance, safetyFactor, efficiency } = params;\n    let kWhNeededRaw = 0;\n    let kWNeededRaw = 0;\n    if (method === \"MAX_PEAK\") {\n        const highestEnergyEvent = [\n            ...events\n        ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n        if (highestEnergyEvent) {\n            kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n            kWNeededRaw = highestEnergyEvent.maxExcessKw;\n        }\n    }\n    if (method === \"P95\") {\n        if (events.length < 20) {\n            const highestEnergyEvent = [\n                ...events\n            ].sort((a, b)=>b.totalExcessKwh - a.totalExcessKwh)[0];\n            if (highestEnergyEvent) {\n                kWhNeededRaw = highestEnergyEvent.totalExcessKwh;\n                kWNeededRaw = highestEnergyEvent.maxExcessKw;\n            }\n        } else {\n            kWhNeededRaw = percentile(events.map((event)=>event.totalExcessKwh), 95);\n            kWNeededRaw = percentile(events.map((event)=>event.maxExcessKw), 95);\n        }\n    }\n    if (method === \"FULL_COVERAGE\") {\n        const byDay = new Map();\n        intervals.forEach((interval)=>{\n            const day = interval.timestamp.slice(0, 10);\n            var _byDay_get;\n            const list = (_byDay_get = byDay.get(day)) !== null && _byDay_get !== void 0 ? _byDay_get : [];\n            list.push(interval);\n            byDay.set(day, list);\n        });\n        let maxDayEnergy = 0;\n        let maxDayPeak = 0;\n        byDay.forEach((dayIntervals)=>{\n            const dayEnergy = dayIntervals.reduce((sum, interval)=>sum + interval.excessKwh, 0);\n            if (dayEnergy > maxDayEnergy) {\n                maxDayEnergy = dayEnergy;\n                maxDayPeak = Math.max(...dayIntervals.map((interval)=>interval.excessKw));\n            }\n        });\n        kWhNeededRaw = maxDayEnergy;\n        kWNeededRaw = maxDayPeak;\n    }\n    kWhNeededRaw *= compliance;\n    kWNeededRaw *= compliance;\n    const kWhNeeded = kWhNeededRaw / efficiency * safetyFactor;\n    const kWNeeded = kWNeededRaw * safetyFactor;\n    const { recommendedProduct, alternativeProduct } = selectMinimumCostBatteryOptions(kWhNeeded);\n    return {\n        kWhNeededRaw,\n        kWNeededRaw,\n        kWhNeeded,\n        kWNeeded,\n        recommendedProduct,\n        alternativeProduct\n    };\n}\nfunction buildDataQualityReport(intervals) {\n    var _timestamps_, _timestamps_1;\n    if (intervals.length === 0) {\n        return {\n            rows: 0,\n            startDate: null,\n            endDate: null,\n            missingIntervalsCount: 0,\n            duplicateCount: 0,\n            non15MinIntervals: 0,\n            warnings: [\n                \"No rows found in dataset.\"\n            ]\n        };\n    }\n    const timestamps = intervals.map((row)=>new Date(row.timestamp)).filter((date)=>!Number.isNaN(date.getTime())).sort((a, b)=>a.getTime() - b.getTime());\n    const duplicateCount = timestamps.length - new Set(timestamps.map((d)=>d.toISOString())).size;\n    let non15MinIntervals = 0;\n    let missingIntervalsCount = 0;\n    for(let i = 1; i < timestamps.length; i += 1){\n        const diffMinutes = (timestamps[i].getTime() - timestamps[i - 1].getTime()) / 60000;\n        if (diffMinutes !== 15) {\n            non15MinIntervals += 1;\n            if (diffMinutes > 15) {\n                missingIntervalsCount += Math.max(0, Math.round(diffMinutes / 15) - 1);\n            }\n        }\n    }\n    const warnings = [];\n    if (duplicateCount > 0) warnings.push(\"Detected \".concat(duplicateCount, \" duplicate timestamps.\"));\n    if (non15MinIntervals > 0) {\n        warnings.push(\"Detected \".concat(non15MinIntervals, \" non-15-minute interval transitions.\"));\n    }\n    var _timestamps__toISOString, _timestamps__toISOString1;\n    return {\n        rows: intervals.length,\n        startDate: (_timestamps__toISOString = (_timestamps_ = timestamps[0]) === null || _timestamps_ === void 0 ? void 0 : _timestamps_.toISOString()) !== null && _timestamps__toISOString !== void 0 ? _timestamps__toISOString : null,\n        endDate: (_timestamps__toISOString1 = (_timestamps_1 = timestamps[timestamps.length - 1]) === null || _timestamps_1 === void 0 ? void 0 : _timestamps_1.toISOString()) !== null && _timestamps__toISOString1 !== void 0 ? _timestamps__toISOString1 : null,\n        missingIntervalsCount,\n        duplicateCount,\n        non15MinIntervals,\n        warnings\n    };\n}\nfunction findMaxObserved(intervals) {\n    if (intervals.length === 0) {\n        return {\n            maxObservedKw: 0,\n            maxObservedTimestamp: null\n        };\n    }\n    let maxObservedKw = -1;\n    let maxObservedTimestamp = null;\n    intervals.forEach((interval)=>{\n        if (interval.consumptionKw > maxObservedKw || interval.consumptionKw === maxObservedKw && maxObservedTimestamp !== null && interval.timestamp < maxObservedTimestamp) {\n            maxObservedKw = interval.consumptionKw;\n            maxObservedTimestamp = interval.timestamp;\n        }\n    });\n    return {\n        maxObservedKw,\n        maxObservedTimestamp\n    };\n}\nfunction selectTopExceededIntervals(intervals, day) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;\n    return intervals.filter((interval)=>(0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp) === day && interval.excessKw > 0).sort((a, b)=>b.excessKw - a.excessKw || a.timestamp.localeCompare(b.timestamp)).slice(0, limit).map((interval)=>({\n            timestamp: interval.timestamp,\n            consumption_kW: interval.consumptionKw,\n            excess_kW: interval.excessKw\n        }));\n}\nfunction buildDayProfile(intervals, dayIso) {\n    let intervalMinutes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15, timeZone = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"Europe/Amsterdam\";\n    if (!dayIso || intervalMinutes <= 0) return [];\n    const [year, month, day] = dayIso.split(\"-\").map(Number);\n    const dayStartLocal = new Date(year, month - 1, day, 0, 0, 0, 0);\n    if (Number.isNaN(dayStartLocal.getTime())) return [];\n    const slotsPerDay = Math.floor(24 * 60 / intervalMinutes);\n    const profile = Array.from({\n        length: slotsPerDay\n    }, (_, index)=>{\n        const minutes = index * intervalMinutes;\n        const hour = Math.floor(minutes / 60);\n        const minute = minutes % 60;\n        return {\n            timestampLabel: \"\".concat(String(hour).padStart(2, \"0\"), \":\").concat(String(minute).padStart(2, \"0\")),\n            timestampIso: new Date(dayStartLocal.getTime() + minutes * 60000).toISOString(),\n            observedKw: 0\n        };\n    });\n    intervals.forEach((interval)=>{\n        if ((0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalDayIso)(interval.timestamp, timeZone) !== dayIso) return;\n        const dt = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.parseTimestamp)(interval.timestamp);\n        if (Number.isNaN(dt.getTime())) return;\n        const { hour, minute } = (0,_datetime__WEBPACK_IMPORTED_MODULE_0__.getLocalHourMinute)(dt, timeZone);\n        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return;\n        const minuteOfDay = hour * 60 + minute;\n        const slotIndex = Math.floor(minuteOfDay / intervalMinutes);\n        if (slotIndex < 0 || slotIndex >= slotsPerDay) return;\n        profile[slotIndex].observedKw = Math.max(profile[slotIndex].observedKw, interval.consumptionKw);\n    });\n    return profile;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEtBQUssQ0FBQ2UsY0FBY3RCO1FBQzNDLElBQUl1QixZQUFZLEtBQUtBLGFBQWFqQixhQUFhO1FBRS9DRSxPQUFPLENBQUNlLFVBQVUsQ0FBQ0osVUFBVSxHQUFHakksS0FBS2EsR0FBRyxDQUFDeUcsT0FBTyxDQUFDZSxVQUFVLENBQUNKLFVBQVUsRUFBRW5GLFNBQVNSLGFBQWE7SUFDaEc7SUFFQSxPQUFPZ0Y7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvY2FsY3VsYXRpb25zLnRzPzNmNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TG9jYWxEYXlJc28sIGdldExvY2FsSG91ck1pbnV0ZSwgcGFyc2VUaW1lc3RhbXAgfSBmcm9tICcuL2RhdGV0aW1lJztcblxuZXhwb3J0IHR5cGUgTWV0aG9kID0gJ01BWF9QRUFLJyB8ICdQOTUnIHwgJ0ZVTExfQ09WRVJBR0UnO1xuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJ2YWxSZWNvcmQge1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nO1xyXG4gIGNvbnN1bXB0aW9uS3doOiBudW1iZXI7XHJcbiAgZXhwb3J0S3doPzogbnVtYmVyO1xyXG4gIHB2S3doPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NlZEludGVydmFsIGV4dGVuZHMgSW50ZXJ2YWxSZWNvcmQge1xyXG4gIGNvbnN1bXB0aW9uS3c6IG51bWJlcjtcclxuICBleGNlc3NLdzogbnVtYmVyO1xyXG4gIGV4Y2Vzc0t3aDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBlYWtFdmVudCB7XG4gIHBlYWtUaW1lc3RhbXA6IHN0cmluZztcbiAgZHVyYXRpb25JbnRlcnZhbHM6IG51bWJlcjtcbiAgbWF4RXhjZXNzS3c6IG51bWJlcjtcbiAgdG90YWxFeGNlc3NLd2g6IG51bWJlcjtcbiAgaW50ZXJ2YWxJbmRleGVzOiBudW1iZXJbXTtcbn1cblxyXG5leHBvcnQgaW50ZXJmYWNlIERhdGFRdWFsaXR5UmVwb3J0IHtcclxuICByb3dzOiBudW1iZXI7XHJcbiAgc3RhcnREYXRlOiBzdHJpbmcgfCBudWxsO1xyXG4gIGVuZERhdGU6IHN0cmluZyB8IG51bGw7XHJcbiAgbWlzc2luZ0ludGVydmFsc0NvdW50OiBudW1iZXI7XHJcbiAgZHVwbGljYXRlQ291bnQ6IG51bWJlcjtcclxuICBub24xNU1pbkludGVydmFsczogbnVtYmVyO1xyXG4gIHdhcm5pbmdzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTaXppbmdSZXN1bHQge1xyXG4gIGtXaE5lZWRlZFJhdzogbnVtYmVyO1xyXG4gIGtXTmVlZGVkUmF3OiBudW1iZXI7XHJcbiAga1doTmVlZGVkOiBudW1iZXI7XHJcbiAga1dOZWVkZWQ6IG51bWJlcjtcclxuICByZWNvbW1lbmRlZFByb2R1Y3Q6IEJhdHRlcnlQcm9kdWN0O1xyXG4gIGFsdGVybmF0aXZlUHJvZHVjdDogQmF0dGVyeVByb2R1Y3QgfCBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhdHRlcnlQcm9kdWN0IHtcbiAgbGFiZWw6IHN0cmluZztcbiAgY2FwYWNpdHlLd2g6IG51bWJlcjtcbiAgbW9kdWxhcj86IGJvb2xlYW47XG4gIHVuaXRQcmljZUV1cj86IG51bWJlcjtcbiAgdW5pdENhcGFjaXR5S3doPzogbnVtYmVyO1xuICBjb3VudD86IG51bWJlcjtcbiAgdG90YWxQcmljZUV1cj86IG51bWJlcjtcbiAgYnJlYWtkb3duPzogQmF0dGVyeUJyZWFrZG93bltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdHRlcnlCcmVha2Rvd24ge1xuICB0eXBlOiBzdHJpbmc7XG4gIGNvdW50OiBudW1iZXI7XG4gIHVuaXRDYXBhY2l0eUt3aDogbnVtYmVyO1xuICB1bml0UHJpY2VFdXI6IG51bWJlcjtcbiAgdG90YWxQcmljZUV1cjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4Y2VlZGVkSW50ZXJ2YWwge1xuICB0aW1lc3RhbXA6IHN0cmluZztcbiAgY29uc3VtcHRpb25fa1c6IG51bWJlcjtcbiAgZXhjZXNzX2tXOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5UHJvZmlsZVBvaW50IHtcbiAgdGltZXN0YW1wTGFiZWw6IHN0cmluZztcbiAgdGltZXN0YW1wSXNvOiBzdHJpbmc7XG4gIG9ic2VydmVkS3c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IEJBVFRFUllfT1BUSU9OUzogQmF0dGVyeVByb2R1Y3RbXSA9IFtcbiAge1xuICAgIGxhYmVsOiAnV2F0dHNOZXh0IEVTUyBDYWJpbmV0IDY0IGtXaCcsXG4gICAgY2FwYWNpdHlLd2g6IDY0LFxuICAgIG1vZHVsYXI6IHRydWUsXG4gICAgdW5pdFByaWNlRXVyOiAxNTY4OS4zM1xuICB9LFxuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgRVNTIENhYmluZXQgOTYga1doJyxcbiAgICBjYXBhY2l0eUt3aDogOTYsXG4gICAgbW9kdWxhcjogdHJ1ZSxcbiAgICB1bml0UHJpY2VFdXI6IDIyMjI1Ljk4XG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ0VTUyBBbGwtaW4tb25lIENhYmluZXQgMjYxIGtXaCcsXG4gICAgY2FwYWNpdHlLd2g6IDI2MSxcbiAgICBtb2R1bGFyOiB0cnVlLFxuICAgIHVuaXRQcmljZUV1cjogNDM5OTUuOTZcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnV2F0dHNOZXh0IEFsbC1pbi1vbmUgQ29udGFpbmVyIDIuMDkgTVdoJyxcbiAgICBjYXBhY2l0eUt3aDogMjA5MCxcbiAgICBtb2R1bGFyOiBmYWxzZSxcbiAgICB1bml0UHJpY2VFdXI6IDMxODY1OC4wNlxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdXYXR0c05leHQgQWxsIGluLW9uZSBDb250YWluZXIgNS4wMTUgTVdoJyxcbiAgICBjYXBhY2l0eUt3aDogNTAxNSxcbiAgICBtb2R1bGFyOiBmYWxzZSxcbiAgICB1bml0UHJpY2VFdXI6IDY3NTA1Mi40OVxuICB9XG5dO1xuXG5pbnRlcmZhY2UgQmF0dGVyeUNvbmZpZ3VyYXRpb25DYW5kaWRhdGUge1xuICBsYWJlbDogc3RyaW5nO1xuICB0b3RhbENhcGFjaXR5S3doOiBudW1iZXI7XG4gIHRvdGFsUHJpY2VFdXI6IG51bWJlcjtcbiAgb3ZlckNhcGFjaXR5S3doOiBudW1iZXI7XG4gIGNvdW50OiBudW1iZXI7XG4gIHVuaXRDYXBhY2l0eUt3aDogbnVtYmVyO1xuICB1bml0UHJpY2VFdXI6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gcm91bmRDdXJyZW5jeSh2YWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDApIC8gMTAwO1xufVxuXG5mdW5jdGlvbiB0b0JhdHRlcnlQcm9kdWN0KGNhbmRpZGF0ZTogQmF0dGVyeUNvbmZpZ3VyYXRpb25DYW5kaWRhdGUpOiBCYXR0ZXJ5UHJvZHVjdCB7XG4gIGNvbnN0IHRvdGFsUHJpY2VFdXIgPSByb3VuZEN1cnJlbmN5KGNhbmRpZGF0ZS50b3RhbFByaWNlRXVyKTtcbiAgcmV0dXJuIHtcbiAgICBsYWJlbDogY2FuZGlkYXRlLmxhYmVsLFxuICAgIGNhcGFjaXR5S3doOiBjYW5kaWRhdGUudG90YWxDYXBhY2l0eUt3aCxcbiAgICB1bml0Q2FwYWNpdHlLd2g6IGNhbmRpZGF0ZS51bml0Q2FwYWNpdHlLd2gsXG4gICAgY291bnQ6IGNhbmRpZGF0ZS5jb3VudCxcbiAgICB1bml0UHJpY2VFdXI6IHJvdW5kQ3VycmVuY3koY2FuZGlkYXRlLnVuaXRQcmljZUV1ciksXG4gICAgdG90YWxQcmljZUV1cixcbiAgICBicmVha2Rvd246IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogYCR7Y2FuZGlkYXRlLnVuaXRDYXBhY2l0eUt3aH0ga1doYCxcbiAgICAgICAgY291bnQ6IGNhbmRpZGF0ZS5jb3VudCxcbiAgICAgICAgdW5pdENhcGFjaXR5S3doOiBjYW5kaWRhdGUudW5pdENhcGFjaXR5S3doLFxuICAgICAgICB1bml0UHJpY2VFdXI6IHJvdW5kQ3VycmVuY3koY2FuZGlkYXRlLnVuaXRQcmljZUV1ciksXG4gICAgICAgIHRvdGFsUHJpY2VFdXJcbiAgICAgIH1cbiAgICBdXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RNaW5pbXVtQ29zdEJhdHRlcnlPcHRpb25zKHJlcXVpcmVkS3doOiBudW1iZXIpOiB7XG4gIHJlY29tbWVuZGVkUHJvZHVjdDogQmF0dGVyeVByb2R1Y3Q7XG4gIGFsdGVybmF0aXZlUHJvZHVjdDogQmF0dGVyeVByb2R1Y3QgfCBudWxsO1xufSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRSZXF1aXJlZCA9IE1hdGgubWF4KDAsIHJlcXVpcmVkS3doKTtcbiAgY29uc3QgY2FuZGlkYXRlczogQmF0dGVyeUNvbmZpZ3VyYXRpb25DYW5kaWRhdGVbXSA9IFtdO1xuXG4gIEJBVFRFUllfT1BUSU9OUy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICBjb25zdCB1bml0UHJpY2VFdXIgPSBvcHRpb24udW5pdFByaWNlRXVyID8/IDA7XG4gICAgaWYgKG9wdGlvbi5tb2R1bGFyKSB7XG4gICAgICBjb25zdCBtYXhDb3VudCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChub3JtYWxpemVkUmVxdWlyZWQgLyBvcHRpb24uY2FwYWNpdHlLd2gpKTtcbiAgICAgIGZvciAobGV0IGNvdW50ID0gMTsgY291bnQgPD0gbWF4Q291bnQ7IGNvdW50ICs9IDEpIHtcbiAgICAgICAgY29uc3QgdG90YWxDYXBhY2l0eUt3aCA9IGNvdW50ICogb3B0aW9uLmNhcGFjaXR5S3doO1xuICAgICAgICBjb25zdCB0b3RhbFByaWNlRXVyID0gY291bnQgKiB1bml0UHJpY2VFdXI7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgbGFiZWw6IGAke2NvdW50fVxcdTAwZDcgJHtvcHRpb24uY2FwYWNpdHlLd2h9IGtXaCAobW9kdWxhaXIpYCxcbiAgICAgICAgICB0b3RhbENhcGFjaXR5S3doLFxuICAgICAgICAgIHRvdGFsUHJpY2VFdXIsXG4gICAgICAgICAgb3ZlckNhcGFjaXR5S3doOiB0b3RhbENhcGFjaXR5S3doIC0gbm9ybWFsaXplZFJlcXVpcmVkLFxuICAgICAgICAgIGNvdW50LFxuICAgICAgICAgIHVuaXRDYXBhY2l0eUt3aDogb3B0aW9uLmNhcGFjaXR5S3doLFxuICAgICAgICAgIHVuaXRQcmljZUV1clxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uLmNhcGFjaXR5S3doID49IG5vcm1hbGl6ZWRSZXF1aXJlZCkge1xuICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgbGFiZWw6IG9wdGlvbi5sYWJlbCxcbiAgICAgICAgdG90YWxDYXBhY2l0eUt3aDogb3B0aW9uLmNhcGFjaXR5S3doLFxuICAgICAgICB0b3RhbFByaWNlRXVyOiB1bml0UHJpY2VFdXIsXG4gICAgICAgIG92ZXJDYXBhY2l0eUt3aDogb3B0aW9uLmNhcGFjaXR5S3doIC0gbm9ybWFsaXplZFJlcXVpcmVkLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgdW5pdENhcGFjaXR5S3doOiBvcHRpb24uY2FwYWNpdHlLd2gsXG4gICAgICAgIHVuaXRQcmljZUV1clxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBzb3J0ZWQgPSBjYW5kaWRhdGVzLnNvcnQoXG4gICAgKGEsIGIpID0+XG4gICAgICBhLnRvdGFsUHJpY2VFdXIgLSBiLnRvdGFsUHJpY2VFdXIgfHxcbiAgICAgIGEub3ZlckNhcGFjaXR5S3doIC0gYi5vdmVyQ2FwYWNpdHlLd2ggfHxcbiAgICAgIGEudG90YWxDYXBhY2l0eUt3aCAtIGIudG90YWxDYXBhY2l0eUt3aFxuICApO1xuXG4gIGNvbnN0IHJlY29tbWVuZGVkUHJvZHVjdCA9IHRvQmF0dGVyeVByb2R1Y3Qoc29ydGVkWzBdKTtcbiAgY29uc3QgYWx0ZXJuYXRpdmVQcm9kdWN0ID0gc29ydGVkWzFdID8gdG9CYXR0ZXJ5UHJvZHVjdChzb3J0ZWRbMV0pIDogbnVsbDtcblxuICByZXR1cm4geyByZWNvbW1lbmRlZFByb2R1Y3QsIGFsdGVybmF0aXZlUHJvZHVjdCB9O1xufVxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzSW50ZXJ2YWxzKFxuICByb3dzOiBJbnRlcnZhbFJlY29yZFtdLFxuICBjb250cmFjdGVkUG93ZXJLdzogbnVtYmVyXG4pOiBQcm9jZXNzZWRJbnRlcnZhbFtdIHtcbiAgcmV0dXJuIHJvd3MubWFwKChyb3cpID0+IHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZVRpbWVzdGFtcChyb3cudGltZXN0YW1wKTtcbiAgICBjb25zdCBub3JtYWxpemVkVGltZXN0YW1wID0gTnVtYmVyLmlzTmFOKHRpbWVzdGFtcC5nZXRUaW1lKCkpID8gcm93LnRpbWVzdGFtcCA6IHRpbWVzdGFtcC50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IGNvbnN1bXB0aW9uS3cgPSByb3cuY29uc3VtcHRpb25Ld2ggLyAwLjI1O1xuICAgIGNvbnN0IGV4Y2Vzc0t3ID0gTWF0aC5tYXgoMCwgY29uc3VtcHRpb25LdyAtIGNvbnRyYWN0ZWRQb3dlckt3KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucm93LFxuICAgICAgdGltZXN0YW1wOiBub3JtYWxpemVkVGltZXN0YW1wLFxuICAgICAgY29uc3VtcHRpb25LdyxcbiAgICAgIGV4Y2Vzc0t3LFxuICAgICAgZXhjZXNzS3doOiBleGNlc3NLdyAqIDAuMjVcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBQZWFrRXZlbnRzKGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSk6IFBlYWtFdmVudFtdIHtcbiAgY29uc3QgZXZlbnRzOiBQZWFrRXZlbnRbXSA9IFtdO1xuICBsZXQgY3VycmVudDogUGVha0V2ZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbnRlcnZhbC5leGNlc3NLdyA+IDApIHtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICBjdXJyZW50ID0ge1xuICAgICAgICAgIHBlYWtUaW1lc3RhbXA6IGludGVydmFsLnRpbWVzdGFtcCxcbiAgICAgICAgICBkdXJhdGlvbkludGVydmFsczogMCxcbiAgICAgICAgICBtYXhFeGNlc3NLdzogMCxcbiAgICAgICAgICB0b3RhbEV4Y2Vzc0t3aDogMCxcbiAgICAgICAgICBpbnRlcnZhbEluZGV4ZXM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjdXJyZW50LmR1cmF0aW9uSW50ZXJ2YWxzICs9IDE7XG4gICAgICBpZiAoXG4gICAgICAgIGludGVydmFsLmV4Y2Vzc0t3ID4gY3VycmVudC5tYXhFeGNlc3NLdyB8fFxuICAgICAgICAoaW50ZXJ2YWwuZXhjZXNzS3cgPT09IGN1cnJlbnQubWF4RXhjZXNzS3cgJiYgaW50ZXJ2YWwudGltZXN0YW1wIDwgY3VycmVudC5wZWFrVGltZXN0YW1wKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnQubWF4RXhjZXNzS3cgPSBpbnRlcnZhbC5leGNlc3NLdztcbiAgICAgICAgY3VycmVudC5wZWFrVGltZXN0YW1wID0gaW50ZXJ2YWwudGltZXN0YW1wO1xuICAgICAgfVxuICAgICAgY3VycmVudC50b3RhbEV4Y2Vzc0t3aCArPSBpbnRlcnZhbC5leGNlc3NLd2g7XG4gICAgICBjdXJyZW50LmludGVydmFsSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGV2ZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKGN1cnJlbnQpIHtcclxuICAgIGV2ZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGV2ZW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gcGVyY2VudGlsZSh2YWx1ZXM6IG51bWJlcltdLCBwOiBudW1iZXIpOiBudW1iZXIge1xyXG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcclxuICBjb25zdCBzb3J0ZWQgPSBbLi4udmFsdWVzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgY29uc3QgaWR4ID0gTWF0aC5jZWlsKChwIC8gMTAwKSAqIHNvcnRlZC5sZW5ndGgpIC0gMTtcclxuICByZXR1cm4gc29ydGVkW01hdGgubWF4KDAsIE1hdGgubWluKGlkeCwgc29ydGVkLmxlbmd0aCAtIDEpKV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2l6aW5nKHBhcmFtczoge1xyXG4gIGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXTtcclxuICBldmVudHM6IFBlYWtFdmVudFtdO1xyXG4gIG1ldGhvZDogTWV0aG9kO1xyXG4gIGNvbXBsaWFuY2U6IG51bWJlcjtcclxuICBzYWZldHlGYWN0b3I6IG51bWJlcjtcclxuICBlZmZpY2llbmN5OiBudW1iZXI7XHJcbn0pOiBTaXppbmdSZXN1bHQge1xyXG4gIGNvbnN0IHsgaW50ZXJ2YWxzLCBldmVudHMsIG1ldGhvZCwgY29tcGxpYW5jZSwgc2FmZXR5RmFjdG9yLCBlZmZpY2llbmN5IH0gPSBwYXJhbXM7XHJcblxyXG4gIGxldCBrV2hOZWVkZWRSYXcgPSAwO1xyXG4gIGxldCBrV05lZWRlZFJhdyA9IDA7XHJcblxyXG4gIGlmIChtZXRob2QgPT09ICdNQVhfUEVBSycpIHtcclxuICAgIGNvbnN0IGhpZ2hlc3RFbmVyZ3lFdmVudCA9IFsuLi5ldmVudHNdLnNvcnQoXHJcbiAgICAgIChhLCBiKSA9PiBiLnRvdGFsRXhjZXNzS3doIC0gYS50b3RhbEV4Y2Vzc0t3aFxyXG4gICAgKVswXTtcclxuICAgIGlmIChoaWdoZXN0RW5lcmd5RXZlbnQpIHtcclxuICAgICAga1doTmVlZGVkUmF3ID0gaGlnaGVzdEVuZXJneUV2ZW50LnRvdGFsRXhjZXNzS3doO1xyXG4gICAgICBrV05lZWRlZFJhdyA9IGhpZ2hlc3RFbmVyZ3lFdmVudC5tYXhFeGNlc3NLdztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChtZXRob2QgPT09ICdQOTUnKSB7XHJcbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA8IDIwKSB7XHJcbiAgICAgIGNvbnN0IGhpZ2hlc3RFbmVyZ3lFdmVudCA9IFsuLi5ldmVudHNdLnNvcnQoXHJcbiAgICAgICAgKGEsIGIpID0+IGIudG90YWxFeGNlc3NLd2ggLSBhLnRvdGFsRXhjZXNzS3doXHJcbiAgICAgIClbMF07XHJcbiAgICAgIGlmIChoaWdoZXN0RW5lcmd5RXZlbnQpIHtcclxuICAgICAgICBrV2hOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQudG90YWxFeGNlc3NLd2g7XHJcbiAgICAgICAga1dOZWVkZWRSYXcgPSBoaWdoZXN0RW5lcmd5RXZlbnQubWF4RXhjZXNzS3c7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGtXaE5lZWRlZFJhdyA9IHBlcmNlbnRpbGUoXHJcbiAgICAgICAgZXZlbnRzLm1hcCgoZXZlbnQpID0+IGV2ZW50LnRvdGFsRXhjZXNzS3doKSxcclxuICAgICAgICA5NVxyXG4gICAgICApO1xyXG4gICAgICBrV05lZWRlZFJhdyA9IHBlcmNlbnRpbGUoXHJcbiAgICAgICAgZXZlbnRzLm1hcCgoZXZlbnQpID0+IGV2ZW50Lm1heEV4Y2Vzc0t3KSxcclxuICAgICAgICA5NVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG1ldGhvZCA9PT0gJ0ZVTExfQ09WRVJBR0UnKSB7XHJcbiAgICBjb25zdCBieURheSA9IG5ldyBNYXA8c3RyaW5nLCBQcm9jZXNzZWRJbnRlcnZhbFtdPigpO1xyXG4gICAgaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRheSA9IGludGVydmFsLnRpbWVzdGFtcC5zbGljZSgwLCAxMCk7XHJcbiAgICAgIGNvbnN0IGxpc3QgPSBieURheS5nZXQoZGF5KSA/PyBbXTtcclxuICAgICAgbGlzdC5wdXNoKGludGVydmFsKTtcclxuICAgICAgYnlEYXkuc2V0KGRheSwgbGlzdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgbWF4RGF5RW5lcmd5ID0gMDtcclxuICAgIGxldCBtYXhEYXlQZWFrID0gMDtcclxuXHJcbiAgICBieURheS5mb3JFYWNoKChkYXlJbnRlcnZhbHMpID0+IHtcclxuICAgICAgY29uc3QgZGF5RW5lcmd5ID0gZGF5SW50ZXJ2YWxzLnJlZHVjZSgoc3VtLCBpbnRlcnZhbCkgPT4gc3VtICsgaW50ZXJ2YWwuZXhjZXNzS3doLCAwKTtcclxuICAgICAgaWYgKGRheUVuZXJneSA+IG1heERheUVuZXJneSkge1xyXG4gICAgICAgIG1heERheUVuZXJneSA9IGRheUVuZXJneTtcclxuICAgICAgICBtYXhEYXlQZWFrID0gTWF0aC5tYXgoLi4uZGF5SW50ZXJ2YWxzLm1hcCgoaW50ZXJ2YWwpID0+IGludGVydmFsLmV4Y2Vzc0t3KSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGtXaE5lZWRlZFJhdyA9IG1heERheUVuZXJneTtcclxuICAgIGtXTmVlZGVkUmF3ID0gbWF4RGF5UGVhaztcclxuICB9XHJcblxyXG4gIGtXaE5lZWRlZFJhdyAqPSBjb21wbGlhbmNlO1xyXG4gIGtXTmVlZGVkUmF3ICo9IGNvbXBsaWFuY2U7XHJcblxyXG4gIGNvbnN0IGtXaE5lZWRlZCA9IChrV2hOZWVkZWRSYXcgLyBlZmZpY2llbmN5KSAqIHNhZmV0eUZhY3RvcjtcclxuICBjb25zdCBrV05lZWRlZCA9IGtXTmVlZGVkUmF3ICogc2FmZXR5RmFjdG9yO1xyXG5cclxuICBjb25zdCB7IHJlY29tbWVuZGVkUHJvZHVjdCwgYWx0ZXJuYXRpdmVQcm9kdWN0IH0gPSBzZWxlY3RNaW5pbXVtQ29zdEJhdHRlcnlPcHRpb25zKGtXaE5lZWRlZCk7XG5cclxuICByZXR1cm4ge1xyXG4gICAga1doTmVlZGVkUmF3LFxyXG4gICAga1dOZWVkZWRSYXcsXHJcbiAgICBrV2hOZWVkZWQsXHJcbiAgICBrV05lZWRlZCxcclxuICAgIHJlY29tbWVuZGVkUHJvZHVjdCxcclxuICAgIGFsdGVybmF0aXZlUHJvZHVjdFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZERhdGFRdWFsaXR5UmVwb3J0KGludGVydmFsczogSW50ZXJ2YWxSZWNvcmRbXSk6IERhdGFRdWFsaXR5UmVwb3J0IHtcbiAgaWYgKGludGVydmFscy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJvd3M6IDAsXHJcbiAgICAgIHN0YXJ0RGF0ZTogbnVsbCxcclxuICAgICAgZW5kRGF0ZTogbnVsbCxcclxuICAgICAgbWlzc2luZ0ludGVydmFsc0NvdW50OiAwLFxyXG4gICAgICBkdXBsaWNhdGVDb3VudDogMCxcclxuICAgICAgbm9uMTVNaW5JbnRlcnZhbHM6IDAsXHJcbiAgICAgIHdhcm5pbmdzOiBbJ05vIHJvd3MgZm91bmQgaW4gZGF0YXNldC4nXVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBpbnRlcnZhbHNcclxuICAgIC5tYXAoKHJvdykgPT4gbmV3IERhdGUocm93LnRpbWVzdGFtcCkpXHJcbiAgICAuZmlsdGVyKChkYXRlKSA9PiAhTnVtYmVyLmlzTmFOKGRhdGUuZ2V0VGltZSgpKSlcclxuICAgIC5zb3J0KChhLCBiKSA9PiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpKTtcclxuXHJcbiAgY29uc3QgZHVwbGljYXRlQ291bnQgPSB0aW1lc3RhbXBzLmxlbmd0aCAtIG5ldyBTZXQodGltZXN0YW1wcy5tYXAoKGQpID0+IGQudG9JU09TdHJpbmcoKSkpLnNpemU7XHJcbiAgbGV0IG5vbjE1TWluSW50ZXJ2YWxzID0gMDtcclxuICBsZXQgbWlzc2luZ0ludGVydmFsc0NvdW50ID0gMDtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aW1lc3RhbXBzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICBjb25zdCBkaWZmTWludXRlcyA9ICh0aW1lc3RhbXBzW2ldLmdldFRpbWUoKSAtIHRpbWVzdGFtcHNbaSAtIDFdLmdldFRpbWUoKSkgLyA2MDAwMDtcclxuICAgIGlmIChkaWZmTWludXRlcyAhPT0gMTUpIHtcclxuICAgICAgbm9uMTVNaW5JbnRlcnZhbHMgKz0gMTtcclxuICAgICAgaWYgKGRpZmZNaW51dGVzID4gMTUpIHtcclxuICAgICAgICBtaXNzaW5nSW50ZXJ2YWxzQ291bnQgKz0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChkaWZmTWludXRlcyAvIDE1KSAtIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcclxuICBpZiAoZHVwbGljYXRlQ291bnQgPiAwKSB3YXJuaW5ncy5wdXNoKGBEZXRlY3RlZCAke2R1cGxpY2F0ZUNvdW50fSBkdXBsaWNhdGUgdGltZXN0YW1wcy5gKTtcclxuICBpZiAobm9uMTVNaW5JbnRlcnZhbHMgPiAwKSB7XHJcbiAgICB3YXJuaW5ncy5wdXNoKGBEZXRlY3RlZCAke25vbjE1TWluSW50ZXJ2YWxzfSBub24tMTUtbWludXRlIGludGVydmFsIHRyYW5zaXRpb25zLmApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHJvd3M6IGludGVydmFscy5sZW5ndGgsXHJcbiAgICBzdGFydERhdGU6IHRpbWVzdGFtcHNbMF0/LnRvSVNPU3RyaW5nKCkgPz8gbnVsbCxcclxuICAgIGVuZERhdGU6IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXT8udG9JU09TdHJpbmcoKSA/PyBudWxsLFxyXG4gICAgbWlzc2luZ0ludGVydmFsc0NvdW50LFxyXG4gICAgZHVwbGljYXRlQ291bnQsXHJcbiAgICBub24xNU1pbkludGVydmFscyxcclxuICAgIHdhcm5pbmdzXHJcbiAgfTtcclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZE1heE9ic2VydmVkKGludGVydmFsczogUHJvY2Vzc2VkSW50ZXJ2YWxbXSk6IHtcbiAgbWF4T2JzZXJ2ZWRLdzogbnVtYmVyO1xuICBtYXhPYnNlcnZlZFRpbWVzdGFtcDogc3RyaW5nIHwgbnVsbDtcbn0ge1xuICBpZiAoaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXhPYnNlcnZlZEt3OiAwLFxuICAgICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgbGV0IG1heE9ic2VydmVkS3cgPSAtMTtcbiAgbGV0IG1heE9ic2VydmVkVGltZXN0YW1wOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcbiAgICBpZiAoXG4gICAgICBpbnRlcnZhbC5jb25zdW1wdGlvbkt3ID4gbWF4T2JzZXJ2ZWRLdyB8fFxuICAgICAgKGludGVydmFsLmNvbnN1bXB0aW9uS3cgPT09IG1heE9ic2VydmVkS3cgJiZcbiAgICAgICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXAgIT09IG51bGwgJiZcbiAgICAgICAgaW50ZXJ2YWwudGltZXN0YW1wIDwgbWF4T2JzZXJ2ZWRUaW1lc3RhbXApXG4gICAgKSB7XG4gICAgICBtYXhPYnNlcnZlZEt3ID0gaW50ZXJ2YWwuY29uc3VtcHRpb25LdztcbiAgICAgIG1heE9ic2VydmVkVGltZXN0YW1wID0gaW50ZXJ2YWwudGltZXN0YW1wO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtYXhPYnNlcnZlZEt3LFxuICAgIG1heE9ic2VydmVkVGltZXN0YW1wXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RUb3BFeGNlZWRlZEludGVydmFscyhcbiAgaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdLFxuICBkYXk6IHN0cmluZyxcbiAgbGltaXQgPSAyMFxuKTogRXhjZWVkZWRJbnRlcnZhbFtdIHtcbiAgcmV0dXJuIGludGVydmFsc1xuICAgIC5maWx0ZXIoKGludGVydmFsKSA9PiBnZXRMb2NhbERheUlzbyhpbnRlcnZhbC50aW1lc3RhbXApID09PSBkYXkgJiYgaW50ZXJ2YWwuZXhjZXNzS3cgPiAwKVxuICAgIC5zb3J0KChhLCBiKSA9PiBiLmV4Y2Vzc0t3IC0gYS5leGNlc3NLdyB8fCBhLnRpbWVzdGFtcC5sb2NhbGVDb21wYXJlKGIudGltZXN0YW1wKSlcbiAgICAuc2xpY2UoMCwgbGltaXQpXG4gICAgLm1hcCgoaW50ZXJ2YWwpID0+ICh7XG4gICAgICB0aW1lc3RhbXA6IGludGVydmFsLnRpbWVzdGFtcCxcbiAgICAgIGNvbnN1bXB0aW9uX2tXOiBpbnRlcnZhbC5jb25zdW1wdGlvbkt3LFxuICAgICAgZXhjZXNzX2tXOiBpbnRlcnZhbC5leGNlc3NLd1xuICAgIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGF5UHJvZmlsZShcbiAgaW50ZXJ2YWxzOiBQcm9jZXNzZWRJbnRlcnZhbFtdLFxuICBkYXlJc286IHN0cmluZyxcbiAgaW50ZXJ2YWxNaW51dGVzID0gMTUsXG4gIHRpbWVab25lID0gJ0V1cm9wZS9BbXN0ZXJkYW0nXG4pOiBEYXlQcm9maWxlUG9pbnRbXSB7XG4gIGlmICghZGF5SXNvIHx8IGludGVydmFsTWludXRlcyA8PSAwKSByZXR1cm4gW107XG5cbiAgY29uc3QgW3llYXIsIG1vbnRoLCBkYXldID0gZGF5SXNvLnNwbGl0KCctJykubWFwKE51bWJlcik7XG4gIGNvbnN0IGRheVN0YXJ0TG9jYWwgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMCwgMCwgMCwgMCk7XG4gIGlmIChOdW1iZXIuaXNOYU4oZGF5U3RhcnRMb2NhbC5nZXRUaW1lKCkpKSByZXR1cm4gW107XG5cbiAgY29uc3Qgc2xvdHNQZXJEYXkgPSBNYXRoLmZsb29yKCgyNCAqIDYwKSAvIGludGVydmFsTWludXRlcyk7XG4gIGNvbnN0IHByb2ZpbGUgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzbG90c1BlckRheSB9LCAoXywgaW5kZXgpID0+IHtcbiAgICBjb25zdCBtaW51dGVzID0gaW5kZXggKiBpbnRlcnZhbE1pbnV0ZXM7XG4gICAgY29uc3QgaG91ciA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBjb25zdCBtaW51dGUgPSBtaW51dGVzICUgNjA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVzdGFtcExhYmVsOiBgJHtTdHJpbmcoaG91cikucGFkU3RhcnQoMiwgJzAnKX06JHtTdHJpbmcobWludXRlKS5wYWRTdGFydCgyLCAnMCcpfWAsXG4gICAgICB0aW1lc3RhbXBJc286IG5ldyBEYXRlKGRheVN0YXJ0TG9jYWwuZ2V0VGltZSgpICsgbWludXRlcyAqIDYwXzAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgIG9ic2VydmVkS3c6IDBcbiAgICB9O1xuICB9KTtcblxuICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcbiAgICBpZiAoZ2V0TG9jYWxEYXlJc28oaW50ZXJ2YWwudGltZXN0YW1wLCB0aW1lWm9uZSkgIT09IGRheUlzbykgcmV0dXJuO1xuXG4gICAgY29uc3QgZHQgPSBwYXJzZVRpbWVzdGFtcChpbnRlcnZhbC50aW1lc3RhbXApO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oZHQuZ2V0VGltZSgpKSkgcmV0dXJuO1xuICAgIGNvbnN0IHsgaG91ciwgbWludXRlIH0gPSBnZXRMb2NhbEhvdXJNaW51dGUoZHQsIHRpbWVab25lKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShob3VyKSB8fCAhTnVtYmVyLmlzRmluaXRlKG1pbnV0ZSkpIHJldHVybjtcblxuICAgIGNvbnN0IG1pbnV0ZU9mRGF5ID0gaG91ciAqIDYwICsgbWludXRlO1xuICAgIGNvbnN0IHNsb3RJbmRleCA9IE1hdGguZmxvb3IobWludXRlT2ZEYXkgLyBpbnRlcnZhbE1pbnV0ZXMpO1xuICAgIGlmIChzbG90SW5kZXggPCAwIHx8IHNsb3RJbmRleCA+PSBzbG90c1BlckRheSkgcmV0dXJuO1xuXG4gICAgcHJvZmlsZVtzbG90SW5kZXhdLm9ic2VydmVkS3cgPSBNYXRoLm1heChwcm9maWxlW3Nsb3RJbmRleF0ub2JzZXJ2ZWRLdywgaW50ZXJ2YWwuY29uc3VtcHRpb25Ldyk7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9maWxlO1xufVxuIl0sIm5hbWVzIjpbImdldExvY2FsRGF5SXNvIiwiZ2V0TG9jYWxIb3VyTWludXRlIiwicGFyc2VUaW1lc3RhbXAiLCJCQVRURVJZX09QVElPTlMiLCJsYWJlbCIsImNhcGFjaXR5S3doIiwibW9kdWxhciIsInVuaXRQcmljZUV1ciIsInJvdW5kQ3VycmVuY3kiLCJ2YWx1ZSIsIk1hdGgiLCJyb3VuZCIsInRvQmF0dGVyeVByb2R1Y3QiLCJjYW5kaWRhdGUiLCJ0b3RhbFByaWNlRXVyIiwidG90YWxDYXBhY2l0eUt3aCIsInVuaXRDYXBhY2l0eUt3aCIsImNvdW50IiwiYnJlYWtkb3duIiwidHlwZSIsInNlbGVjdE1pbmltdW1Db3N0QmF0dGVyeU9wdGlvbnMiLCJyZXF1aXJlZEt3aCIsIm5vcm1hbGl6ZWRSZXF1aXJlZCIsIm1heCIsImNhbmRpZGF0ZXMiLCJmb3JFYWNoIiwib3B0aW9uIiwibWF4Q291bnQiLCJjZWlsIiwicHVzaCIsIm92ZXJDYXBhY2l0eUt3aCIsInNvcnRlZCIsInNvcnQiLCJhIiwiYiIsInJlY29tbWVuZGVkUHJvZHVjdCIsImFsdGVybmF0aXZlUHJvZHVjdCIsInByb2Nlc3NJbnRlcnZhbHMiLCJyb3dzIiwiY29udHJhY3RlZFBvd2VyS3ciLCJtYXAiLCJyb3ciLCJ0aW1lc3RhbXAiLCJub3JtYWxpemVkVGltZXN0YW1wIiwiTnVtYmVyIiwiaXNOYU4iLCJnZXRUaW1lIiwidG9JU09TdHJpbmciLCJjb25zdW1wdGlvbkt3IiwiY29uc3VtcHRpb25Ld2giLCJleGNlc3NLdyIsImV4Y2Vzc0t3aCIsImdyb3VwUGVha0V2ZW50cyIsImludGVydmFscyIsImV2ZW50cyIsImN1cnJlbnQiLCJpbnRlcnZhbCIsImluZGV4IiwicGVha1RpbWVzdGFtcCIsImR1cmF0aW9uSW50ZXJ2YWxzIiwibWF4RXhjZXNzS3ciLCJ0b3RhbEV4Y2Vzc0t3aCIsImludGVydmFsSW5kZXhlcyIsInBlcmNlbnRpbGUiLCJ2YWx1ZXMiLCJwIiwibGVuZ3RoIiwiaWR4IiwibWluIiwiY29tcHV0ZVNpemluZyIsInBhcmFtcyIsIm1ldGhvZCIsImNvbXBsaWFuY2UiLCJzYWZldHlGYWN0b3IiLCJlZmZpY2llbmN5Iiwia1doTmVlZGVkUmF3Iiwia1dOZWVkZWRSYXciLCJoaWdoZXN0RW5lcmd5RXZlbnQiLCJldmVudCIsImJ5RGF5IiwiTWFwIiwiZGF5Iiwic2xpY2UiLCJsaXN0IiwiZ2V0Iiwic2V0IiwibWF4RGF5RW5lcmd5IiwibWF4RGF5UGVhayIsImRheUludGVydmFscyIsImRheUVuZXJneSIsInJlZHVjZSIsInN1bSIsImtXaE5lZWRlZCIsImtXTmVlZGVkIiwiYnVpbGREYXRhUXVhbGl0eVJlcG9ydCIsInRpbWVzdGFtcHMiLCJzdGFydERhdGUiLCJlbmREYXRlIiwibWlzc2luZ0ludGVydmFsc0NvdW50IiwiZHVwbGljYXRlQ291bnQiLCJub24xNU1pbkludGVydmFscyIsIndhcm5pbmdzIiwiRGF0ZSIsImZpbHRlciIsImRhdGUiLCJTZXQiLCJkIiwic2l6ZSIsImkiLCJkaWZmTWludXRlcyIsImZpbmRNYXhPYnNlcnZlZCIsIm1heE9ic2VydmVkS3ciLCJtYXhPYnNlcnZlZFRpbWVzdGFtcCIsInNlbGVjdFRvcEV4Y2VlZGVkSW50ZXJ2YWxzIiwibGltaXQiLCJsb2NhbGVDb21wYXJlIiwiY29uc3VtcHRpb25fa1ciLCJleGNlc3Nfa1ciLCJidWlsZERheVByb2ZpbGUiLCJkYXlJc28iLCJpbnRlcnZhbE1pbnV0ZXMiLCJ0aW1lWm9uZSIsInllYXIiLCJtb250aCIsInNwbGl0IiwiZGF5U3RhcnRMb2NhbCIsInNsb3RzUGVyRGF5IiwiZmxvb3IiLCJwcm9maWxlIiwiQXJyYXkiLCJmcm9tIiwiXyIsIm1pbnV0ZXMiLCJob3VyIiwibWludXRlIiwidGltZXN0YW1wTGFiZWwiLCJTdHJpbmciLCJwYWRTdGFydCIsInRpbWVzdGFtcElzbyIsIm9ic2VydmVkS3ciLCJkdCIsImlzRmluaXRlIiwibWludXRlT2ZEYXkiLCJzbG90SW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});